// Built from precompiled binaries at https://github.com/bblanchon/pdfium-binaries/releases/tag/chromium/4348
// PDFium version chromium/4348 [00c189677bec91cd04ba4b8c272f6cbbd13b959c]
// Built on: Thu, 10 Dec 2020 22:14:17 GMT
// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace PDFiumCore
{
    public enum FPDF_TEXT_RENDERMODE
    {
        FPDF_TEXTRENDERMODE_UNKNOWN = -1,
        FPDF_TEXTRENDERMODE_FILL = 0,
        FPDF_TEXTRENDERMODE_STROKE = 1,
        FPDF_TEXTRENDERMODE_FILL_STROKE = 2,
        FPDF_TEXTRENDERMODE_INVISIBLE = 3,
        FPDF_TEXTRENDERMODE_FILL_CLIP = 4,
        FPDF_TEXTRENDERMODE_STROKE_CLIP = 5,
        FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP = 6,
        FPDF_TEXTRENDERMODE_CLIP = 7,
        FPDF_TEXTRENDERMODE_LAST = 7
    }

    public enum FPDF_DUPLEXTYPE_
    {
        DuplexUndefined = 0,
        Simplex = 1,
        DuplexFlipShortEdge = 2,
        DuplexFlipLongEdge = 3
    }

    public unsafe partial class FpdfActionT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfActionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfActionT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfActionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfActionT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfActionT __CreateInstance(global::PDFiumCore.FpdfActionT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfActionT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfActionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfActionT.__Internal));
            *(global::PDFiumCore.FpdfActionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfActionT(global::PDFiumCore.FpdfActionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfActionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfAnnotationT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAnnotationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAnnotationT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfAnnotationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfAnnotationT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfAnnotationT __CreateInstance(global::PDFiumCore.FpdfAnnotationT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfAnnotationT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfAnnotationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfAnnotationT.__Internal));
            *(global::PDFiumCore.FpdfAnnotationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfAnnotationT(global::PDFiumCore.FpdfAnnotationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfAnnotationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfAttachmentT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAttachmentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfAttachmentT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfAttachmentT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfAttachmentT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfAttachmentT __CreateInstance(global::PDFiumCore.FpdfAttachmentT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfAttachmentT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfAttachmentT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfAttachmentT.__Internal));
            *(global::PDFiumCore.FpdfAttachmentT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfAttachmentT(global::PDFiumCore.FpdfAttachmentT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfAttachmentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfBitmapT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBitmapT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBitmapT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfBitmapT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfBitmapT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfBitmapT __CreateInstance(global::PDFiumCore.FpdfBitmapT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfBitmapT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfBitmapT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfBitmapT.__Internal));
            *(global::PDFiumCore.FpdfBitmapT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfBitmapT(global::PDFiumCore.FpdfBitmapT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfBitmapT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfBookmarkT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBookmarkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfBookmarkT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfBookmarkT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfBookmarkT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfBookmarkT __CreateInstance(global::PDFiumCore.FpdfBookmarkT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfBookmarkT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfBookmarkT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfBookmarkT.__Internal));
            *(global::PDFiumCore.FpdfBookmarkT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfBookmarkT(global::PDFiumCore.FpdfBookmarkT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfBookmarkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfClippathT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfClippathT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfClippathT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfClippathT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfClippathT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfClippathT __CreateInstance(global::PDFiumCore.FpdfClippathT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfClippathT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfClippathT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfClippathT.__Internal));
            *(global::PDFiumCore.FpdfClippathT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfClippathT(global::PDFiumCore.FpdfClippathT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfClippathT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfDestT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDestT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDestT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfDestT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfDestT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfDestT __CreateInstance(global::PDFiumCore.FpdfDestT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfDestT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfDestT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfDestT.__Internal));
            *(global::PDFiumCore.FpdfDestT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfDestT(global::PDFiumCore.FpdfDestT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfDestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfDocumentT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDocumentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfDocumentT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfDocumentT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfDocumentT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfDocumentT __CreateInstance(global::PDFiumCore.FpdfDocumentT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfDocumentT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfDocumentT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfDocumentT.__Internal));
            *(global::PDFiumCore.FpdfDocumentT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfDocumentT(global::PDFiumCore.FpdfDocumentT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfDocumentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfFontT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFontT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFontT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfFontT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfFontT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfFontT __CreateInstance(global::PDFiumCore.FpdfFontT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfFontT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfFontT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfFontT.__Internal));
            *(global::PDFiumCore.FpdfFontT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfFontT(global::PDFiumCore.FpdfFontT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfFontT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfFormHandleT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFormHandleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfFormHandleT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfFormHandleT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfFormHandleT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfFormHandleT __CreateInstance(global::PDFiumCore.FpdfFormHandleT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfFormHandleT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfFormHandleT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfFormHandleT.__Internal));
            *(global::PDFiumCore.FpdfFormHandleT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfFormHandleT(global::PDFiumCore.FpdfFormHandleT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfFormHandleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfJavascriptActionT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfJavascriptActionT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfJavascriptActionT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfJavascriptActionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfJavascriptActionT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfJavascriptActionT __CreateInstance(global::PDFiumCore.FpdfJavascriptActionT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfJavascriptActionT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfJavascriptActionT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfJavascriptActionT.__Internal));
            *(global::PDFiumCore.FpdfJavascriptActionT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfJavascriptActionT(global::PDFiumCore.FpdfJavascriptActionT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfJavascriptActionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfLinkT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfLinkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfLinkT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfLinkT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfLinkT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfLinkT __CreateInstance(global::PDFiumCore.FpdfLinkT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfLinkT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfLinkT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfLinkT.__Internal));
            *(global::PDFiumCore.FpdfLinkT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfLinkT(global::PDFiumCore.FpdfLinkT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfLinkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPageT __CreateInstance(global::PDFiumCore.FpdfPageT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPageT.__Internal));
            *(global::PDFiumCore.FpdfPageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageT(global::PDFiumCore.FpdfPageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPagelinkT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagelinkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagelinkT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPagelinkT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPagelinkT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPagelinkT __CreateInstance(global::PDFiumCore.FpdfPagelinkT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPagelinkT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPagelinkT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPagelinkT.__Internal));
            *(global::PDFiumCore.FpdfPagelinkT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPagelinkT(global::PDFiumCore.FpdfPagelinkT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPagelinkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageobjectT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPageobjectT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageobjectT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPageobjectT __CreateInstance(global::PDFiumCore.FpdfPageobjectT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageobjectT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPageobjectT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPageobjectT.__Internal));
            *(global::PDFiumCore.FpdfPageobjectT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageobjectT(global::PDFiumCore.FpdfPageobjectT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageobjectT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPageobjectmarkT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectmarkT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPageobjectmarkT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPageobjectmarkT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageobjectmarkT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPageobjectmarkT __CreateInstance(global::PDFiumCore.FpdfPageobjectmarkT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPageobjectmarkT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPageobjectmarkT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPageobjectmarkT.__Internal));
            *(global::PDFiumCore.FpdfPageobjectmarkT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPageobjectmarkT(global::PDFiumCore.FpdfPageobjectmarkT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPageobjectmarkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPagerangeT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagerangeT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPagerangeT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPagerangeT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPagerangeT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPagerangeT __CreateInstance(global::PDFiumCore.FpdfPagerangeT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPagerangeT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPagerangeT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPagerangeT.__Internal));
            *(global::PDFiumCore.FpdfPagerangeT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPagerangeT(global::PDFiumCore.FpdfPagerangeT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPagerangeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfPathsegmentT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPathsegmentT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfPathsegmentT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfPathsegmentT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPathsegmentT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfPathsegmentT __CreateInstance(global::PDFiumCore.FpdfPathsegmentT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfPathsegmentT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfPathsegmentT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfPathsegmentT.__Internal));
            *(global::PDFiumCore.FpdfPathsegmentT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPathsegmentT(global::PDFiumCore.FpdfPathsegmentT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfPathsegmentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfSchhandleT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSchhandleT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSchhandleT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfSchhandleT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfSchhandleT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfSchhandleT __CreateInstance(global::PDFiumCore.FpdfSchhandleT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfSchhandleT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfSchhandleT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfSchhandleT.__Internal));
            *(global::PDFiumCore.FpdfSchhandleT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfSchhandleT(global::PDFiumCore.FpdfSchhandleT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfSchhandleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfSignatureT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSignatureT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfSignatureT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfSignatureT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfSignatureT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfSignatureT __CreateInstance(global::PDFiumCore.FpdfSignatureT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfSignatureT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfSignatureT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfSignatureT.__Internal));
            *(global::PDFiumCore.FpdfSignatureT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfSignatureT(global::PDFiumCore.FpdfSignatureT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfSignatureT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfStructelementT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructelementT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfStructelementT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfStructelementT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfStructelementT __CreateInstance(global::PDFiumCore.FpdfStructelementT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfStructelementT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfStructelementT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfStructelementT.__Internal));
            *(global::PDFiumCore.FpdfStructelementT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfStructelementT(global::PDFiumCore.FpdfStructelementT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfStructelementT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfStructtreeT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructtreeT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfStructtreeT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfStructtreeT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfStructtreeT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfStructtreeT __CreateInstance(global::PDFiumCore.FpdfStructtreeT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfStructtreeT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfStructtreeT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfStructtreeT.__Internal));
            *(global::PDFiumCore.FpdfStructtreeT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfStructtreeT(global::PDFiumCore.FpdfStructtreeT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfStructtreeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfTextpageT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfTextpageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfTextpageT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfTextpageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfTextpageT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfTextpageT __CreateInstance(global::PDFiumCore.FpdfTextpageT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfTextpageT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfTextpageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfTextpageT.__Internal));
            *(global::PDFiumCore.FpdfTextpageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfTextpageT(global::PDFiumCore.FpdfTextpageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfTextpageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FpdfWidgetT
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfWidgetT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FpdfWidgetT>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FpdfWidgetT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfWidgetT(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FpdfWidgetT __CreateInstance(global::PDFiumCore.FpdfWidgetT.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FpdfWidgetT(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FpdfWidgetT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FpdfWidgetT.__Internal));
            *(global::PDFiumCore.FpdfWidgetT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfWidgetT(global::PDFiumCore.FpdfWidgetT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FpdfWidgetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class FPDF_BSTR_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr str;

            [FieldOffset(8)]
            internal int len;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_BSTR_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_BSTR_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_BSTR_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_BSTR_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_BSTR_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_BSTR_ __CreateInstance(global::PDFiumCore.FPDF_BSTR_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_BSTR_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_BSTR_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_BSTR_.__Internal));
            *(global::PDFiumCore.FPDF_BSTR_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_BSTR_(global::PDFiumCore.FPDF_BSTR_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_BSTR_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_BSTR_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_BSTR_(global::PDFiumCore.FPDF_BSTR_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_BSTR_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_BSTR_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_BSTR_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Str
        {
            get
            {
                return (sbyte*) ((global::PDFiumCore.FPDF_BSTR_.__Internal*) __Instance)->str;
            }

            set
            {
                ((global::PDFiumCore.FPDF_BSTR_.__Internal*)__Instance)->str = (global::System.IntPtr) value;
            }
        }

        public int Len
        {
            get
            {
                return ((global::PDFiumCore.FPDF_BSTR_.__Internal*) __Instance)->len;
            }

            set
            {
                ((global::PDFiumCore.FPDF_BSTR_.__Internal*)__Instance)->len = value;
            }
        }
    }

    public unsafe partial class FS_MATRIX_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float a;

            [FieldOffset(4)]
            internal float b;

            [FieldOffset(8)]
            internal float c;

            [FieldOffset(12)]
            internal float d;

            [FieldOffset(16)]
            internal float e;

            [FieldOffset(20)]
            internal float f;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FS_MATRIX_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_MATRIX_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_MATRIX_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FS_MATRIX_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_MATRIX_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FS_MATRIX_ __CreateInstance(global::PDFiumCore.FS_MATRIX_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_MATRIX_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FS_MATRIX_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_MATRIX_.__Internal));
            *(global::PDFiumCore.FS_MATRIX_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_MATRIX_(global::PDFiumCore.FS_MATRIX_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_MATRIX_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FS_MATRIX_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_MATRIX_(global::PDFiumCore.FS_MATRIX_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance) = *((global::PDFiumCore.FS_MATRIX_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FS_MATRIX_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float A
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->a;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->a = value;
            }
        }

        public float B
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->b;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->b = value;
            }
        }

        public float C
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->c;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->c = value;
            }
        }

        public float D
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->d;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->d = value;
            }
        }

        public float E
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->e;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->e = value;
            }
        }

        public float F
        {
            get
            {
                return ((global::PDFiumCore.FS_MATRIX_.__Internal*) __Instance)->f;
            }

            set
            {
                ((global::PDFiumCore.FS_MATRIX_.__Internal*)__Instance)->f = value;
            }
        }
    }

    public unsafe partial class FS_RECTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float left;

            [FieldOffset(4)]
            internal float top;

            [FieldOffset(8)]
            internal float right;

            [FieldOffset(12)]
            internal float bottom;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FS_RECTF_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_RECTF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_RECTF_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FS_RECTF_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_RECTF_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FS_RECTF_ __CreateInstance(global::PDFiumCore.FS_RECTF_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_RECTF_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FS_RECTF_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_RECTF_.__Internal));
            *(global::PDFiumCore.FS_RECTF_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_RECTF_(global::PDFiumCore.FS_RECTF_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_RECTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FS_RECTF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_RECTF_(global::PDFiumCore.FS_RECTF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_RECTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FS_RECTF_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Left
        {
            get
            {
                return ((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance)->left;
            }

            set
            {
                ((global::PDFiumCore.FS_RECTF_.__Internal*)__Instance)->left = value;
            }
        }

        public float Top
        {
            get
            {
                return ((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance)->top;
            }

            set
            {
                ((global::PDFiumCore.FS_RECTF_.__Internal*)__Instance)->top = value;
            }
        }

        public float Right
        {
            get
            {
                return ((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance)->right;
            }

            set
            {
                ((global::PDFiumCore.FS_RECTF_.__Internal*)__Instance)->right = value;
            }
        }

        public float Bottom
        {
            get
            {
                return ((global::PDFiumCore.FS_RECTF_.__Internal*) __Instance)->bottom;
            }

            set
            {
                ((global::PDFiumCore.FS_RECTF_.__Internal*)__Instance)->bottom = value;
            }
        }
    }

    public unsafe partial class FS_SIZEF_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float width;

            [FieldOffset(4)]
            internal float height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FS_SIZEF_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_SIZEF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_SIZEF_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FS_SIZEF_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_SIZEF_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FS_SIZEF_ __CreateInstance(global::PDFiumCore.FS_SIZEF_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_SIZEF_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FS_SIZEF_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_SIZEF_.__Internal));
            *(global::PDFiumCore.FS_SIZEF_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_SIZEF_(global::PDFiumCore.FS_SIZEF_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_SIZEF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FS_SIZEF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_SIZEF_(global::PDFiumCore.FS_SIZEF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_SIZEF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_SIZEF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FS_SIZEF_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Width
        {
            get
            {
                return ((global::PDFiumCore.FS_SIZEF_.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::PDFiumCore.FS_SIZEF_.__Internal*)__Instance)->width = value;
            }
        }

        public float Height
        {
            get
            {
                return ((global::PDFiumCore.FS_SIZEF_.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::PDFiumCore.FS_SIZEF_.__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class FS_POINTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FS_POINTF_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_POINTF_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_POINTF_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FS_POINTF_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_POINTF_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FS_POINTF_ __CreateInstance(global::PDFiumCore.FS_POINTF_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_POINTF_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FS_POINTF_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_POINTF_.__Internal));
            *(global::PDFiumCore.FS_POINTF_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_POINTF_(global::PDFiumCore.FS_POINTF_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_POINTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FS_POINTF_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_POINTF_(global::PDFiumCore.FS_POINTF_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_POINTF_.__Internal*) __Instance) = *((global::PDFiumCore.FS_POINTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FS_POINTF_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::PDFiumCore.FS_POINTF_.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::PDFiumCore.FS_POINTF_.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::PDFiumCore.FS_POINTF_.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::PDFiumCore.FS_POINTF_.__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class FPDF_LIBRARY_CONFIG_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pUserFontPaths;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pIsolate;

            [FieldOffset(24)]
            internal uint m_v8EmbedderSlot;

            [FieldOffset(32)]
            internal global::System.IntPtr m_pPlatform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_LIBRARY_CONFIG_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_LIBRARY_CONFIG_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_LIBRARY_CONFIG_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_LIBRARY_CONFIG_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_LIBRARY_CONFIG_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_LIBRARY_CONFIG_ __CreateInstance(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_LIBRARY_CONFIG_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal));
            *(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_LIBRARY_CONFIG_(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_LIBRARY_CONFIG_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_LIBRARY_CONFIG_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_LIBRARY_CONFIG_(global::PDFiumCore.FPDF_LIBRARY_CONFIG_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_LIBRARY_CONFIG_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*)__Instance)->version = value;
            }
        }

        public global::System.IntPtr MPIsolate
        {
            get
            {
                return ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance)->m_pIsolate;
            }

            set
            {
                ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*)__Instance)->m_pIsolate = (global::System.IntPtr) value;
            }
        }

        public uint MV8EmbedderSlot
        {
            get
            {
                return ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance)->m_v8EmbedderSlot;
            }

            set
            {
                ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*)__Instance)->m_v8EmbedderSlot = value;
            }
        }

        public global::System.IntPtr MPPlatform
        {
            get
            {
                return ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance)->m_pPlatform;
            }

            set
            {
                ((global::PDFiumCore.FPDF_LIBRARY_CONFIG_.__Internal*)__Instance)->m_pPlatform = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class FPDF_FILEACCESS : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_FileLen;

            [FieldOffset(8)]
            internal global::System.IntPtr m_GetBlock;

            [FieldOffset(16)]
            internal global::System.IntPtr m_Param;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_FILEACCESS@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEACCESS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEACCESS>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_FILEACCESS __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEACCESS(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_FILEACCESS __CreateInstance(global::PDFiumCore.FPDF_FILEACCESS.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEACCESS(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_FILEACCESS.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEACCESS.__Internal));
            *(global::PDFiumCore.FPDF_FILEACCESS.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEACCESS(global::PDFiumCore.FPDF_FILEACCESS.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEACCESS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_FILEACCESS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEACCESS(global::PDFiumCore.FPDF_FILEACCESS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_FILEACCESS __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MFileLen
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __Instance)->m_FileLen;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*)__Instance)->m_FileLen = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_uint_bytePtr_uint MGetBlock
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __Instance)->m_GetBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_uint_bytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_uint_bytePtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*)__Instance)->m_GetBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr MParam
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*) __Instance)->m_Param;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEACCESS.__Internal*)__Instance)->m_Param = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class FPDF_FILEHANDLER_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr clientData;

            [FieldOffset(8)]
            internal global::System.IntPtr Release;

            [FieldOffset(16)]
            internal global::System.IntPtr GetSize;

            [FieldOffset(24)]
            internal global::System.IntPtr ReadBlock;

            [FieldOffset(32)]
            internal global::System.IntPtr WriteBlock;

            [FieldOffset(40)]
            internal global::System.IntPtr Flush;

            [FieldOffset(48)]
            internal global::System.IntPtr Truncate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_FILEHANDLER_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEHANDLER_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEHANDLER_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_FILEHANDLER_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEHANDLER_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_FILEHANDLER_ __CreateInstance(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEHANDLER_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal));
            *(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEHANDLER_(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEHANDLER_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_FILEHANDLER_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEHANDLER_(global::PDFiumCore.FPDF_FILEHANDLER_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_FILEHANDLER_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr ClientData
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->clientData;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->clientData = (global::System.IntPtr) value;
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr Release
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint_IntPtr GetSize
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->GetSize;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->GetSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint ReadBlock
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->ReadBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->ReadBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint WriteBlock
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_uint_IntPtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr Flush
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->Flush;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->Flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_uint Truncate
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*) __Instance)->Truncate;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEHANDLER_.__Internal*)__Instance)->Truncate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FPDF_COLORSCHEME_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint path_fill_color;

            [FieldOffset(4)]
            internal uint path_stroke_color;

            [FieldOffset(8)]
            internal uint text_fill_color;

            [FieldOffset(12)]
            internal uint text_stroke_color;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_COLORSCHEME_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_COLORSCHEME_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_COLORSCHEME_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_COLORSCHEME_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_COLORSCHEME_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_COLORSCHEME_ __CreateInstance(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_COLORSCHEME_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal));
            *(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_COLORSCHEME_(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_COLORSCHEME_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_COLORSCHEME_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_COLORSCHEME_(global::PDFiumCore.FPDF_COLORSCHEME_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_COLORSCHEME_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PathFillColor
        {
            get
            {
                return ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance)->path_fill_color;
            }

            set
            {
                ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*)__Instance)->path_fill_color = value;
            }
        }

        public uint PathStrokeColor
        {
            get
            {
                return ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance)->path_stroke_color;
            }

            set
            {
                ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*)__Instance)->path_stroke_color = value;
            }
        }

        public uint TextFillColor
        {
            get
            {
                return ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance)->text_fill_color;
            }

            set
            {
                ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*)__Instance)->text_fill_color = value;
            }
        }

        public uint TextStrokeColor
        {
            get
            {
                return ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*) __Instance)->text_stroke_color;
            }

            set
            {
                ((global::PDFiumCore.FPDF_COLORSCHEME_.__Internal*)__Instance)->text_stroke_color = value;
            }
        }
    }

    public unsafe partial class fpdfview
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_InitLibrary")]
            internal static extern void FPDF_InitLibrary();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_InitLibraryWithConfig")]
            internal static extern void FPDF_InitLibraryWithConfig(global::System.IntPtr config);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_DestroyLibrary")]
            internal static extern void FPDF_DestroyLibrary();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SetSandBoxPolicy")]
            internal static extern void FPDF_SetSandBoxPolicy(uint policy, int enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadDocument")]
            internal static extern global::System.IntPtr FPDF_LoadDocument([MarshalAs(UnmanagedType.LPUTF8Str)] string file_path, [MarshalAs(UnmanagedType.LPUTF8Str)] string password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadMemDocument")]
            internal static extern global::System.IntPtr FPDF_LoadMemDocument(global::System.IntPtr data_buf, int size, [MarshalAs(UnmanagedType.LPUTF8Str)] string password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadMemDocument64")]
            internal static extern global::System.IntPtr FPDF_LoadMemDocument64(global::System.IntPtr data_buf, ulong size, [MarshalAs(UnmanagedType.LPUTF8Str)] string password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadCustomDocument")]
            internal static extern global::System.IntPtr FPDF_LoadCustomDocument(global::System.IntPtr pFileAccess, [MarshalAs(UnmanagedType.LPUTF8Str)] string password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetFileVersion")]
            internal static extern int FPDF_GetFileVersion(global::System.IntPtr doc, int* fileVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetLastError")]
            internal static extern uint FPDF_GetLastError();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_DocumentHasValidCrossReferenceTable")]
            internal static extern int FPDF_DocumentHasValidCrossReferenceTable(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetTrailerEnds")]
            internal static extern uint FPDF_GetTrailerEnds(global::System.IntPtr document, uint* buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetDocPermissions")]
            internal static extern uint FPDF_GetDocPermissions(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetSecurityHandlerRevision")]
            internal static extern int FPDF_GetSecurityHandlerRevision(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageCount")]
            internal static extern int FPDF_GetPageCount(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadPage")]
            internal static extern global::System.IntPtr FPDF_LoadPage(global::System.IntPtr document, int page_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageWidthF")]
            internal static extern float FPDF_GetPageWidthF(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageWidth")]
            internal static extern double FPDF_GetPageWidth(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageHeightF")]
            internal static extern float FPDF_GetPageHeightF(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageHeight")]
            internal static extern double FPDF_GetPageHeight(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageBoundingBox")]
            internal static extern int FPDF_GetPageBoundingBox(global::System.IntPtr page, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageSizeByIndexF")]
            internal static extern int FPDF_GetPageSizeByIndexF(global::System.IntPtr document, int page_index, global::System.IntPtr size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageSizeByIndex")]
            internal static extern int FPDF_GetPageSizeByIndex(global::System.IntPtr document, int page_index, double* width, double* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPageBitmap")]
            internal static extern void FPDF_RenderPageBitmap(global::System.IntPtr bitmap, global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPageBitmapWithMatrix")]
            internal static extern void FPDF_RenderPageBitmapWithMatrix(global::System.IntPtr bitmap, global::System.IntPtr page, global::System.IntPtr matrix, global::System.IntPtr clipping, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_ClosePage")]
            internal static extern void FPDF_ClosePage(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_CloseDocument")]
            internal static extern void FPDF_CloseDocument(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_DeviceToPage")]
            internal static extern int FPDF_DeviceToPage(global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, double* page_x, double* page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_PageToDevice")]
            internal static extern int FPDF_PageToDevice(global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, int* device_x, int* device_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_Create")]
            internal static extern global::System.IntPtr FPDFBitmapCreate(int width, int height, int alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_CreateEx")]
            internal static extern global::System.IntPtr FPDFBitmapCreateEx(int width, int height, int format, global::System.IntPtr first_scan, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_GetFormat")]
            internal static extern int FPDFBitmapGetFormat(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_FillRect")]
            internal static extern void FPDFBitmapFillRect(global::System.IntPtr bitmap, int left, int top, int width, int height, uint color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_GetBuffer")]
            internal static extern global::System.IntPtr FPDFBitmapGetBuffer(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_GetWidth")]
            internal static extern int FPDFBitmapGetWidth(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_GetHeight")]
            internal static extern int FPDFBitmapGetHeight(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_GetStride")]
            internal static extern int FPDFBitmapGetStride(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBitmap_Destroy")]
            internal static extern void FPDFBitmapDestroy(global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetPrintScaling")]
            internal static extern int FPDF_VIEWERREF_GetPrintScaling(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetNumCopies")]
            internal static extern int FPDF_VIEWERREF_GetNumCopies(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetPrintPageRange")]
            internal static extern global::System.IntPtr FPDF_VIEWERREF_GetPrintPageRange(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetPrintPageRangeCount")]
            internal static extern ulong FPDF_VIEWERREF_GetPrintPageRangeCount(global::System.IntPtr pagerange);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetPrintPageRangeElement")]
            internal static extern int FPDF_VIEWERREF_GetPrintPageRangeElement(global::System.IntPtr pagerange, ulong index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetDuplex")]
            internal static extern global::PDFiumCore.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_VIEWERREF_GetName")]
            internal static extern uint FPDF_VIEWERREF_GetName(global::System.IntPtr document, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_CountNamedDests")]
            internal static extern uint FPDF_CountNamedDests(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetNamedDestByName")]
            internal static extern global::System.IntPtr FPDF_GetNamedDestByName(global::System.IntPtr document, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetNamedDest")]
            internal static extern global::System.IntPtr FPDF_GetNamedDest(global::System.IntPtr document, int index, global::System.IntPtr buffer, int* buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetXFAPacketCount")]
            internal static extern int FPDF_GetXFAPacketCount(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetXFAPacketName")]
            internal static extern uint FPDF_GetXFAPacketName(global::System.IntPtr document, int index, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetXFAPacketContent")]
            internal static extern int FPDF_GetXFAPacketContent(global::System.IntPtr document, int index, global::System.IntPtr buffer, uint buflen, uint* out_buflen);
        }

        /// <summary>
        /// <para>Function: FPDF_InitLibrary</para>
        /// <para>Initialize the FPDFSDK library</para>
        /// <para>Parameters:</para>
        /// <para>None</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: Convenience function to call FPDF_InitLibraryWithConfig() for backwards compatibility purposes. This will be deprecated in the future.</para>
        /// </summary>
        public static void FPDF_InitLibrary()
        {
            __Internal.FPDF_InitLibrary();
        }

        /// <summary>
        /// <para>Function: FPDF_InitLibraryWithConfig</para>
        /// <para>Initialize the FPDFSDK library</para>
        /// <para>Parameters:</para>
        /// <para>config - configuration information as above.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: You have to call this function before you can call any PDF processing functions.</para>
        /// </summary>
        public static void FPDF_InitLibraryWithConfig(global::PDFiumCore.FPDF_LIBRARY_CONFIG_ config)
        {
            var __arg0 = ReferenceEquals(config, null) ? global::System.IntPtr.Zero : config.__Instance;
            __Internal.FPDF_InitLibraryWithConfig(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_DestroyLibary</para>
        /// <para>Release all resources allocated by the FPDFSDK library.</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: You can call this function to release all memory blocks allocated by the library. After this function is called, you should not call any PDF processing functions.</para>
        /// </summary>
        public static void FPDF_DestroyLibrary()
        {
            __Internal.FPDF_DestroyLibrary();
        }

        /// <summary>
        /// <para>Function: FPDF_SetSandBoxPolicy</para>
        /// <para>Set the policy for the sandbox environment.</para>
        /// <para>Parameters:</para>
        /// <para>policy -   The specified policy for setting, for example: FPDF_POLICY_MACHINETIME_ACCESS.</para>
        /// <para>enable -   True to enable, false to disable the policy.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_SetSandBoxPolicy(uint policy, int enable)
        {
            __Internal.FPDF_SetSandBoxPolicy(policy, enable);
        }

        /// <summary>
        /// <para>Function: FPDF_LoadDocument</para>
        /// <para>Open and load a PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>file_path -  Path to the PDF file (including extension).</para>
        /// <para>password  -  A string used as the password for the PDF file. If no password is needed, empty or NULL can be used. See comments below regarding the encoding.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: Loaded document can be closed by FPDF_CloseDocument(). If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>The encoding for |password| can be either UTF-8 or Latin-1. PDFs, depending on the security handler revision, will only accept one or the other encoding. If |password|'s encoding and the PDF's expected encoding do not match, FPDF_LoadDocument() will automatically convert |password| to the other encoding.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadDocument(string file_path, string password)
        {
            var __ret = __Internal.FPDF_LoadDocument(file_path, password);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadMemDocument</para>
        /// <para>Open and load a PDF document from memory.</para>
        /// <para>Parameters:</para>
        /// <para>data_buf    -   Pointer to a buffer containing the PDF document.</para>
        /// <para>size        -   Number of bytes in the PDF document.</para>
        /// <para>password    -   A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The memory buffer must remain valid when the document is open. The loaded document can be closed by FPDF_CloseDocument. If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadMemDocument(global::System.IntPtr data_buf, int size, string password)
        {
            var __ret = __Internal.FPDF_LoadMemDocument(data_buf, size, password);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadMemDocument64</para>
        /// <para>Open and load a PDF document from memory.</para>
        /// <para>Parameters:</para>
        /// <para>data_buf    -   Pointer to a buffer containing the PDF document.</para>
        /// <para>size        -   Number of bytes in the PDF document.</para>
        /// <para>password    -   A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The memory buffer must remain valid when the document is open. The loaded document can be closed by FPDF_CloseDocument. If this function fails, you can use FPDF_GetLastError() to retrieve the reason why it failed.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadMemDocument64(global::System.IntPtr data_buf, ulong size, string password)
        {
            var __ret = __Internal.FPDF_LoadMemDocument64(data_buf, size, password);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadCustomDocument</para>
        /// <para>Load PDF document from a custom access descriptor.</para>
        /// <para>Parameters:</para>
        /// <para>pFileAccess -   A structure for accessing the file.</para>
        /// <para>password    -   Optional password for decrypting the PDF file.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded document, or NULL on failure.</para>
        /// <para>Comments: The application must keep the file resources |pFileAccess| points to valid until the returned FPDF_DOCUMENT is closed. |pFileAccess| itself does not need to outlive the FPDF_DOCUMENT.</para>
        /// <para>The loaded document can be closed with FPDF_CloseDocument().</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for |password|.</para>
        /// <para>Notes: If PDFium is built with the XFA module, the application should call FPDF_LoadXFA() function after the PDF document loaded to support XFA fields defined in the fpdfformfill.h file.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_LoadCustomDocument(global::PDFiumCore.FPDF_FILEACCESS pFileAccess, string password)
        {
            var __arg0 = ReferenceEquals(pFileAccess, null) ? global::System.IntPtr.Zero : pFileAccess.__Instance;
            var __ret = __Internal.FPDF_LoadCustomDocument(__arg0, password);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetFileVersion</para>
        /// <para>Get the file version of the given PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>doc         -   Handle to a document.</para>
        /// <para>fileVersion -   The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</para>
        /// <para>Return value:</para>
        /// <para>True if succeeds, false otherwise.</para>
        /// <para>Comments: If the document was created by FPDF_CreateNewDocument, then this function will always fail.</para>
        /// </summary>
        public static int FPDF_GetFileVersion(global::PDFiumCore.FpdfDocumentT doc, ref int fileVersion)
        {
            var __arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            fixed (int* __fileVersion1 = &fileVersion)
            {
                var __arg1 = __fileVersion1;
                var __ret = __Internal.FPDF_GetFileVersion(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetLastError</para>
        /// <para>Get last error code when a function fails.</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return value:</para>
        /// <para>A 32-bit integer indicating error code as defined above.</para>
        /// <para>Comments: If the previous SDK call succeeded, the return value of this function is not defined.</para>
        /// </summary>
        public static uint FPDF_GetLastError()
        {
            var __ret = __Internal.FPDF_GetLastError();
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_DocumentHasValidCrossReferenceTable</para>
        /// <para>Whether the document's cross reference table is valid or not.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>True if the PDF parser did not encounter problems parsing the cross</para>
        /// <para>reference table. False if the parser could not parse the cross</para>
        /// <para>reference table and the table had to be rebuild from other data</para>
        /// <para>within the document.</para>
        /// <para>Comments: The return value can change over time as the PDF parser evolves.</para>
        /// </summary>
        public static int FPDF_DocumentHasValidCrossReferenceTable(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_DocumentHasValidCrossReferenceTable(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetTrailerEnds</para>
        /// <para>Get the byte offsets of trailer ends.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>buffer      -   The address of a buffer that receives the byte offsets.</para>
        /// <para>length      -   The size, in ints, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of ints in the buffer on success, 0 on error.</para>
        /// <para>|buffer| is an array of integers that describes the exact byte offsets of the</para>
        /// <para>trailer ends in the document. If |length| is less than the returned length,</para>
        /// <para>or |document| or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetTrailerEnds(global::PDFiumCore.FpdfDocumentT document, ref uint buffer, uint length)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (uint* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDF_GetTrailerEnds(__arg0, __arg1, length);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetDocPermission</para>
        /// <para>Get file permission flags of the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>A 32-bit integer indicating permission flags. Please refer to the</para>
        /// <para>PDF Reference for detailed descriptions. If the document is not</para>
        /// <para>protected, 0xffffffff will be returned.</para>
        /// </summary>
        public static uint FPDF_GetDocPermissions(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetDocPermissions(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetSecurityHandlerRevision</para>
        /// <para>Get the revision for the security handler.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>The security handler revision number. Please refer to the PDF</para>
        /// <para>Reference for a detailed description. If the document is not</para>
        /// <para>protected, -1 will be returned.</para>
        /// </summary>
        public static int FPDF_GetSecurityHandlerRevision(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSecurityHandlerRevision(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageCount</para>
        /// <para>Get total number of pages in the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument.</para>
        /// <para>Return value:</para>
        /// <para>Total number of pages in the document.</para>
        /// </summary>
        public static int FPDF_GetPageCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetPageCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadPage</para>
        /// <para>Load a page inside the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument</para>
        /// <para>page_index  -   Index number of the page. 0 for the first page.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the loaded page, or NULL if page load fails.</para>
        /// <para>Comments: The loaded page can be rendered to devices using FPDF_RenderPage. The loaded page can be closed using FPDF_ClosePage.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageT FPDF_LoadPage(global::PDFiumCore.FpdfDocumentT document, int page_index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_LoadPage(__arg0, page_index);
            global::PDFiumCore.FpdfPageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageT) global::PDFiumCore.FpdfPageT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageWidthF</para>
        /// <para>Get page width.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>Page width (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm).</para>
        /// </summary>
        public static float FPDF_GetPageWidthF(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageWidthF(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageWidth</para>
        /// <para>Get page width.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>Return value:</para>
        /// <para>Page width (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm).</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageWidthF() above. This will be deprecated in the</para>
        /// <para>future.</para>
        /// </summary>
        public static double FPDF_GetPageWidth(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageWidth(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageHeightF</para>
        /// <para>Get page height.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>Page height (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm)</para>
        /// </summary>
        public static float FPDF_GetPageHeightF(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageHeightF(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageHeight</para>
        /// <para>Get page height.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>Return value:</para>
        /// <para>Page height (excluding non-displayable area) measured in points.</para>
        /// <para>One point is 1/72 inch (around 0.3528 mm)</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageHeightF() above. This will be deprecated in the</para>
        /// <para>future.</para>
        /// </summary>
        public static double FPDF_GetPageHeight(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageHeight(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageBoundingBox</para>
        /// <para>Get the bounding box of the page. This is the intersection between</para>
        /// <para>its media box and its crop box.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>rect        -   Pointer to a rect to receive the page bounding box. On an error, |rect| won't be filled.</para>
        /// <para>Return value:</para>
        /// <para>True for success.</para>
        /// </summary>
        public static int FPDF_GetPageBoundingBox(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDF_GetPageBoundingBox(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageSizeByIndexF</para>
        /// <para>Get the size of the page at the given index.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>page_index  -   Page index, zero for the first page.</para>
        /// <para>size        -   Pointer to a FS_SIZEF to receive the page size. (in points).</para>
        /// <para>Return value:</para>
        /// <para>Non-zero for success. 0 for error (document or page not found).</para>
        /// </summary>
        public static int FPDF_GetPageSizeByIndexF(global::PDFiumCore.FpdfDocumentT document, int page_index, global::PDFiumCore.FS_SIZEF_ size)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg2 = ReferenceEquals(size, null) ? global::System.IntPtr.Zero : size.__Instance;
            var __ret = __Internal.FPDF_GetPageSizeByIndexF(__arg0, page_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetPageSizeByIndex</para>
        /// <para>Get the size of the page at the given index.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument.</para>
        /// <para>page_index  -   Page index, zero for the first page.</para>
        /// <para>width       -   Pointer to a double to receive the page width (in points).</para>
        /// <para>height      -   Pointer to a double to receive the page height (in points).</para>
        /// <para>Return value:</para>
        /// <para>Non-zero for success. 0 for error (document or page not found).</para>
        /// <para>Note:</para>
        /// <para>Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in</para>
        /// <para>the future.</para>
        /// </summary>
        public static int FPDF_GetPageSizeByIndex(global::PDFiumCore.FpdfDocumentT document, int page_index, ref double width, ref double height)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (double* __width2 = &width)
            {
                var __arg2 = __width2;
                fixed (double* __height3 = &height)
                {
                    var __arg3 = __height3;
                    var __ret = __Internal.FPDF_GetPageSizeByIndex(__arg0, page_index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmap</para>
        /// <para>Render contents of a page to a device independent bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). The bitmap handle can be created by FPDFBitmap_Create or retrieved from an image object by FPDFImageObj_GetBitmap.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>start_x     -   Left pixel position of the display area in bitmap coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in bitmap coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>flags       -   0 for normal display, or combination of the Page Rendering flags defined above. With the FPDF_ANNOT flag, it renders all annotations that do not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_RenderPageBitmap(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDF_RenderPageBitmap(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags);
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmapWithMatrix</para>
        /// <para>Render contents of a page to a device independent bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). The bitmap handle can be created by FPDFBitmap_Create or retrieved by FPDFImageObj_GetBitmap.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>matrix      -   The transform matrix, which must be invertible. See PDF Reference 1.7, 4.2.2 Common Transformations.</para>
        /// <para>clipping    -   The rect to clip to in device coords.</para>
        /// <para>flags       -   0 for normal display, or combination of the Page Rendering flags defined above. With the FPDF_ANNOT flag, it renders all annotations that do not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>Return value:</para>
        /// <para>None. Note that behavior is undefined if det of |matrix| is 0.</para>
        /// </summary>
        public static void FPDF_RenderPageBitmapWithMatrix(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_MATRIX_ matrix, global::PDFiumCore.FS_RECTF_ clipping, int flags)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg2 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __arg3 = ReferenceEquals(clipping, null) ? global::System.IntPtr.Zero : clipping.__Instance;
            __Internal.FPDF_RenderPageBitmapWithMatrix(__arg0, __arg1, __arg2, __arg3, flags);
        }

        /// <summary>
        /// <para>Function: FPDF_ClosePage</para>
        /// <para>Close a loaded PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the loaded page.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_ClosePage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDF_ClosePage(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_CloseDocument</para>
        /// <para>Close a loaded PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_CloseDocument(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            __Internal.FPDF_CloseDocument(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_DeviceToPage</para>
        /// <para>Convert the screen coordinates of a point to page coordinates.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>start_x     -   Left pixel position of the display area in device coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in device coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>device_x    -   X value in device coordinates to be converted.</para>
        /// <para>device_y    -   Y value in device coordinates to be converted.</para>
        /// <para>page_x      -   A pointer to a double receiving the converted X value in page coordinates.</para>
        /// <para>page_y      -   A pointer to a double receiving the converted Y value in page coordinates.</para>
        /// <para>Return value:</para>
        /// <para>Returns true if the conversion succeeds, and |page_x| and |page_y|</para>
        /// <para>successfully receives the converted coordinates.</para>
        /// <para>Comments: The page coordinate system has its origin at the left-bottom corner of the page, with the X-axis on the bottom going to the right, and the Y-axis on the left side going up.</para>
        /// <para>NOTE: this coordinate system can be altered when you zoom, scroll, or rotate a page, however, a point on the page should always have the same coordinate values in the page coordinate system.</para>
        /// <para>The device coordinate system is device dependent. For screen device, its origin is at the left-top corner of the window. However this origin can be altered by the Windows coordinate transformation utilities.</para>
        /// <para>You must make sure the start_x, start_y, size_x, size_y and rotate parameters have exactly same values as you used in the FPDF_RenderPage() function call.</para>
        /// </summary>
        public static int FPDF_DeviceToPage(global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, ref double page_x, ref double page_y)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (double* __page_x8 = &page_x)
            {
                var __arg8 = __page_x8;
                fixed (double* __page_y9 = &page_y)
                {
                    var __arg9 = __page_y9;
                    var __ret = __Internal.FPDF_DeviceToPage(__arg0, start_x, start_y, size_x, size_y, rotate, device_x, device_y, __arg8, __arg9);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDF_PageToDevice</para>
        /// <para>Convert the page coordinates of a point to screen coordinates.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage.</para>
        /// <para>start_x     -   Left pixel position of the display area in device coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in device coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal) 1 (rotated 90 degrees clockwise) 2 (rotated 180 degrees) 3 (rotated 90 degrees counter-clockwise)</para>
        /// <para>page_x      -   X value in page coordinates.</para>
        /// <para>page_y      -   Y value in page coordinate.</para>
        /// <para>device_x    -   A pointer to an integer receiving the result X value in device coordinates.</para>
        /// <para>device_y    -   A pointer to an integer receiving the result Y value in device coordinates.</para>
        /// <para>Return value:</para>
        /// <para>Returns true if the conversion succeeds, and |device_x| and</para>
        /// <para>|device_y| successfully receives the converted coordinates.</para>
        /// <para>Comments: See comments for FPDF_DeviceToPage().</para>
        /// </summary>
        public static int FPDF_PageToDevice(global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, ref int device_x, ref int device_y)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (int* __device_x8 = &device_x)
            {
                var __arg8 = __device_x8;
                fixed (int* __device_y9 = &device_y)
                {
                    var __arg9 = __device_y9;
                    var __ret = __Internal.FPDF_PageToDevice(__arg0, start_x, start_y, size_x, size_y, rotate, page_x, page_y, __arg8, __arg9);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_Create</para>
        /// <para>Create a device independent bitmap (FXDIB).</para>
        /// <para>Parameters:</para>
        /// <para>width       -   The number of pixels in width for the bitmap. Must be greater than 0.</para>
        /// <para>height      -   The number of pixels in height for the bitmap. Must be greater than 0.</para>
        /// <para>alpha       -   A flag indicating whether the alpha channel is used. Non-zero for using alpha, zero for not using.</para>
        /// <para>Return value:</para>
        /// <para>The created bitmap handle, or NULL if a parameter error or out of</para>
        /// <para>memory.</para>
        /// <para>Comments: The bitmap always uses 4 bytes per pixel. The first byte is always double word aligned.</para>
        /// <para>The byte order is BGRx (the last byte unused if no alpha channel) or BGRA.</para>
        /// <para>The pixels in a horizontal line are stored side by side, with the left most pixel stored first (with lower memory address). Each line uses width * 4 bytes.</para>
        /// <para>Lines are stored one after another, with the top most line stored first. There is no gap between adjacent lines.</para>
        /// <para>This function allocates enough memory for holding all pixels in the bitmap, but it doesn't initialize the buffer. Applications can use FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS allows it, this function can allocate up to 4 GB of memory.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFBitmapCreate(int width, int height, int alpha)
        {
            var __ret = __Internal.FPDFBitmapCreate(width, height, alpha);
            global::PDFiumCore.FpdfBitmapT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBitmapT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBitmapT) global::PDFiumCore.FpdfBitmapT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBitmapT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_CreateEx</para>
        /// <para>Create a device independent bitmap (FXDIB)</para>
        /// <para>Parameters:</para>
        /// <para>width       -   The number of pixels in width for the bitmap. Must be greater than 0.</para>
        /// <para>height      -   The number of pixels in height for the bitmap. Must be greater than 0.</para>
        /// <para>format      -   A number indicating for bitmap format, as defined above.</para>
        /// <para>first_scan  -   A pointer to the first byte of the first line if using an external buffer. If this parameter is NULL, then the a new buffer will be created.</para>
        /// <para>stride      -   Number of bytes for each scan line, for external buffer only.</para>
        /// <para>Return value:</para>
        /// <para>The bitmap handle, or NULL if parameter error or out of memory.</para>
        /// <para>Comments: Similar to FPDFBitmap_Create function, but allows for more formats and an external buffer is supported. The bitmap created by this function can be used in any place that a FPDF_BITMAP handle is required.</para>
        /// <para>If an external buffer is used, then the application should destroy the buffer by itself. FPDFBitmap_Destroy function will not destroy the buffer.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFBitmapCreateEx(int width, int height, int format, global::System.IntPtr first_scan, int stride)
        {
            var __ret = __Internal.FPDFBitmapCreateEx(width, height, format, first_scan, stride);
            global::PDFiumCore.FpdfBitmapT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBitmapT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBitmapT) global::PDFiumCore.FpdfBitmapT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBitmapT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetFormat</para>
        /// <para>Get the format of the bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The format of the bitmap.</para>
        /// <para>Comments: Only formats supported by FPDFBitmap_CreateEx are supported by this function; see the list of such formats above.</para>
        /// </summary>
        public static int FPDFBitmapGetFormat(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetFormat(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_FillRect</para>
        /// <para>Fill a rectangle in a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   The handle to the bitmap. Returned by FPDFBitmap_Create.</para>
        /// <para>left        -   The left position. Starting from 0 at the left-most pixel.</para>
        /// <para>top         -   The top position. Starting from 0 at the top-most line.</para>
        /// <para>width       -   Width in pixels to be filled.</para>
        /// <para>height      -   Height in pixels to be filled.</para>
        /// <para>color       -   A 32-bit value specifing the color, in 8888 ARGB format.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function sets the color and (optionally) alpha value in the specified region of the bitmap.</para>
        /// <para>NOTE: If the alpha channel is used, this function does NOT composite the background with the source color, instead the background will be replaced by the source color and the alpha.</para>
        /// <para>If the alpha channel is not used, the alpha parameter is ignored.</para>
        /// </summary>
        public static void FPDFBitmapFillRect(global::PDFiumCore.FpdfBitmapT bitmap, int left, int top, int width, int height, uint color)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmapFillRect(__arg0, left, top, width, height, color);
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetBuffer</para>
        /// <para>Get data buffer of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The pointer to the first byte of the bitmap buffer.</para>
        /// <para>Comments: The stride may be more than width * number of bytes per pixel</para>
        /// <para>Applications can use this function to get the bitmap buffer pointer, then manipulate any color and/or alpha values for any pixels in the bitmap.</para>
        /// <para>The data is in BGRA format. Where the A maybe unused if alpha was not specified.</para>
        /// </summary>
        public static global::System.IntPtr FPDFBitmapGetBuffer(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetBuffer(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetWidth</para>
        /// <para>Get width of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The width of the bitmap in pixels.</para>
        /// </summary>
        public static int FPDFBitmapGetWidth(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetWidth(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetHeight</para>
        /// <para>Get height of a bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The height of the bitmap in pixels.</para>
        /// </summary>
        public static int FPDFBitmapGetHeight(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetHeight(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_GetStride</para>
        /// <para>Get number of bytes for each line in the bitmap buffer.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes for each line in the bitmap buffer.</para>
        /// <para>Comments: The stride may be more than width * number of bytes per pixel.</para>
        /// </summary>
        public static int FPDFBitmapGetStride(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFBitmapGetStride(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFBitmap_Destroy</para>
        /// <para>Destroy a bitmap and release all related buffers.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function will not destroy any external buffers provided when the bitmap was created.</para>
        /// </summary>
        public static void FPDFBitmapDestroy(global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmapDestroy(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintScaling</para>
        /// <para>Whether the PDF document prefers to be scaled or not.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetPrintScaling(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintScaling(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetNumCopies</para>
        /// <para>Returns the number of copies to be printed.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The number of copies to be printed.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetNumCopies(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetNumCopies(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRange</para>
        /// <para>Page numbers to initialize print dialog box when file is printed.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The print page range to be used for printing.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPagerangeT FPDF_VIEWERREF_GetPrintPageRange(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRange(__arg0);
            global::PDFiumCore.FpdfPagerangeT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPagerangeT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPagerangeT) global::PDFiumCore.FpdfPagerangeT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPagerangeT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRangeCount</para>
        /// <para>Returns the number of elements in a FPDF_PAGERANGE.</para>
        /// <para>Parameters:</para>
        /// <para>pagerange   -   Handle to the page range.</para>
        /// <para>Return value:</para>
        /// <para>The number of elements in the page range. Returns 0 on error.</para>
        /// </summary>
        public static ulong FPDF_VIEWERREF_GetPrintPageRangeCount(global::PDFiumCore.FpdfPagerangeT pagerange)
        {
            var __arg0 = ReferenceEquals(pagerange, null) ? global::System.IntPtr.Zero : pagerange.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetPrintPageRangeElement</para>
        /// <para>Returns an element from a FPDF_PAGERANGE.</para>
        /// <para>Parameters:</para>
        /// <para>pagerange   -   Handle to the page range.</para>
        /// <para>index       -   Index of the element.</para>
        /// <para>Return value:</para>
        /// <para>The value of the element in the page range at a given index.</para>
        /// <para>Returns -1 on error.</para>
        /// </summary>
        public static int FPDF_VIEWERREF_GetPrintPageRangeElement(global::PDFiumCore.FpdfPagerangeT pagerange, ulong index)
        {
            var __arg0 = ReferenceEquals(pagerange, null) ? global::System.IntPtr.Zero : pagerange.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeElement(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetDuplex</para>
        /// <para>Returns the paper handling option to be used when printing from</para>
        /// <para>the print dialog.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>Return value:</para>
        /// <para>The paper handling option to be used when printing.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetDuplex(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_VIEWERREF_GetName</para>
        /// <para>Gets the contents for a viewer ref, with a given key. The value must</para>
        /// <para>be of type &quot;name&quot;.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>key         -   Name of the key in the viewer pref dictionary, encoded in UTF-8.</para>
        /// <para>buffer      -   A string to write the contents of the key to.</para>
        /// <para>length      -   Length of the buffer.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the contents, including the NULL terminator.</para>
        /// <para>Thus if the return value is 0, then that indicates an error, such</para>
        /// <para>as when |document| is invalid or |buffer| is NULL. If |length| is</para>
        /// <para>less than the returned length, or |buffer| is NULL, |buffer| will</para>
        /// <para>not be modified.</para>
        /// </summary>
        public static uint FPDF_VIEWERREF_GetName(global::PDFiumCore.FpdfDocumentT document, string key, sbyte* buffer, uint length)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_VIEWERREF_GetName(__arg0, key, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_CountNamedDests</para>
        /// <para>Get the count of named destinations in the PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to a document</para>
        /// <para>Return value:</para>
        /// <para>The count of named destinations.</para>
        /// </summary>
        public static uint FPDF_CountNamedDests(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_CountNamedDests(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetNamedDestByName</para>
        /// <para>Get a the destination handle for the given name.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to the loaded document.</para>
        /// <para>name        -   The name of a destination.</para>
        /// <para>Return value:</para>
        /// <para>The handle to the destination.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDF_GetNamedDestByName(global::PDFiumCore.FpdfDocumentT document, string name)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetNamedDestByName(__arg0, name);
            global::PDFiumCore.FpdfDestT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDestT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDestT) global::PDFiumCore.FpdfDestT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDestT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_GetNamedDest</para>
        /// <para>Get the named destination by index.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to a document</para>
        /// <para>index           -   The index of a named destination.</para>
        /// <para>buffer          -   The buffer to store the destination name, used as wchar_t*.</para>
        /// <para>buflen [in/out] -   Size of the buffer in bytes on input, length of the result in bytes on output or -1 if the buffer is too small.</para>
        /// <para>Return value:</para>
        /// <para>The destination handle for a given index, or NULL if there is no</para>
        /// <para>named destination corresponding to |index|.</para>
        /// <para>Comments: Call this function twice to get the name of the named destination: 1) First time pass in |buffer| as NULL and get buflen. 2) Second time pass in allocated |buffer| and buflen to retrieve |buffer|, which should be used as wchar_t*.</para>
        /// <para>If buflen is not sufficiently large, it will be set to -1 upon return.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDF_GetNamedDest(global::PDFiumCore.FpdfDocumentT document, int index, global::System.IntPtr buffer, ref int buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (int* __buflen3 = &buflen)
            {
                var __arg3 = __buflen3;
                var __ret = __Internal.FPDF_GetNamedDest(__arg0, index, buffer, __arg3);
                global::PDFiumCore.FpdfDestT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::PDFiumCore.FpdfDestT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::PDFiumCore.FpdfDestT) global::PDFiumCore.FpdfDestT.NativeToManagedMap[__ret];
                else __result0 = global::PDFiumCore.FpdfDestT.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketCount</para>
        /// <para>Get the number of valid packets in the XFA entry.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to the document.</para>
        /// <para>Return value:</para>
        /// <para>The number of valid packets, or -1 on error.</para>
        /// </summary>
        public static int FPDF_GetXFAPacketCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetXFAPacketCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketName</para>
        /// <para>Get the name of a packet in the XFA array.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to the document.</para>
        /// <para>index    - Index number of the packet. 0 for the first packet.</para>
        /// <para>buffer   - Buffer for holding the name of the XFA packet.</para>
        /// <para>buflen   - Length of |buffer| in bytes.</para>
        /// <para>Return value:</para>
        /// <para>The length of the packet name in bytes, or 0 on error.</para>
        /// <para>|document| must be valid and |index| must be in the range [0, N), where N is</para>
        /// <para>the value returned by FPDF_GetXFAPacketCount().</para>
        /// <para>|buffer| is only modified if it is non-NULL and |buflen| is greater than or</para>
        /// <para>equal to the length of the packet name. The packet name includes a</para>
        /// <para>terminating NUL character. |buffer| is unmodified on error.</para>
        /// </summary>
        public static uint FPDF_GetXFAPacketName(global::PDFiumCore.FpdfDocumentT document, int index, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetXFAPacketName(__arg0, index, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetXFAPacketContent</para>
        /// <para>Get the content of a packet in the XFA array.</para>
        /// <para>Parameters:</para>
        /// <para>document   - Handle to the document.</para>
        /// <para>index      - Index number of the packet. 0 for the first packet.</para>
        /// <para>buffer     - Buffer for holding the content of the XFA packet.</para>
        /// <para>buflen     - Length of |buffer| in bytes.</para>
        /// <para>out_buflen - Pointer to the variable that will receive the minimum buffer size needed to contain the content of the XFA packet.</para>
        /// <para>Return value:</para>
        /// <para>Whether the operation succeeded or not.</para>
        /// <para>|document| must be valid and |index| must be in the range [0, N), where N is</para>
        /// <para>the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be</para>
        /// <para>NULL. When the aforementioned arguments are valid, the operation succeeds,</para>
        /// <para>and |out_buflen| receives the content size. |buffer| is only modified if</para>
        /// <para>|buffer| is non-null and long enough to contain the content. Callers must</para>
        /// <para>check both the return value and the input |buflen| is no less than the</para>
        /// <para>returned |out_buflen| before using the data in |buffer|.</para>
        /// </summary>
        public static int FPDF_GetXFAPacketContent(global::PDFiumCore.FpdfDocumentT document, int index, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDF_GetXFAPacketContent(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }
    }

    public enum FPDFANNOT_COLORTYPE
    {
        FPDFANNOT_COLORTYPE_Color = 0,
        FPDFANNOT_COLORTYPE_InteriorColor = 1
    }

    public unsafe partial class fpdf_annot
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_IsSupportedSubtype")]
            internal static extern int FPDFAnnotIsSupportedSubtype(int subtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_CreateAnnot")]
            internal static extern global::System.IntPtr FPDFPageCreateAnnot(global::System.IntPtr page, int subtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetAnnotCount")]
            internal static extern int FPDFPageGetAnnotCount(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetAnnot")]
            internal static extern global::System.IntPtr FPDFPageGetAnnot(global::System.IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetAnnotIndex")]
            internal static extern int FPDFPageGetAnnotIndex(global::System.IntPtr page, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_CloseAnnot")]
            internal static extern void FPDFPageCloseAnnot(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_RemoveAnnot")]
            internal static extern int FPDFPageRemoveAnnot(global::System.IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetSubtype")]
            internal static extern int FPDFAnnotGetSubtype(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_IsObjectSupportedSubtype")]
            internal static extern int FPDFAnnotIsObjectSupportedSubtype(int subtype);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_UpdateObject")]
            internal static extern int FPDFAnnotUpdateObject(global::System.IntPtr annot, global::System.IntPtr obj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_AddInkStroke")]
            internal static extern int FPDFAnnotAddInkStroke(global::System.IntPtr annot, global::System.IntPtr points, ulong point_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_RemoveInkList")]
            internal static extern int FPDFAnnotRemoveInkList(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_AppendObject")]
            internal static extern int FPDFAnnotAppendObject(global::System.IntPtr annot, global::System.IntPtr obj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetObjectCount")]
            internal static extern int FPDFAnnotGetObjectCount(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetObject")]
            internal static extern global::System.IntPtr FPDFAnnotGetObject(global::System.IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_RemoveObject")]
            internal static extern int FPDFAnnotRemoveObject(global::System.IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetColor")]
            internal static extern int FPDFAnnotSetColor(global::System.IntPtr annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetColor")]
            internal static extern int FPDFAnnotGetColor(global::System.IntPtr annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_HasAttachmentPoints")]
            internal static extern int FPDFAnnotHasAttachmentPoints(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetAttachmentPoints")]
            internal static extern int FPDFAnnotSetAttachmentPoints(global::System.IntPtr annot, ulong quad_index, global::System.IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_AppendAttachmentPoints")]
            internal static extern int FPDFAnnotAppendAttachmentPoints(global::System.IntPtr annot, global::System.IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_CountAttachmentPoints")]
            internal static extern ulong FPDFAnnotCountAttachmentPoints(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetAttachmentPoints")]
            internal static extern int FPDFAnnotGetAttachmentPoints(global::System.IntPtr annot, ulong quad_index, global::System.IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetRect")]
            internal static extern int FPDFAnnotSetRect(global::System.IntPtr annot, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetRect")]
            internal static extern int FPDFAnnotGetRect(global::System.IntPtr annot, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetVertices")]
            internal static extern uint FPDFAnnotGetVertices(global::System.IntPtr annot, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetInkListCount")]
            internal static extern uint FPDFAnnotGetInkListCount(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetInkListPath")]
            internal static extern uint FPDFAnnotGetInkListPath(global::System.IntPtr annot, uint path_index, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetLine")]
            internal static extern int FPDFAnnotGetLine(global::System.IntPtr annot, global::System.IntPtr start, global::System.IntPtr end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_HasKey")]
            internal static extern int FPDFAnnotHasKey(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetValueType")]
            internal static extern int FPDFAnnotGetValueType(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetStringValue")]
            internal static extern int FPDFAnnotSetStringValue(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, ushort* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetStringValue")]
            internal static extern uint FPDFAnnotGetStringValue(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetNumberValue")]
            internal static extern int FPDFAnnotGetNumberValue(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetAP")]
            internal static extern int FPDFAnnotSetAP(global::System.IntPtr annot, int appearanceMode, ushort* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetAP")]
            internal static extern uint FPDFAnnotGetAP(global::System.IntPtr annot, int appearanceMode, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetLinkedAnnot")]
            internal static extern global::System.IntPtr FPDFAnnotGetLinkedAnnot(global::System.IntPtr annot, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFlags")]
            internal static extern int FPDFAnnotGetFlags(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetFlags")]
            internal static extern int FPDFAnnotSetFlags(global::System.IntPtr annot, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldFlags")]
            internal static extern int FPDFAnnotGetFormFieldFlags(global::System.IntPtr handle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldAtPoint")]
            internal static extern global::System.IntPtr FPDFAnnotGetFormFieldAtPoint(global::System.IntPtr hHandle, global::System.IntPtr page, global::System.IntPtr point);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldName")]
            internal static extern uint FPDFAnnotGetFormFieldName(global::System.IntPtr hHandle, global::System.IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldType")]
            internal static extern int FPDFAnnotGetFormFieldType(global::System.IntPtr hHandle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldValue")]
            internal static extern uint FPDFAnnotGetFormFieldValue(global::System.IntPtr hHandle, global::System.IntPtr annot, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetOptionCount")]
            internal static extern int FPDFAnnotGetOptionCount(global::System.IntPtr hHandle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetOptionLabel")]
            internal static extern uint FPDFAnnotGetOptionLabel(global::System.IntPtr hHandle, global::System.IntPtr annot, int index, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_IsOptionSelected")]
            internal static extern int FPDFAnnotIsOptionSelected(global::System.IntPtr handle, global::System.IntPtr annot, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFontSize")]
            internal static extern int FPDFAnnotGetFontSize(global::System.IntPtr hHandle, global::System.IntPtr annot, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_IsChecked")]
            internal static extern int FPDFAnnotIsChecked(global::System.IntPtr hHandle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_SetFocusableSubtypes")]
            internal static extern int FPDFAnnotSetFocusableSubtypes(global::System.IntPtr hHandle, int* subtypes, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFocusableSubtypesCount")]
            internal static extern int FPDFAnnotGetFocusableSubtypesCount(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFocusableSubtypes")]
            internal static extern int FPDFAnnotGetFocusableSubtypes(global::System.IntPtr hHandle, int* subtypes, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetLink")]
            internal static extern global::System.IntPtr FPDFAnnotGetLink(global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormControlCount")]
            internal static extern int FPDFAnnotGetFormControlCount(global::System.IntPtr hHandle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormControlIndex")]
            internal static extern int FPDFAnnotGetFormControlIndex(global::System.IntPtr hHandle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAnnot_GetFormFieldExportValue")]
            internal static extern uint FPDFAnnotGetFormFieldExportValue(global::System.IntPtr hHandle, global::System.IntPtr annot, ushort* buffer, uint buflen);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if an annotation subtype is currently supported for creation.</para>
        /// <para>Currently supported subtypes: circle, highlight, ink, popup, square,</para>
        /// <para>squiggly, stamp, strikeout, text, and underline.</para>
        /// <para>subtype   - the subtype to be checked.</para>
        /// <para>Returns true if this subtype supported.</para>
        /// </summary>
        public static int FPDFAnnotIsSupportedSubtype(int subtype)
        {
            var __ret = __Internal.FPDFAnnotIsSupportedSubtype(subtype);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create an annotation in |page| of the subtype |subtype|. If the specified</para>
        /// <para>subtype is illegal or unsupported, then a new annotation will not be created.</para>
        /// <para>Must call FPDFPage_CloseAnnot() when the annotation returned by this</para>
        /// <para>function is no longer needed.</para>
        /// <para>page      - handle to a page.</para>
        /// <para>subtype   - the subtype of the new annotation.</para>
        /// <para>Returns a handle to the new annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFPageCreateAnnot(global::PDFiumCore.FpdfPageT page, int subtype)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageCreateAnnot(__arg0, subtype);
            global::PDFiumCore.FpdfAnnotationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAnnotationT) global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAnnotationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of annotations in |page|.</para>
        /// <para>page   - handle to a page.</para>
        /// <para>Returns the number of annotations in |page|.</para>
        /// </summary>
        public static int FPDFPageGetAnnotCount(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetAnnotCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get annotation in |page| at |index|. Must call FPDFPage_CloseAnnot() when the</para>
        /// <para>annotation returned by this function is no longer needed.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of the annotation.</para>
        /// <para>Returns a handle to the annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFPageGetAnnot(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetAnnot(__arg0, index);
            global::PDFiumCore.FpdfAnnotationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAnnotationT) global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAnnotationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the index of |annot| in |page|. This is the opposite of</para>
        /// <para>FPDFPage_GetAnnot().</para>
        /// <para>page  - handle to the page that the annotation is on.</para>
        /// <para>annot - handle to an annotation.</para>
        /// <para>Returns the index of |annot|, or -1 on failure.</para>
        /// </summary>
        public static int FPDFPageGetAnnotIndex(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFPageGetAnnotIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Close an annotation. Must be called when the annotation returned by</para>
        /// <para>FPDFPage_CreateAnnot() or FPDFPage_GetAnnot() is no longer needed. This</para>
        /// <para>function does not remove the annotation from the document.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// </summary>
        public static void FPDFPageCloseAnnot(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            __Internal.FPDFPageCloseAnnot(__arg0);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove the annotation in |page| at |index|.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of the annotation.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFPageRemoveAnnot(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageRemoveAnnot(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the subtype of an annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the annotation subtype.</para>
        /// </summary>
        public static int FPDFAnnotGetSubtype(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetSubtype(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if an annotation subtype is currently supported for object extraction,</para>
        /// <para>update, and removal.</para>
        /// <para>Currently supported subtypes: ink and stamp.</para>
        /// <para>subtype   - the subtype to be checked.</para>
        /// <para>Returns true if this subtype supported.</para>
        /// </summary>
        public static int FPDFAnnotIsObjectSupportedSubtype(int subtype)
        {
            var __ret = __Internal.FPDFAnnotIsObjectSupportedSubtype(subtype);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Update |obj| in |annot|. |obj| must be in |annot| already and must have</para>
        /// <para>been retrieved by FPDFAnnot_GetObject(). Currently, only ink and stamp</para>
        /// <para>annotations are supported by this API. Also note that only path, image, and</para>
        /// <para>text objects have APIs for modification; see FPDFPath_*(), FPDFText_*(), and</para>
        /// <para>FPDFImageObj_*().</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>obj    - handle to the object that |annot| needs to update.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotUpdateObject(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FpdfPageobjectT obj)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(obj, null) ? global::System.IntPtr.Zero : obj.__Instance;
            var __ret = __Internal.FPDFAnnotUpdateObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add a new InkStroke, represented by an array of points, to the InkList of</para>
        /// <para>|annot|. The API creates an InkList if one doesn't already exist in |annot|.</para>
        /// <para>This API works only for ink annotations. Please refer section 12.5.6.13 in</para>
        /// <para>PDF 32000-1:2008 Specification.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>points      - pointer to a FS_POINTF array representing input points.</para>
        /// <para>point_count - number of elements in |points| array. This should not exceed</para>
        /// <para>the maximum value that can be represented by an int32_t).</para>
        /// <para>Returns the 0-based index at which the new InkStroke is added in the InkList</para>
        /// <para>of the |annot|. Returns -1 on failure.</para>
        /// </summary>
        public static int FPDFAnnotAddInkStroke(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ points, ulong point_count)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            var __ret = __Internal.FPDFAnnotAddInkStroke(__arg0, __arg1, point_count);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes an InkList in |annot|.</para>
        /// <para>This API works only for ink annotations.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Return true on successful removal of /InkList entry from context of the</para>
        /// <para>non-null ink |annot|. Returns false on failure.</para>
        /// </summary>
        public static int FPDFAnnotRemoveInkList(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotRemoveInkList(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add |obj| to |annot|. |obj| must have been created by</para>
        /// <para>FPDFPageObj_CreateNew{Path|Rect}() or FPDFPageObj_New{Text|Image}Obj(), and</para>
        /// <para>will be owned by |annot|. Note that an |obj| cannot belong to more than one</para>
        /// <para>|annot|. Currently, only ink and stamp annotations are supported by this API.</para>
        /// <para>Also note that only path, image, and text objects have APIs for creation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>obj    - handle to the object that is to be added to |annot|.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotAppendObject(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FpdfPageobjectT obj)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(obj, null) ? global::System.IntPtr.Zero : obj.__Instance;
            var __ret = __Internal.FPDFAnnotAppendObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the total number of objects in |annot|, including path objects, text</para>
        /// <para>objects, external objects, image objects, and shading objects.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the number of objects in |annot|.</para>
        /// </summary>
        public static int FPDFAnnotGetObjectCount(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetObjectCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the object in |annot| at |index|.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>index  - the index of the object.</para>
        /// <para>Return a handle to the object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFAnnotGetObject(global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetObject(__arg0, index);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove the object in |annot| at |index|.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>index  - the index of the object to be removed.</para>
        /// <para>Return true if successful.</para>
        /// </summary>
        public static int FPDFAnnotRemoveObject(global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotRemoveObject(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the color of an annotation. Fails when called on annotations with</para>
        /// <para>appearance streams already defined; instead use</para>
        /// <para>FPDFPath_Set{Stroke|Fill}Color().</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>type     - type of the color to be set.</para>
        /// <para>R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.</para>
        /// <para>A        - buffer to hold the opacity. Ranges from 0 to 255.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetColor(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, uint R, uint G, uint B, uint A)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetColor(__arg0, type, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the color of an annotation. If no color is specified, default to yellow</para>
        /// <para>for highlight annotation, black for all else. Fails when called on</para>
        /// <para>annotations with appearance streams already defined; instead use</para>
        /// <para>FPDFPath_Get{Stroke|Fill}Color().</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>type     - type of the color requested.</para>
        /// <para>R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.</para>
        /// <para>A        - buffer to hold the opacity. Ranges from 0 to 255.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetColor(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FPDFANNOT_COLORTYPE type, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFAnnotGetColor(__arg0, type, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if the annotation is of a type that has attachment points</para>
        /// <para>(i.e. quadpoints). Quadpoints are the vertices of the rectangle that</para>
        /// <para>encompasses the texts affected by the annotation. They provide the</para>
        /// <para>coordinates in the page where the annotation is attached. Only text markup</para>
        /// <para>annotations (i.e. highlight, strikeout, squiggly, and underline) and link</para>
        /// <para>annotations have quadpoints.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns true if the annotation is of a type that has quadpoints, false</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static int FPDFAnnotHasAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotHasAttachmentPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Replace the attachment points (i.e. quadpoints) set of an annotation at</para>
        /// <para>|quad_index|. This index needs to be within the result of</para>
        /// <para>FPDFAnnot_CountAttachmentPoints().</para>
        /// <para>If the annotation's appearance stream is defined and this annotation is of a</para>
        /// <para>type with quadpoints, then update the bounding box too if the new quadpoints</para>
        /// <para>define a bigger one.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_index  - index of the set of quadpoints.</para>
        /// <para>quad_points - the quadpoints to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, ulong quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg2 = ReferenceEquals(quad_points, null) ? global::System.IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotSetAttachmentPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Append to the list of attachment points (i.e. quadpoints) of an annotation.</para>
        /// <para>If the annotation's appearance stream is defined and this annotation is of a</para>
        /// <para>type with quadpoints, then update the bounding box too if the new quadpoints</para>
        /// <para>define a bigger one.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_points - the quadpoints to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotAppendAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(quad_points, null) ? global::System.IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotAppendAttachmentPoints(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of sets of quadpoints of an annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>Returns the number of sets of quadpoints, or 0 on failure.</para>
        /// </summary>
        public static ulong FPDFAnnotCountAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotCountAttachmentPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the attachment points (i.e. quadpoints) of an annotation.</para>
        /// <para>annot       - handle to an annotation.</para>
        /// <para>quad_index  - index of the set of quadpoints.</para>
        /// <para>quad_points - receives the quadpoints; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetAttachmentPoints(global::PDFiumCore.FpdfAnnotationT annot, ulong quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg2 = ReferenceEquals(quad_points, null) ? global::System.IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFAnnotGetAttachmentPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the annotation rectangle defining the location of the annotation. If the</para>
        /// <para>annotation's appearance stream is defined and this annotation is of a type</para>
        /// <para>without quadpoints, then update the bounding box too if the new rectangle</para>
        /// <para>defines a bigger one.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>rect   - the annotation rectangle to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetRect(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFAnnotSetRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation rectangle defining the location of the annotation.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>rect   - receives the rectangle; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotGetRect(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFAnnotGetRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the vertices of a polygon or polyline annotation. |buffer| is an array of</para>
        /// <para>points of the annotation. If |length| is less than the returned length, or</para>
        /// <para>|annot| or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>buffer - buffer for holding the points.</para>
        /// <para>length - length of the buffer in points.</para>
        /// <para>Returns the number of points if the annotation is of type polygon or</para>
        /// <para>polyline, 0 otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetVertices(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ buffer, uint length)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __ret = __Internal.FPDFAnnotGetVertices(__arg0, __arg1, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of paths in the ink list of an ink annotation.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>Returns the number of paths in the ink list if the annotation is of type ink,</para>
        /// <para>0 otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetInkListCount(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetInkListCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get a path in the ink list of an ink annotation. |buffer| is an array of</para>
        /// <para>points of the path. If |length| is less than the returned length, or |annot|</para>
        /// <para>or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>path_index - index of the path</para>
        /// <para>buffer - buffer for holding the points.</para>
        /// <para>length - length of the buffer in points.</para>
        /// <para>Returns the number of points of the path if the annotation is of type ink, 0</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static uint FPDFAnnotGetInkListPath(global::PDFiumCore.FpdfAnnotationT annot, uint path_index, global::PDFiumCore.FS_POINTF_ buffer, uint length)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg2 = ReferenceEquals(buffer, null) ? global::System.IntPtr.Zero : buffer.__Instance;
            var __ret = __Internal.FPDFAnnotGetInkListPath(__arg0, path_index, __arg2, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the starting and ending coordinates of a line annotation.</para>
        /// <para>annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()</para>
        /// <para>start - starting point</para>
        /// <para>end - ending point</para>
        /// <para>Returns true if the annotation is of type line, |start| and |end| are not</para>
        /// <para>NULL, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotGetLine(global::PDFiumCore.FpdfAnnotationT annot, global::PDFiumCore.FS_POINTF_ start, global::PDFiumCore.FS_POINTF_ end)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __arg1 = ReferenceEquals(start, null) ? global::System.IntPtr.Zero : start.__Instance;
            var __arg2 = ReferenceEquals(end, null) ? global::System.IntPtr.Zero : end.__Instance;
            var __ret = __Internal.FPDFAnnotGetLine(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if |annot|'s dictionary has |key| as a key.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns true if |key| exists.</para>
        /// </summary>
        public static int FPDFAnnotHasKey(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotHasKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value corresponding to |key| in |annot|'s dictionary.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns the type of the dictionary value.</para>
        /// </summary>
        public static int FPDFAnnotGetValueType(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the string value corresponding to |key| in |annot|'s dictionary,</para>
        /// <para>overwriting the existing value if any. The value type would be</para>
        /// <para>FPDF_OBJECT_STRING after this function call succeeds.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the dictionary entry to be set, encoded in UTF-8.</para>
        /// <para>value  - the string value to be set, encoded in UTF-16LE.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetStringValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref ushort value)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotSetStringValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value corresponding to |key| in |annot|'s dictionary. |buffer|</para>
        /// <para>is only modified if |buflen| is longer than the length of contents. Note that</para>
        /// <para>if |key| does not exist in the dictionary or if |key|'s corresponding value</para>
        /// <para>in the dictionary is not a string (i.e. the value is not of type</para>
        /// <para>FPDF_OBJECT_STRING or FPDF_OBJECT_NAME), then an empty string would be copied</para>
        /// <para>to |buffer| and the return value would be 2. On other errors, nothing would</para>
        /// <para>be added to |buffer| and the return value would be 0.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>buffer - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetStringValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetStringValue(__arg0, key, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the float value corresponding to |key| in |annot|'s dictionary. Writes</para>
        /// <para>value to |value| and returns True if |key| exists in the dictionary and</para>
        /// <para>|key|'s corresponding value is a number (FPDF_OBJECT_NUMBER), False</para>
        /// <para>otherwise.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>value  - receives the value, must not be NULL.</para>
        /// <para>Returns True if value found, False otherwise.</para>
        /// </summary>
        public static int FPDFAnnotGetNumberValue(global::PDFiumCore.FpdfAnnotationT annot, string key, ref float value)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotGetNumberValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the AP (appearance string) in |annot|'s dictionary for a given</para>
        /// <para>|appearanceMode|.</para>
        /// <para>annot          - handle to an annotation.</para>
        /// <para>appearanceMode - the appearance mode (normal, rollover or down) for which</para>
        /// <para>to get the AP.</para>
        /// <para>value          - the string value to be set, encoded in UTF-16LE. If</para>
        /// <para>nullptr is passed, the AP is cleared for that mode. If the</para>
        /// <para>mode is Normal, APs for all modes are cleared.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetAP(global::PDFiumCore.FpdfAnnotationT annot, int appearanceMode, ref ushort value)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotSetAP(__arg0, appearanceMode, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the AP (appearance string) from |annot|'s dictionary for a given</para>
        /// <para>|appearanceMode|.</para>
        /// <para>|buffer| is only modified if |buflen| is large enough to hold the whole AP</para>
        /// <para>string. If |buflen| is smaller, the total size of the AP is still returned,</para>
        /// <para>but nothing is copied.</para>
        /// <para>If there is no appearance stream for |annot| in |appearanceMode|, an empty</para>
        /// <para>string is written to |buf| and 2 is returned.</para>
        /// <para>On other errors, nothing is written to |buffer| and 0 is returned.</para>
        /// <para>annot          - handle to an annotation.</para>
        /// <para>appearanceMode - the appearance mode (normal, rollover or down) for which</para>
        /// <para>to get the AP.</para>
        /// <para>buffer         - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen         - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetAP(global::PDFiumCore.FpdfAnnotationT annot, int appearanceMode, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetAP(__arg0, appearanceMode, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation corresponding to |key| in |annot|'s dictionary. Common</para>
        /// <para>keys for linking annotations include &quot;IRT&quot; and &quot;Popup&quot;. Must call</para>
        /// <para>FPDFPage_CloseAnnot() when the annotation returned by this function is no</para>
        /// <para>longer needed.</para>
        /// <para>annot  - handle to an annotation.</para>
        /// <para>key    - the key to the requested dictionary entry, encoded in UTF-8.</para>
        /// <para>Returns a handle to the linked annotation object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFAnnotGetLinkedAnnot(global::PDFiumCore.FpdfAnnotationT annot, string key)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetLinkedAnnot(__arg0, key);
            global::PDFiumCore.FpdfAnnotationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAnnotationT) global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAnnotationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation flags of |annot|.</para>
        /// <para>annot    - handle to an annotation.</para>
        /// <para>Returns the annotation flags.</para>
        /// </summary>
        public static int FPDFAnnotGetFlags(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFlags(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the |annot|'s flags to be of the value |flags|.</para>
        /// <para>annot      - handle to an annotation.</para>
        /// <para>flags      - the flag values to be set.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAnnotSetFlags(global::PDFiumCore.FpdfAnnotationT annot, int flags)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotSetFlags(__arg0, flags);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the annotation flags of |annot|.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>Returns the annotation flags specific to interactive forms.</para>
        /// </summary>
        public static int FPDFAnnotGetFormFieldFlags(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldFlags(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Retrieves an interactive form annotation whose rectangle contains a given</para>
        /// <para>point on a page. Must call FPDFPage_CloseAnnot() when the annotation returned</para>
        /// <para>is no longer needed.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   handle to the page, returned by FPDF_LoadPage function.</para>
        /// <para>point       -   position in PDF &quot;user space&quot;.</para>
        /// <para>Returns the interactive form annotation whose rectangle contains the given</para>
        /// <para>coordinates on the page. If there is no such annotation, return NULL.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFAnnotGetFormFieldAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_POINTF_ point)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg2 = ReferenceEquals(point, null) ? global::System.IntPtr.Zero : point.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldAtPoint(__arg0, __arg1, __arg2);
            global::PDFiumCore.FpdfAnnotationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAnnotationT) global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAnnotationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the name of |annot|, which is an interactive form annotation.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value will</para>
        /// <para>be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the name string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldName(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldName(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the form field type of |annot|, which is an interactive form annotation.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>Returns the type of the form field (one of the FPDF_FORMFIELD_* values) on</para>
        /// <para>success. Returns -1 on error.</para>
        /// <para>See field types in fpdf_formfill.h.</para>
        /// </summary>
        public static int FPDFAnnotGetFormFieldType(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormFieldType(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the value of |annot|, which is an interactive form annotation.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value will</para>
        /// <para>be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldValue(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldValue(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of options in the |annot|'s &quot;Opt&quot; dictionary. Intended for</para>
        /// <para>use with listbox and combobox widget annotations.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns the number of options in &quot;Opt&quot; dictionary on success. Return value</para>
        /// <para>will be -1 if annotation does not have an &quot;Opt&quot; dictionary or other error.</para>
        /// </summary>
        public static int FPDFAnnotGetOptionCount(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetOptionCount(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value for the label of the option at |index| in |annot|'s</para>
        /// <para>&quot;Opt&quot; dictionary. Intended for use with listbox and combobox widget</para>
        /// <para>annotations. |buffer| is only modified if |buflen| is longer than the length</para>
        /// <para>of contents. If index is out of range or in case of other error, nothing</para>
        /// <para>will be added to |buffer| and the return value will be 0. Note that</para>
        /// <para>return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>index   - numeric index of the option in the &quot;Opt&quot; array</para>
        /// <para>buffer  - buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// <para>If |annot| does not have an &quot;Opt&quot; array, |index| is out of range or if any</para>
        /// <para>other error occurs, returns 0.</para>
        /// </summary>
        public static uint FPDFAnnotGetOptionLabel(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, int index, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer3 = &buffer)
            {
                var __arg3 = __buffer3;
                var __ret = __Internal.FPDFAnnotGetOptionLabel(__arg0, __arg1, index, __arg3, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Determine whether or not the option at |index| in |annot|'s &quot;Opt&quot; dictionary</para>
        /// <para>is selected. Intended for use with listbox and combobox widget annotations.</para>
        /// <para>handle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>index   - numeric index of the option in the &quot;Opt&quot; array.</para>
        /// <para>Returns true if the option at |index| in |annot|'s &quot;Opt&quot; dictionary is</para>
        /// <para>selected, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotIsOptionSelected(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot, int index)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotIsOptionSelected(__arg0, __arg1, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the float value of the font size for an |annot| with variable text.</para>
        /// <para>If 0, the font is to be auto-sized: its size is computed as a function of</para>
        /// <para>the height of the annotation rectangle.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>value   - Required. Float which will be set to font size on success.</para>
        /// <para>Returns true if the font size was set in |value|, false on error or if</para>
        /// <para>|value| not provided.</para>
        /// </summary>
        public static int FPDFAnnotGetFontSize(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref float value)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAnnotGetFontSize(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Determine if |annot| is a form widget that is checked. Intended for use with</para>
        /// <para>checkbox and radio button widgets.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns true if |annot| is a form widget and is checked, false otherwise.</para>
        /// </summary>
        public static int FPDFAnnotIsChecked(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotIsChecked(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the list of focusable annotation subtypes. Annotations of subtype</para>
        /// <para>FPDF_ANNOT_WIDGET are by default focusable. New subtypes set using this API</para>
        /// <para>will override the existing subtypes.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>subtypes - list of annotation subtype which can be tabbed over.</para>
        /// <para>count    - total number of annotation subtype in list.</para>
        /// <para>Returns true if list of annotation subtype is set successfully, false</para>
        /// <para>otherwise.</para>
        /// </summary>
        public static int FPDFAnnotSetFocusableSubtypes(global::PDFiumCore.FpdfFormHandleT hHandle, ref int subtypes, ulong count)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            fixed (int* __subtypes1 = &subtypes)
            {
                var __arg1 = __subtypes1;
                var __ret = __Internal.FPDFAnnotSetFocusableSubtypes(__arg0, __arg1, count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the count of focusable annotation subtypes as set by host</para>
        /// <para>for a |hHandle|.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>Returns the count of focusable annotation subtypes or -1 on error.</para>
        /// <para>Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.</para>
        /// </summary>
        public static int FPDFAnnotGetFocusableSubtypesCount(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __ret = __Internal.FPDFAnnotGetFocusableSubtypesCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the list of focusable annotation subtype as set by host.</para>
        /// <para>hHandle  - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>subtypes - receives the list of annotation subtype which can be tabbed</para>
        /// <para>over. Caller must have allocated |subtypes| more than or</para>
        /// <para>equal to the count obtained from</para>
        /// <para>FPDFAnnot_GetFocusableSubtypesCount() API.</para>
        /// <para>count    - size of |subtypes|.</para>
        /// <para>Returns true on success and set list of annotation subtype to |subtypes|,</para>
        /// <para>false otherwise.</para>
        /// <para>Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable.</para>
        /// </summary>
        public static int FPDFAnnotGetFocusableSubtypes(global::PDFiumCore.FpdfFormHandleT hHandle, ref int subtypes, ulong count)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            fixed (int* __subtypes1 = &subtypes)
            {
                var __arg1 = __subtypes1;
                var __ret = __Internal.FPDFAnnotGetFocusableSubtypes(__arg0, __arg1, count);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets FPDF_LINK object for |annot|. Intended to use for link annotations.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns FPDF_LINK from the FPDF_ANNOTATION and NULL on failure,</para>
        /// <para>if the input annot is NULL or input annot's subtype is not link.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfLinkT FPDFAnnotGetLink(global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetLink(__arg0);
            global::PDFiumCore.FpdfLinkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfLinkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfLinkT) global::PDFiumCore.FpdfLinkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfLinkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the count of annotations in the |annot|'s control group.</para>
        /// <para>A group of interactive form annotations is collectively called a form</para>
        /// <para>control group. Here, |annot|, an interactive form annotation, should be</para>
        /// <para>either a radio button or a checkbox.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns number of controls in its control group or -1 on error.</para>
        /// </summary>
        public static int FPDFAnnotGetFormControlCount(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormControlCount(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the index of |annot| in |annot|'s control group.</para>
        /// <para>A group of interactive form annotations is collectively called a form</para>
        /// <para>control group. Here, |annot|, an interactive form annotation, should be</para>
        /// <para>either a radio button or a checkbox.</para>
        /// <para>hHandle - handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>annot   - handle to an annotation.</para>
        /// <para>Returns index of a given |annot| in its control group or -1 on error.</para>
        /// </summary>
        public static int FPDFAnnotGetFormControlIndex(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FPDFAnnotGetFormControlIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the export value of |annot| which is an interactive form annotation.</para>
        /// <para>Intended for use with radio button and checkbox widget annotations.</para>
        /// <para>|buffer| is only modified if |buflen| is longer than the length of contents.</para>
        /// <para>In case of error, nothing will be added to |buffer| and the return value</para>
        /// <para>will be 0. Note that return value of empty string is 2 for &quot;\0\0&quot;.</para>
        /// <para>hHandle     -   handle to the form fill module, returned by</para>
        /// <para>FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   handle to an interactive form annotation.</para>
        /// <para>buffer      -   buffer for holding the value string, encoded in UTF-16LE.</para>
        /// <para>buflen      -   length of the buffer in bytes.</para>
        /// <para>Returns the length of the string value in bytes.</para>
        /// </summary>
        public static uint FPDFAnnotGetFormFieldExportValue(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfAnnotationT annot, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAnnotGetFormFieldExportValue(__arg0, __arg1, __arg2, buflen);
                return __ret;
            }
        }
    }

    public enum FPDF_FILEIDTYPE
    {
        FILEIDTYPE_PERMANENT = 0,
        FILEIDTYPE_CHANGING = 1
    }

    public unsafe partial class FS_QUADPOINTSF : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x1;

            [FieldOffset(4)]
            internal float y1;

            [FieldOffset(8)]
            internal float x2;

            [FieldOffset(12)]
            internal float y2;

            [FieldOffset(16)]
            internal float x3;

            [FieldOffset(20)]
            internal float y3;

            [FieldOffset(24)]
            internal float x4;

            [FieldOffset(28)]
            internal float y4;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FS_QUADPOINTSF@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_QUADPOINTSF> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FS_QUADPOINTSF>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FS_QUADPOINTSF __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_QUADPOINTSF(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FS_QUADPOINTSF __CreateInstance(global::PDFiumCore.FS_QUADPOINTSF.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FS_QUADPOINTSF(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FS_QUADPOINTSF.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_QUADPOINTSF.__Internal));
            *(global::PDFiumCore.FS_QUADPOINTSF.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_QUADPOINTSF(global::PDFiumCore.FS_QUADPOINTSF.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FS_QUADPOINTSF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FS_QUADPOINTSF()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FS_QUADPOINTSF(global::PDFiumCore.FS_QUADPOINTSF _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance) = *((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FS_QUADPOINTSF __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X1
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->x1;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->x1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->y1;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->y1 = value;
            }
        }

        public float X2
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->x2;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->x2 = value;
            }
        }

        public float Y2
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->y2;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->y2 = value;
            }
        }

        public float X3
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->x3;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->x3 = value;
            }
        }

        public float Y3
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->y3;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->y3 = value;
            }
        }

        public float X4
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->x4;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->x4 = value;
            }
        }

        public float Y4
        {
            get
            {
                return ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*) __Instance)->y4;
            }

            set
            {
                ((global::PDFiumCore.FS_QUADPOINTSF.__Internal*)__Instance)->y4 = value;
            }
        }
    }

    public unsafe partial class fpdf_doc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_GetFirstChild")]
            internal static extern global::System.IntPtr FPDFBookmarkGetFirstChild(global::System.IntPtr document, global::System.IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_GetNextSibling")]
            internal static extern global::System.IntPtr FPDFBookmarkGetNextSibling(global::System.IntPtr document, global::System.IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_GetTitle")]
            internal static extern uint FPDFBookmarkGetTitle(global::System.IntPtr bookmark, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_Find")]
            internal static extern global::System.IntPtr FPDFBookmarkFind(global::System.IntPtr document, ushort* title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_GetDest")]
            internal static extern global::System.IntPtr FPDFBookmarkGetDest(global::System.IntPtr document, global::System.IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFBookmark_GetAction")]
            internal static extern global::System.IntPtr FPDFBookmarkGetAction(global::System.IntPtr bookmark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAction_GetType")]
            internal static extern uint FPDFActionGetType(global::System.IntPtr action);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAction_GetDest")]
            internal static extern global::System.IntPtr FPDFActionGetDest(global::System.IntPtr document, global::System.IntPtr action);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAction_GetFilePath")]
            internal static extern uint FPDFActionGetFilePath(global::System.IntPtr action, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAction_GetURIPath")]
            internal static extern uint FPDFActionGetURIPath(global::System.IntPtr document, global::System.IntPtr action, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDest_GetDestPageIndex")]
            internal static extern int FPDFDestGetDestPageIndex(global::System.IntPtr document, global::System.IntPtr dest);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDest_GetView")]
            internal static extern uint FPDFDestGetView(global::System.IntPtr dest, uint* pNumParams, float* pParams);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDest_GetLocationInPage")]
            internal static extern int FPDFDestGetLocationInPage(global::System.IntPtr dest, int* hasXVal, int* hasYVal, int* hasZoomVal, float* x, float* y, float* zoom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetLinkAtPoint")]
            internal static extern global::System.IntPtr FPDFLinkGetLinkAtPoint(global::System.IntPtr page, double x, double y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetLinkZOrderAtPoint")]
            internal static extern int FPDFLinkGetLinkZOrderAtPoint(global::System.IntPtr page, double x, double y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetDest")]
            internal static extern global::System.IntPtr FPDFLinkGetDest(global::System.IntPtr document, global::System.IntPtr link);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetAction")]
            internal static extern global::System.IntPtr FPDFLinkGetAction(global::System.IntPtr link);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_Enumerate")]
            internal static extern int FPDFLinkEnumerate(global::System.IntPtr page, int* start_pos, global::System.IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetAnnot")]
            internal static extern global::System.IntPtr FPDFLinkGetAnnot(global::System.IntPtr page, global::System.IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetAnnotRect")]
            internal static extern int FPDFLinkGetAnnotRect(global::System.IntPtr link_annot, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_CountQuadPoints")]
            internal static extern int FPDFLinkCountQuadPoints(global::System.IntPtr link_annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetQuadPoints")]
            internal static extern int FPDFLinkGetQuadPoints(global::System.IntPtr link_annot, int quad_index, global::System.IntPtr quad_points);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageAAction")]
            internal static extern global::System.IntPtr FPDF_GetPageAAction(global::System.IntPtr page, int aa_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetFileIdentifier")]
            internal static extern uint FPDF_GetFileIdentifier(global::System.IntPtr document, global::PDFiumCore.FPDF_FILEIDTYPE id_type, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetMetaText")]
            internal static extern uint FPDF_GetMetaText(global::System.IntPtr document, [MarshalAs(UnmanagedType.LPUTF8Str)] string tag, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetPageLabel")]
            internal static extern uint FPDF_GetPageLabel(global::System.IntPtr document, int page_index, global::System.IntPtr buffer, uint buflen);
        }

        /// <summary>
        /// <para>Get the first child of |bookmark|, or the first top-level bookmark item.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the current bookmark. Pass NULL for the first top</para>
        /// <para>level item.</para>
        /// <para>Returns a handle to the first child of |bookmark| or the first top-level</para>
        /// <para>bookmark item. NULL if no child or top-level bookmark found.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkGetFirstChild(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(bookmark, null) ? global::System.IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetFirstChild(__arg0, __arg1);
            global::PDFiumCore.FpdfBookmarkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBookmarkT) global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBookmarkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the next sibling of |bookmark|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the current bookmark.</para>
        /// <para>Returns a handle to the next sibling of |bookmark|, or NULL if this is the</para>
        /// <para>last bookmark at this level.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkGetNextSibling(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(bookmark, null) ? global::System.IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetNextSibling(__arg0, __arg1);
            global::PDFiumCore.FpdfBookmarkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBookmarkT) global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBookmarkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the title of |bookmark|.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>buffer   - buffer for the title. May be NULL.</para>
        /// <para>buflen   - the length of the buffer in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the title, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the |buffer| and</para>
        /// <para>|buflen| parameters.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The</para>
        /// <para>string is terminated by a UTF16 NUL character. If |buflen| is less than the</para>
        /// <para>required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFBookmarkGetTitle(global::PDFiumCore.FpdfBookmarkT bookmark, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(bookmark, null) ? global::System.IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetTitle(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Find the bookmark with |title| in |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>title    - the UTF-16LE encoded Unicode title for which to search.</para>
        /// <para>Returns the handle to the bookmark, or NULL if |title| can't be found.</para>
        /// <para>FPDFBookmark_Find() will always return the first bookmark found even if</para>
        /// <para>multiple bookmarks have the same |title|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBookmarkT FPDFBookmarkFind(global::PDFiumCore.FpdfDocumentT document, ref ushort title)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (ushort* __title1 = &title)
            {
                var __arg1 = __title1;
                var __ret = __Internal.FPDFBookmarkFind(__arg0, __arg1);
                global::PDFiumCore.FpdfBookmarkT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::PDFiumCore.FpdfBookmarkT) global::PDFiumCore.FpdfBookmarkT.NativeToManagedMap[__ret];
                else __result0 = global::PDFiumCore.FpdfBookmarkT.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Get the destination associated with |bookmark|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>Returns the handle to the destination data,  NULL if no destination is</para>
        /// <para>associated with |bookmark|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFBookmarkGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(bookmark, null) ? global::System.IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetDest(__arg0, __arg1);
            global::PDFiumCore.FpdfDestT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDestT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDestT) global::PDFiumCore.FpdfDestT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDestT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the action associated with |bookmark|.</para>
        /// <para>bookmark - handle to the bookmark.</para>
        /// <para>Returns the handle to the action data, or NULL if no action is associated</para>
        /// <para>with |bookmark|. When NULL is returned, FPDFBookmark_GetDest() should be</para>
        /// <para>called to get the |bookmark| destination data.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDFBookmarkGetAction(global::PDFiumCore.FpdfBookmarkT bookmark)
        {
            var __arg0 = ReferenceEquals(bookmark, null) ? global::System.IntPtr.Zero : bookmark.__Instance;
            var __ret = __Internal.FPDFBookmarkGetAction(__arg0);
            global::PDFiumCore.FpdfActionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfActionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfActionT) global::PDFiumCore.FpdfActionT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfActionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the type of |action|.</para>
        /// <para>action - handle to the action.</para>
        /// <para>Returns one of:</para>
        /// <para>PDFACTION_UNSUPPORTED</para>
        /// <para>PDFACTION_GOTO</para>
        /// <para>PDFACTION_REMOTEGOTO</para>
        /// <para>PDFACTION_URI</para>
        /// <para>PDFACTION_LAUNCH</para>
        /// </summary>
        public static uint FPDFActionGetType(global::PDFiumCore.FpdfActionT action)
        {
            var __arg0 = ReferenceEquals(action, null) ? global::System.IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the destination of |action|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>action   - handle to the action. |action| must be a |PDFACTION_GOTO| or</para>
        /// <para>|PDFACTION_REMOTEGOTO|.</para>
        /// <para>Returns a handle to the destination data, or NULL on error, typically</para>
        /// <para>because the arguments were bad or the action was of the wrong type.</para>
        /// <para>In the case of |PDFACTION_REMOTEGOTO|, you must first call</para>
        /// <para>FPDFAction_GetFilePath(), then load the document at that path, then pass</para>
        /// <para>the document handle from that document as |document| to FPDFAction_GetDest().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFActionGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfActionT action)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(action, null) ? global::System.IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetDest(__arg0, __arg1);
            global::PDFiumCore.FpdfDestT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDestT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDestT) global::PDFiumCore.FpdfDestT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDestT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the file path of |action|.</para>
        /// <para>action - handle to the action. |action| must be a |PDFACTION_LAUNCH| or</para>
        /// <para>|PDFACTION_REMOTEGOTO|.</para>
        /// <para>buffer - a buffer for output the path string. May be NULL.</para>
        /// <para>buflen - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the file path, including the trailing NUL</para>
        /// <para>character, or 0 on error, typically because the arguments were bad or the</para>
        /// <para>action was of the wrong type.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-8 encoding.</para>
        /// <para>If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFActionGetFilePath(global::PDFiumCore.FpdfActionT action, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(action, null) ? global::System.IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetFilePath(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the URI path of |action|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>action   - handle to the action. Must be a |PDFACTION_URI|.</para>
        /// <para>buffer   - a buffer for the path string. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the URI path, including the trailing NUL</para>
        /// <para>character, or 0 on error, typically because the arguments were bad or the</para>
        /// <para>action was of the wrong type.</para>
        /// <para>The |buffer| is always encoded in 7-bit ASCII. If |buflen| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFActionGetURIPath(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfActionT action, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(action, null) ? global::System.IntPtr.Zero : action.__Instance;
            var __ret = __Internal.FPDFActionGetURIPath(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the page index of |dest|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>dest     - handle to the destination.</para>
        /// <para>Returns the 0-based page index containing |dest|. Returns -1 on error.</para>
        /// </summary>
        public static int FPDFDestGetDestPageIndex(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfDestT dest)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(dest, null) ? global::System.IntPtr.Zero : dest.__Instance;
            var __ret = __Internal.FPDFDestGetDestPageIndex(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the view (fit type) specified by |dest|.</para>
        /// <para>dest         - handle to the destination.</para>
        /// <para>pNumParams   - receives the number of view parameters, which is at most 4.</para>
        /// <para>pParams      - buffer to write the view parameters. Must be at least 4</para>
        /// <para>FS_FLOATs long.</para>
        /// <para>Returns one of the PDFDEST_VIEW_* constants, PDFDEST_VIEW_UNKNOWN_MODE if</para>
        /// <para>|dest| does not specify a view.</para>
        /// </summary>
        public static uint FPDFDestGetView(global::PDFiumCore.FpdfDestT dest, ref uint pNumParams, ref float pParams)
        {
            var __arg0 = ReferenceEquals(dest, null) ? global::System.IntPtr.Zero : dest.__Instance;
            fixed (uint* __pNumParams1 = &pNumParams)
            {
                var __arg1 = __pNumParams1;
                fixed (float* __pParams2 = &pParams)
                {
                    var __arg2 = __pParams2;
                    var __ret = __Internal.FPDFDestGetView(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Get the (x, y, zoom) location of |dest| in the destination page, if the</para>
        /// <para>destination is in [page /XYZ x y zoom] syntax.</para>
        /// <para>dest       - handle to the destination.</para>
        /// <para>hasXVal    - out parameter; true if the x value is not null</para>
        /// <para>hasYVal    - out parameter; true if the y value is not null</para>
        /// <para>hasZoomVal - out parameter; true if the zoom value is not null</para>
        /// <para>x          - out parameter; the x coordinate, in page coordinates.</para>
        /// <para>y          - out parameter; the y coordinate, in page coordinates.</para>
        /// <para>zoom       - out parameter; the zoom value.</para>
        /// <para>Returns TRUE on successfully reading the /XYZ value.</para>
        /// <para>Note the [x, y, zoom] values are only set if the corresponding hasXVal,</para>
        /// <para>hasYVal or hasZoomVal flags are true.</para>
        /// </summary>
        public static int FPDFDestGetLocationInPage(global::PDFiumCore.FpdfDestT dest, ref int hasXVal, ref int hasYVal, ref int hasZoomVal, ref float x, ref float y, ref float zoom)
        {
            var __arg0 = ReferenceEquals(dest, null) ? global::System.IntPtr.Zero : dest.__Instance;
            fixed (int* __hasXVal1 = &hasXVal)
            {
                var __arg1 = __hasXVal1;
                fixed (int* __hasYVal2 = &hasYVal)
                {
                    var __arg2 = __hasYVal2;
                    fixed (int* __hasZoomVal3 = &hasZoomVal)
                    {
                        var __arg3 = __hasZoomVal3;
                        fixed (float* __x4 = &x)
                        {
                            var __arg4 = __x4;
                            fixed (float* __y5 = &y)
                            {
                                var __arg5 = __y5;
                                fixed (float* __zoom6 = &zoom)
                                {
                                    var __arg6 = __zoom6;
                                    var __ret = __Internal.FPDFDestGetLocationInPage(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                                    return __ret;
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Find a link at point (|x|,|y|) on |page|.</para>
        /// <para>page - handle to the document page.</para>
        /// <para>x    - the x coordinate, in the page coordinate system.</para>
        /// <para>y    - the y coordinate, in the page coordinate system.</para>
        /// <para>Returns a handle to the link, or NULL if no link found at the given point.</para>
        /// <para>You can convert coordinates from screen coordinates to page coordinates using</para>
        /// <para>FPDF_DeviceToPage().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfLinkT FPDFLinkGetLinkAtPoint(global::PDFiumCore.FpdfPageT page, double x, double y)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFLinkGetLinkAtPoint(__arg0, x, y);
            global::PDFiumCore.FpdfLinkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfLinkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfLinkT) global::PDFiumCore.FpdfLinkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfLinkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Find the Z-order of link at point (|x|,|y|) on |page|.</para>
        /// <para>page - handle to the document page.</para>
        /// <para>x    - the x coordinate, in the page coordinate system.</para>
        /// <para>y    - the y coordinate, in the page coordinate system.</para>
        /// <para>Returns the Z-order of the link, or -1 if no link found at the given point.</para>
        /// <para>Larger Z-order numbers are closer to the front.</para>
        /// <para>You can convert coordinates from screen coordinates to page coordinates using</para>
        /// <para>FPDF_DeviceToPage().</para>
        /// </summary>
        public static int FPDFLinkGetLinkZOrderAtPoint(global::PDFiumCore.FpdfPageT page, double x, double y)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFLinkGetLinkZOrderAtPoint(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Get destination info for |link|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>link     - handle to the link.</para>
        /// <para>Returns a handle to the destination, or NULL if there is no destination</para>
        /// <para>associated with the link. In this case, you should call FPDFLink_GetAction()</para>
        /// <para>to retrieve the action associated with |link|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDestT FPDFLinkGetDest(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfLinkT link)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(link, null) ? global::System.IntPtr.Zero : link.__Instance;
            var __ret = __Internal.FPDFLinkGetDest(__arg0, __arg1);
            global::PDFiumCore.FpdfDestT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDestT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDestT) global::PDFiumCore.FpdfDestT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDestT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get action info for |link|.</para>
        /// <para>link - handle to the link.</para>
        /// <para>Returns a handle to the action associated to |link|, or NULL if no action.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDFLinkGetAction(global::PDFiumCore.FpdfLinkT link)
        {
            var __arg0 = ReferenceEquals(link, null) ? global::System.IntPtr.Zero : link.__Instance;
            var __ret = __Internal.FPDFLinkGetAction(__arg0);
            global::PDFiumCore.FpdfActionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfActionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfActionT) global::PDFiumCore.FpdfActionT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfActionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Enumerates all the link annotations in |page|.</para>
        /// <para>page       - handle to the page.</para>
        /// <para>start_pos  - the start position, should initially be 0 and is updated with</para>
        /// <para>the next start position on return.</para>
        /// <para>link_annot - the link handle for |startPos|.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFLinkEnumerate(global::PDFiumCore.FpdfPageT page, ref int start_pos, global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (int* __start_pos1 = &start_pos)
            {
                var __arg1 = __start_pos1;
                var ____arg2 = ReferenceEquals(link_annot, null) ? global::System.IntPtr.Zero : link_annot.__Instance;
                var __arg2 = new global::System.IntPtr(&____arg2);
                var __ret = __Internal.FPDFLinkEnumerate(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets FPDF_ANNOTATION object for |link_annot|.</para>
        /// <para>page       - handle to the page in which FPDF_LINK object is present.</para>
        /// <para>link_annot - handle to link annotation.</para>
        /// <para>Returns FPDF_ANNOTATION from the FPDF_LINK and NULL on failure,</para>
        /// <para>if the input link annot or page is NULL.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAnnotationT FPDFLinkGetAnnot(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(link_annot, null) ? global::System.IntPtr.Zero : link_annot.__Instance;
            var __ret = __Internal.FPDFLinkGetAnnot(__arg0, __arg1);
            global::PDFiumCore.FpdfAnnotationT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAnnotationT) global::PDFiumCore.FpdfAnnotationT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAnnotationT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the rectangle for |link_annot|.</para>
        /// <para>link_annot - handle to the link annotation.</para>
        /// <para>rect       - the annotation rectangle.</para>
        /// <para>Returns true on success.</para>
        /// </summary>
        public static int FPDFLinkGetAnnotRect(global::PDFiumCore.FpdfLinkT link_annot, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = ReferenceEquals(link_annot, null) ? global::System.IntPtr.Zero : link_annot.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFLinkGetAnnotRect(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get the count of quadrilateral points to the |link_annot|.</para>
        /// <para>link_annot - handle to the link annotation.</para>
        /// <para>Returns the count of quadrilateral points.</para>
        /// </summary>
        public static int FPDFLinkCountQuadPoints(global::PDFiumCore.FpdfLinkT link_annot)
        {
            var __arg0 = ReferenceEquals(link_annot, null) ? global::System.IntPtr.Zero : link_annot.__Instance;
            var __ret = __Internal.FPDFLinkCountQuadPoints(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the quadrilateral points for the specified |quad_index| in |link_annot|.</para>
        /// <para>link_annot  - handle to the link annotation.</para>
        /// <para>quad_index  - the specified quad point index.</para>
        /// <para>quad_points - receives the quadrilateral points.</para>
        /// <para>Returns true on success.</para>
        /// </summary>
        public static int FPDFLinkGetQuadPoints(global::PDFiumCore.FpdfLinkT link_annot, int quad_index, global::PDFiumCore.FS_QUADPOINTSF quad_points)
        {
            var __arg0 = ReferenceEquals(link_annot, null) ? global::System.IntPtr.Zero : link_annot.__Instance;
            var __arg2 = ReferenceEquals(quad_points, null) ? global::System.IntPtr.Zero : quad_points.__Instance;
            var __ret = __Internal.FPDFLinkGetQuadPoints(__arg0, quad_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Gets an additional-action from |page|.</para>
        /// <para>page      - handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>aa_type   - the type of the page object's addtional-action, defined</para>
        /// <para>in public/fpdf_formfill.h</para>
        /// <para>Returns the handle to the action data, or NULL if there is no</para>
        /// <para>additional-action of type |aa_type|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfActionT FPDF_GetPageAAction(global::PDFiumCore.FpdfPageT page, int aa_type)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_GetPageAAction(__arg0, aa_type);
            global::PDFiumCore.FpdfActionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfActionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfActionT) global::PDFiumCore.FpdfActionT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfActionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the file identifer defined in the trailer of |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>id_type  - the file identifier type to retrieve.</para>
        /// <para>buffer   - a buffer for the file identifier. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the file identifier, including the NUL</para>
        /// <para>terminator.</para>
        /// <para>The |buffer| is always a byte string. The |buffer| is followed by a NUL</para>
        /// <para>terminator.  If |buflen| is less than the returned length, or |buffer| is</para>
        /// <para>NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetFileIdentifier(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEIDTYPE id_type, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetFileIdentifier(__arg0, id_type, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get meta-data |tag| content from |document|.</para>
        /// <para>document - handle to the document.</para>
        /// <para>tag      - the tag to retrieve. The tag can be one of:</para>
        /// <para>Title, Author, Subject, Keywords, Creator, Producer,</para>
        /// <para>CreationDate, or ModDate.</para>
        /// <para>For detailed explanations of these tags and their respective</para>
        /// <para>values, please refer to PDF Reference 1.6, section 10.2.1,</para>
        /// <para>'Document Information Dictionary'.</para>
        /// <para>buffer   - a buffer for the tag. May be NULL.</para>
        /// <para>buflen   - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the tag, including trailing zeros.</para>
        /// <para>The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two</para>
        /// <para>bytes of zeros indicating the end of the string.  If |buflen| is less than</para>
        /// <para>the returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>For linearized files, FPDFAvail_IsFormAvail must be called before this, and</para>
        /// <para>it must have returned PDF_FORM_AVAIL or PDF_FORM_NOTEXIST. Before that, there</para>
        /// <para>is no guarantee the metadata has been loaded.</para>
        /// </summary>
        public static uint FPDF_GetMetaText(global::PDFiumCore.FpdfDocumentT document, string tag, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetMetaText(__arg0, tag, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the page label for |page_index| from |document|.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_index  - the 0-based index of the page.</para>
        /// <para>buffer      - a buffer for the page label. May be NULL.</para>
        /// <para>buflen      - the length of the buffer, in bytes. May be 0.</para>
        /// <para>Returns the number of bytes in the page label, including trailing zeros.</para>
        /// <para>The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two</para>
        /// <para>bytes of zeros indicating the end of the string.  If |buflen| is less than</para>
        /// <para>the returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_GetPageLabel(global::PDFiumCore.FpdfDocumentT document, int page_index, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetPageLabel(__arg0, page_index, buffer, buflen);
            return __ret;
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void TimerCallback(int idEvent);

    public unsafe partial class IPDF_JsPlatform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr app_alert;

            [FieldOffset(16)]
            internal global::System.IntPtr app_beep;

            [FieldOffset(24)]
            internal global::System.IntPtr app_response;

            [FieldOffset(32)]
            internal global::System.IntPtr Doc_getFilePath;

            [FieldOffset(40)]
            internal global::System.IntPtr Doc_mail;

            [FieldOffset(48)]
            internal global::System.IntPtr Doc_print;

            [FieldOffset(56)]
            internal global::System.IntPtr Doc_submitForm;

            [FieldOffset(64)]
            internal global::System.IntPtr Doc_gotoPage;

            [FieldOffset(72)]
            internal global::System.IntPtr Field_browse;

            [FieldOffset(80)]
            internal global::System.IntPtr m_pFormfillinfo;

            [FieldOffset(88)]
            internal global::System.IntPtr m_isolate;

            [FieldOffset(96)]
            internal uint m_v8EmbedderSlot;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_IPDF_JsPlatform@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IPDF_JsPlatform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IPDF_JsPlatform>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.IPDF_JsPlatform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.IPDF_JsPlatform(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.IPDF_JsPlatform __CreateInstance(global::PDFiumCore.IPDF_JsPlatform.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.IPDF_JsPlatform(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.IPDF_JsPlatform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IPDF_JsPlatform.__Internal));
            *(global::PDFiumCore.IPDF_JsPlatform.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IPDF_JsPlatform(global::PDFiumCore.IPDF_JsPlatform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IPDF_JsPlatform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public IPDF_JsPlatform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IPDF_JsPlatform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public IPDF_JsPlatform(global::PDFiumCore.IPDF_JsPlatform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IPDF_JsPlatform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance) = *((global::PDFiumCore.IPDF_JsPlatform.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.IPDF_JsPlatform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_int_int AppAlert
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->app_alert;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_int_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->app_alert = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int AppBeep
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->app_beep;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->app_beep = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int_IntPtr_int AppResponse
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->app_response;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->app_response = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int Doc_getFilePath
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Doc_getFilePath;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Doc_getFilePath = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr Doc_mail
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Doc_mail;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Doc_mail = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int_int_int_int_int_int_int_int Doc_print
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Doc_print;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int_int_int_int_int_int_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int_int_int_int_int_int_int_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Doc_print = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr Doc_submitForm
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Doc_submitForm;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Doc_submitForm = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int Doc_gotoPage
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Doc_gotoPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Doc_gotoPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int Field_browse
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->Field_browse;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->Field_browse = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr MPFormfillinfo
        {
            get
            {
                return ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->m_pFormfillinfo;
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->m_pFormfillinfo = (global::System.IntPtr) value;
            }
        }

        public global::System.IntPtr MIsolate
        {
            get
            {
                return ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->m_isolate;
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->m_isolate = (global::System.IntPtr) value;
            }
        }

        public uint MV8EmbedderSlot
        {
            get
            {
                return ((global::PDFiumCore.IPDF_JsPlatform.__Internal*) __Instance)->m_v8EmbedderSlot;
            }

            set
            {
                ((global::PDFiumCore.IPDF_JsPlatform.__Internal*)__Instance)->m_v8EmbedderSlot = value;
            }
        }
    }

    public unsafe partial class FPDF_SYSTEMTIME : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort wYear;

            [FieldOffset(2)]
            internal ushort wMonth;

            [FieldOffset(4)]
            internal ushort wDayOfWeek;

            [FieldOffset(6)]
            internal ushort wDay;

            [FieldOffset(8)]
            internal ushort wHour;

            [FieldOffset(10)]
            internal ushort wMinute;

            [FieldOffset(12)]
            internal ushort wSecond;

            [FieldOffset(14)]
            internal ushort wMilliseconds;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FPDF_SYSTEMTIME@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSTEMTIME> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSTEMTIME>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_SYSTEMTIME __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_SYSTEMTIME(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_SYSTEMTIME __CreateInstance(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_SYSTEMTIME(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal));
            *(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_SYSTEMTIME(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_SYSTEMTIME(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_SYSTEMTIME()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_SYSTEMTIME(global::PDFiumCore.FPDF_SYSTEMTIME _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSTEMTIME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_SYSTEMTIME __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort WYear
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wYear;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wYear = value;
            }
        }

        public ushort WMonth
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wMonth;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wMonth = value;
            }
        }

        public ushort WDayOfWeek
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wDayOfWeek;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wDayOfWeek = value;
            }
        }

        public ushort WDay
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wDay;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wDay = value;
            }
        }

        public ushort WHour
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wHour;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wHour = value;
            }
        }

        public ushort WMinute
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wMinute;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wMinute = value;
            }
        }

        public ushort WSecond
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wSecond;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wSecond = value;
            }
        }

        public ushort WMilliseconds
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*) __Instance)->wMilliseconds;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSTEMTIME.__Internal*)__Instance)->wMilliseconds = value;
            }
        }
    }

    public unsafe partial class FPDF_FORMFILLINFO : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 280)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr Release;

            [FieldOffset(16)]
            internal global::System.IntPtr FFI_Invalidate;

            [FieldOffset(24)]
            internal global::System.IntPtr FFI_OutputSelectedRect;

            [FieldOffset(32)]
            internal global::System.IntPtr FFI_SetCursor;

            [FieldOffset(40)]
            internal global::System.IntPtr FFI_SetTimer;

            [FieldOffset(48)]
            internal global::System.IntPtr FFI_KillTimer;

            [FieldOffset(56)]
            internal global::System.IntPtr FFI_GetLocalTime;

            [FieldOffset(64)]
            internal global::System.IntPtr FFI_OnChange;

            [FieldOffset(72)]
            internal global::System.IntPtr FFI_GetPage;

            [FieldOffset(80)]
            internal global::System.IntPtr FFI_GetCurrentPage;

            [FieldOffset(88)]
            internal global::System.IntPtr FFI_GetRotation;

            [FieldOffset(96)]
            internal global::System.IntPtr FFI_ExecuteNamedAction;

            [FieldOffset(104)]
            internal global::System.IntPtr FFI_SetTextFieldFocus;

            [FieldOffset(112)]
            internal global::System.IntPtr FFI_DoURIAction;

            [FieldOffset(120)]
            internal global::System.IntPtr FFI_DoGoToAction;

            [FieldOffset(128)]
            internal global::System.IntPtr m_pJsPlatform;

            [FieldOffset(136)]
            internal int xfa_disabled;

            [FieldOffset(144)]
            internal global::System.IntPtr FFI_DisplayCaret;

            [FieldOffset(152)]
            internal global::System.IntPtr FFI_GetCurrentPageIndex;

            [FieldOffset(160)]
            internal global::System.IntPtr FFI_SetCurrentPage;

            [FieldOffset(168)]
            internal global::System.IntPtr FFI_GotoURL;

            [FieldOffset(176)]
            internal global::System.IntPtr FFI_GetPageViewRect;

            [FieldOffset(184)]
            internal global::System.IntPtr FFI_PageEvent;

            [FieldOffset(192)]
            internal global::System.IntPtr FFI_PopupMenu;

            [FieldOffset(200)]
            internal global::System.IntPtr FFI_OpenFile;

            [FieldOffset(208)]
            internal global::System.IntPtr FFI_EmailTo;

            [FieldOffset(216)]
            internal global::System.IntPtr FFI_UploadTo;

            [FieldOffset(224)]
            internal global::System.IntPtr FFI_GetPlatform;

            [FieldOffset(232)]
            internal global::System.IntPtr FFI_GetLanguage;

            [FieldOffset(240)]
            internal global::System.IntPtr FFI_DownloadFromURL;

            [FieldOffset(248)]
            internal global::System.IntPtr FFI_PostRequestURL;

            [FieldOffset(256)]
            internal global::System.IntPtr FFI_PutRequestURL;

            [FieldOffset(264)]
            internal global::System.IntPtr FFI_OnFocusChange;

            [FieldOffset(272)]
            internal global::System.IntPtr FFI_DoURIActionWithKeyboardModifier;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FPDF_FORMFILLINFO@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FORMFILLINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FORMFILLINFO>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_FORMFILLINFO __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FORMFILLINFO(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_FORMFILLINFO __CreateInstance(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FORMFILLINFO(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
            *(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FORMFILLINFO(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FORMFILLINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_FORMFILLINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FORMFILLINFO(global::PDFiumCore.FPDF_FORMFILLINFO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FORMFILLINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_FORMFILLINFO __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr Release
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double FFI_Invalidate
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_Invalidate;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_Invalidate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double FFI_OutputSelectedRect
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_OutputSelectedRect;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_double_double_double_double));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_OutputSelectedRect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int FFI_SetCursor
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_SetCursor;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_SetCursor = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_int_PDFiumCore_TimerCallback FFI_SetTimer
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_SetTimer;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_int_PDFiumCore_TimerCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_int_PDFiumCore_TimerCallback));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_SetTimer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int FFI_KillTimer
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_KillTimer;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_KillTimer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal_IntPtr FFI_GetLocalTime
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetLocalTime;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_PDFiumCore__FPDF_SYSTEMTIME___Internal_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetLocalTime = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr FFI_OnChange
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_OnChange;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_OnChange = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr_int FFI_GetPage
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr FFI_GetCurrentPage
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetCurrentPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetCurrentPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr FFI_GetRotation
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetRotation;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetRotation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_string FFI_ExecuteNamedAction
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_ExecuteNamedAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_string));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_ExecuteNamedAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_ushortPtr_uint_int FFI_SetTextFieldFocus
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_SetTextFieldFocus;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_ushortPtr_uint_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_ushortPtr_uint_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_SetTextFieldFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_string FFI_DoURIAction
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_DoURIAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_string));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_DoURIAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int_int_floatPtr_int FFI_DoGoToAction
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_DoGoToAction;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int_int_floatPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int_int_floatPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_DoGoToAction = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.IPDF_JsPlatform MPJsPlatform
        {
            get
            {
                global::PDFiumCore.IPDF_JsPlatform __result0;
                if (((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->m_pJsPlatform == IntPtr.Zero) __result0 = null;
                else if (global::PDFiumCore.IPDF_JsPlatform.NativeToManagedMap.ContainsKey(((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->m_pJsPlatform))
                    __result0 = (global::PDFiumCore.IPDF_JsPlatform) global::PDFiumCore.IPDF_JsPlatform.NativeToManagedMap[((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->m_pJsPlatform];
                else __result0 = global::PDFiumCore.IPDF_JsPlatform.__CreateInstance(((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->m_pJsPlatform);
                return __result0;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->m_pJsPlatform = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int XfaDisabled
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->xfa_disabled;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->xfa_disabled = value;
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_double_double_double_double FFI_DisplayCaret
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_DisplayCaret;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_double_double_double_double) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_double_double_double_double));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_DisplayCaret = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr FFI_GetCurrentPageIndex
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetCurrentPageIndex;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetCurrentPageIndex = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int FFI_SetCurrentPage
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_SetCurrentPage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_SetCurrentPage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr FFI_GotoURL
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GotoURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GotoURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_doublePtr_doublePtr_doublePtr_doublePtr FFI_GetPageViewRect
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetPageViewRect;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_doublePtr_doublePtr_doublePtr_doublePtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_doublePtr_doublePtr_doublePtr_doublePtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetPageViewRect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_int_uint FFI_PageEvent
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_PageEvent;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_int_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_int_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_PageEvent = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_IntPtr_int_float_float FFI_PopupMenu
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_PopupMenu;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_IntPtr_int_float_float) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_IntPtr_int_float_float));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_PopupMenu = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_ushortPtr_string FFI_OpenFile
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_OpenFile;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_ushortPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_ushortPtr_string));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_OpenFile = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr FFI_EmailTo
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_EmailTo;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_EmailTo = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr FFI_UploadTo
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_UploadTo;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_UploadTo = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int FFI_GetPlatform
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetPlatform;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetPlatform = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int FFI_GetLanguage
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_GetLanguage;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_GetLanguage = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_ushortPtr FFI_DownloadFromURL
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_DownloadFromURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_DownloadFromURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_IntPtr FFI_PostRequestURL
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_PostRequestURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_PostRequestURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr FFI_PutRequestURL
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_PutRequestURL;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_PutRequestURL = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int FFI_OnFocusChange
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_OnFocusChange;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_OnFocusChange = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_string_int FFI_DoURIActionWithKeyboardModifier
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*) __Instance)->FFI_DoURIActionWithKeyboardModifier;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_string_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_string_int));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FORMFILLINFO.__Internal*)__Instance)->FFI_DoURIActionWithKeyboardModifier = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_formfill
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDOC_InitFormFillEnvironment")]
            internal static extern global::System.IntPtr FPDFDOC_InitFormFillEnvironment(global::System.IntPtr document, global::System.IntPtr formInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDOC_ExitFormFillEnvironment")]
            internal static extern void FPDFDOC_ExitFormFillEnvironment(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnAfterLoadPage")]
            internal static extern void FORM_OnAfterLoadPage(global::System.IntPtr page, global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnBeforeClosePage")]
            internal static extern void FORM_OnBeforeClosePage(global::System.IntPtr page, global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_DoDocumentJSAction")]
            internal static extern void FORM_DoDocumentJSAction(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_DoDocumentOpenAction")]
            internal static extern void FORM_DoDocumentOpenAction(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_DoDocumentAAction")]
            internal static extern void FORM_DoDocumentAAction(global::System.IntPtr hHandle, int aaType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_DoPageAAction")]
            internal static extern void FORM_DoPageAAction(global::System.IntPtr page, global::System.IntPtr hHandle, int aaType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnMouseMove")]
            internal static extern int FORM_OnMouseMove(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnMouseWheel")]
            internal static extern int FORM_OnMouseWheel(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, global::System.IntPtr page_coord, int delta_x, int delta_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnFocus")]
            internal static extern int FORM_OnFocus(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnLButtonDown")]
            internal static extern int FORM_OnLButtonDown(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnRButtonDown")]
            internal static extern int FORM_OnRButtonDown(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnLButtonUp")]
            internal static extern int FORM_OnLButtonUp(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnRButtonUp")]
            internal static extern int FORM_OnRButtonUp(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnLButtonDoubleClick")]
            internal static extern int FORM_OnLButtonDoubleClick(global::System.IntPtr hHandle, global::System.IntPtr page, int modifier, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnKeyDown")]
            internal static extern int FORM_OnKeyDown(global::System.IntPtr hHandle, global::System.IntPtr page, int nKeyCode, int modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnKeyUp")]
            internal static extern int FORM_OnKeyUp(global::System.IntPtr hHandle, global::System.IntPtr page, int nKeyCode, int modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_OnChar")]
            internal static extern int FORM_OnChar(global::System.IntPtr hHandle, global::System.IntPtr page, int nChar, int modifier);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_GetFocusedText")]
            internal static extern uint FORM_GetFocusedText(global::System.IntPtr hHandle, global::System.IntPtr page, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_GetSelectedText")]
            internal static extern uint FORM_GetSelectedText(global::System.IntPtr hHandle, global::System.IntPtr page, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_ReplaceSelection")]
            internal static extern void FORM_ReplaceSelection(global::System.IntPtr hHandle, global::System.IntPtr page, ushort* wsText);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_SelectAllText")]
            internal static extern int FORM_SelectAllText(global::System.IntPtr hHandle, global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_CanUndo")]
            internal static extern int FORM_CanUndo(global::System.IntPtr hHandle, global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_CanRedo")]
            internal static extern int FORM_CanRedo(global::System.IntPtr hHandle, global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_Undo")]
            internal static extern int FORM_Undo(global::System.IntPtr hHandle, global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_Redo")]
            internal static extern int FORM_Redo(global::System.IntPtr hHandle, global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_ForceToKillFocus")]
            internal static extern int FORM_ForceToKillFocus(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_GetFocusedAnnot")]
            internal static extern int FORM_GetFocusedAnnot(global::System.IntPtr handle, int* page_index, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_SetFocusedAnnot")]
            internal static extern int FORM_SetFocusedAnnot(global::System.IntPtr handle, global::System.IntPtr annot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_HasFormFieldAtPoint")]
            internal static extern int FPDFPageHasFormFieldAtPoint(global::System.IntPtr hHandle, global::System.IntPtr page, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_FormFieldZOrderAtPoint")]
            internal static extern int FPDFPageFormFieldZOrderAtPoint(global::System.IntPtr hHandle, global::System.IntPtr page, double page_x, double page_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SetFormFieldHighlightColor")]
            internal static extern void FPDF_SetFormFieldHighlightColor(global::System.IntPtr hHandle, int fieldType, uint color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SetFormFieldHighlightAlpha")]
            internal static extern void FPDF_SetFormFieldHighlightAlpha(global::System.IntPtr hHandle, byte alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RemoveFormFieldHighlight")]
            internal static extern void FPDF_RemoveFormFieldHighlight(global::System.IntPtr hHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_FFLDraw")]
            internal static extern void FPDF_FFLDraw(global::System.IntPtr hHandle, global::System.IntPtr bitmap, global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetFormType")]
            internal static extern int FPDF_GetFormType(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_SetIndexSelected")]
            internal static extern int FORM_SetIndexSelected(global::System.IntPtr hHandle, global::System.IntPtr page, int index, int selected);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FORM_IsIndexSelected")]
            internal static extern int FORM_IsIndexSelected(global::System.IntPtr hHandle, global::System.IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_LoadXFA")]
            internal static extern int FPDF_LoadXFA(global::System.IntPtr document);
        }

        /// <summary>
        /// <para>Function: FPDFDOC_InitFormFillEnvironment</para>
        /// <para>Initialize form fill environment.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document from FPDF_LoadDocument().</para>
        /// <para>pFormFillInfo   -   Pointer to a FPDF_FORMFILLINFO structure.</para>
        /// <para>Return Value:</para>
        /// <para>Handle to the form fill module, or NULL on failure.</para>
        /// <para>Comments: This function should be called before any form fill operation.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFormHandleT FPDFDOC_InitFormFillEnvironment(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FORMFILLINFO formInfo)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(formInfo, null) ? global::System.IntPtr.Zero : formInfo.__Instance;
            var __ret = __Internal.FPDFDOC_InitFormFillEnvironment(__arg0, __arg1);
            global::PDFiumCore.FpdfFormHandleT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfFormHandleT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfFormHandleT) global::PDFiumCore.FpdfFormHandleT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfFormHandleT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFDOC_ExitFormFillEnvironment</para>
        /// <para>Take ownership of |hHandle| and exit form fill environment.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function is a no-op when |hHandle| is null.</para>
        /// </summary>
        public static void FPDFDOC_ExitFormFillEnvironment(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDFDOC_ExitFormFillEnvironment(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_OnAfterLoadPage</para>
        /// <para>This method is required for implementing all the form related</para>
        /// <para>functions. Should be invoked after user successfully loaded a</para>
        /// <para>PDF page, and FPDFDOC_InitFormFillEnvironment() has been invoked.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_OnAfterLoadPage(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_OnAfterLoadPage(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Function: FORM_OnBeforeClosePage</para>
        /// <para>This method is required for implementing all the form related</para>
        /// <para>functions. Should be invoked before user closes the PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_OnBeforeClosePage(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_OnBeforeClosePage(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentJSAction</para>
        /// <para>This method is required for performing document-level JavaScript</para>
        /// <para>actions. It should be invoked after the PDF document has been loaded.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: If there is document-level JavaScript action embedded in the document, this method will execute the JavaScript action. Otherwise, the method will do nothing.</para>
        /// </summary>
        public static void FORM_DoDocumentJSAction(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentJSAction(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentOpenAction</para>
        /// <para>This method is required for performing open-action when the document</para>
        /// <para>is opened.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if there are no open-actions embedded in the document.</para>
        /// </summary>
        public static void FORM_DoDocumentOpenAction(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentOpenAction(__arg0);
        }

        /// <summary>
        /// <para>Function: FORM_DoDocumentAAction</para>
        /// <para>This method is required for performing the document's</para>
        /// <para>additional-action.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>aaType      -   The type of the additional-actions which defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if there is no document additional-action corresponding to the specified |aaType|.</para>
        /// </summary>
        public static void FORM_DoDocumentAAction(global::PDFiumCore.FpdfFormHandleT hHandle, int aaType)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoDocumentAAction(__arg0, aaType);
        }

        /// <summary>
        /// <para>Function: FORM_DoPageAAction</para>
        /// <para>This method is required for performing the page object's</para>
        /// <para>additional-action when opened or closed.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>aaType      -   The type of the page object's additional-actions which defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This method will do nothing if no additional-action corresponding to the specified |aaType| exists.</para>
        /// </summary>
        public static void FORM_DoPageAAction(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfFormHandleT hHandle, int aaType)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FORM_DoPageAAction(__arg0, __arg1, aaType);
        }

        /// <summary>
        /// <para>Function: FORM_OnMouseMove</para>
        /// <para>Call this member function when the mouse cursor moves.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnMouseMove(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnMouseMove(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_OnMouseWheel</para>
        /// <para>Call this member function when the user scrolls the mouse wheel.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_coord  -   Specifies the coordinates of the cursor in PDF user space.</para>
        /// <para>delta_x     -   Specifies the amount of wheel movement on the x-axis, in units of platform-agnostic wheel deltas. Negative values mean left.</para>
        /// <para>delta_y     -   Specifies the amount of wheel movement on the y-axis, in units of platform-agnostic wheel deltas. Negative values mean down.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// <para>Comments: For |delta_x| and |delta_y|, the caller must normalize platform-specific wheel deltas. e.g. On Windows, a delta value of 240 for a WM_MOUSEWHEEL event normalizes to 2, since Windows defines WHEEL_DELTA as 120.</para>
        /// </summary>
        public static int FORM_OnMouseWheel(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, global::PDFiumCore.FS_POINTF_ page_coord, int delta_x, int delta_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg3 = ReferenceEquals(page_coord, null) ? global::System.IntPtr.Zero : page_coord.__Instance;
            var __ret = __Internal.FORM_OnMouseWheel(__arg0, __arg1, modifier, __arg3, delta_x, delta_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnFocus</para>
        /// <para>This function focuses the form annotation at a given point. If the</para>
        /// <para>annotation at the point already has focus, nothing happens. If there</para>
        /// <para>is no annotation at the point, removes form focus.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True if there is an annotation at the given point and it has focus.</para>
        /// </summary>
        public static int FORM_OnFocus(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnFocus(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnLButtonDown</para>
        /// <para>Call this member function when the user presses the left</para>
        /// <para>mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonDown(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonDown</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// </summary>
        public static int FORM_OnRButtonDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnRButtonDown(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonDown</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// <para></para>
        /// <para>FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FORM_OnRButtonDown(FPDF_FORMHANDLE hHandle, FPDF_PAGE page, int modifier, double page_x, double page_y);</para>
        /// <para></para>
        /// <para>Function: FORM_OnLButtonUp Call this member function when the user releases the left mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in device.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in device.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonUp(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnRButtonUp</para>
        /// <para>Same as above, execpt for the right mouse button.</para>
        /// <para>Comments: At the present time, has no effect except in XFA builds, but is included for the sake of symmetry.</para>
        /// </summary>
        public static int FORM_OnRButtonUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnRButtonUp(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnLButtonDoubleClick</para>
        /// <para>Call this member function when the user double clicks the</para>
        /// <para>left mouse button.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>modifier    -   Indicates whether various virtual keys are down.</para>
        /// <para>page_x      -   Specifies the x-coordinate of the cursor in PDF user space.</para>
        /// <para>page_y      -   Specifies the y-coordinate of the cursor in PDF user space.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnLButtonDoubleClick(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int modifier, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnLButtonDoubleClick(__arg0, __arg1, modifier, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnKeyDown</para>
        /// <para>Call this member function when a nonsystem key is pressed.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, aseturned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nKeyCode    -   Indicates whether various virtual keys are down.</para>
        /// <para>modifier    -   Contains the scan code, key-transition code, previous key state, and context code.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnKeyDown(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nKeyCode, int modifier)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnKeyDown(__arg0, __arg1, nKeyCode, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnKeyUp</para>
        /// <para>Call this member function when a nonsystem key is released.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nKeyCode    -   The virtual-key code of the given key.</para>
        /// <para>modifier    -   Contains the scan code, key-transition code, previous key state, and context code.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnKeyUp(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nKeyCode, int modifier)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnKeyUp(__arg0, __arg1, nKeyCode, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_OnChar</para>
        /// <para>Call this member function when a keystroke translates to a</para>
        /// <para>nonsystem character.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle    -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page       -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>nChar      -   The character code value of the key.</para>
        /// <para>modifier   -   Contains the scan code, key-transition code, previous key state, and context code.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_OnChar(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int nChar, int modifier)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_OnChar(__arg0, __arg1, nChar, modifier);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_GetFocusedText</para>
        /// <para>Call this function to obtain the text within the current focused</para>
        /// <para>field, if any.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>buffer      -   Buffer for holding the form text, encoded in UTF-16LE. If NULL, |buffer| is not modified.</para>
        /// <para>buflen      -   Length of |buffer| in bytes. If |buflen| is less than the length of the form text string, |buffer| is not modified.</para>
        /// <para>Return Value:</para>
        /// <para>Length in bytes for the text in the focused field.</para>
        /// </summary>
        public static uint FORM_GetFocusedText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_GetFocusedText(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_GetSelectedText</para>
        /// <para>Call this function to obtain selected text within a form text</para>
        /// <para>field or form combobox text field.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>buffer      -   Buffer for holding the selected text, encoded in UTF-16LE. If NULL, |buffer| is not modified.</para>
        /// <para>buflen      -   Length of |buffer| in bytes. If |buflen| is less than the length of the selected text string, |buffer| is not modified.</para>
        /// <para>Return Value:</para>
        /// <para>Length in bytes of selected text in form text field or form combobox</para>
        /// <para>text field.</para>
        /// </summary>
        public static uint FORM_GetSelectedText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_GetSelectedText(__arg0, __arg1, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_ReplaceSelection</para>
        /// <para>Call this function to replace the selected text in a form</para>
        /// <para>text field or user-editable form combobox text field with another</para>
        /// <para>text string (which can be empty or non-empty). If there is no</para>
        /// <para>selected text, this function will append the replacement text after</para>
        /// <para>the current caret position.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as Returned by FPDF_LoadPage().</para>
        /// <para>wsText      -   The text to be inserted, in UTF-16LE format.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FORM_ReplaceSelection(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, ref ushort wsText)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (ushort* __wsText2 = &wsText)
            {
                var __arg2 = __wsText2;
                __Internal.FORM_ReplaceSelection(__arg0, __arg1, __arg2);
            }
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_SelectAllText</para>
        /// <para>Call this function to select all the text within the currently focused</para>
        /// <para>form text field or form combobox text field.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>Whether the operation succeeded or not.</para>
        /// </summary>
        public static int FORM_SelectAllText(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_SelectAllText(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_CanUndo</para>
        /// <para>Find out if it is possible for the current focused widget in a given</para>
        /// <para>form to perform an undo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if it is possible to undo.</para>
        /// </summary>
        public static int FORM_CanUndo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_CanUndo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_CanRedo</para>
        /// <para>Find out if it is possible for the current focused widget in a given</para>
        /// <para>form to perform a redo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if it is possible to redo.</para>
        /// </summary>
        public static int FORM_CanRedo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_CanRedo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_Undo</para>
        /// <para>Make the current focussed widget perform an undo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if the undo operation succeeded.</para>
        /// </summary>
        public static int FORM_Undo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_Undo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_Redo</para>
        /// <para>Make the current focussed widget perform a redo operation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return Value:</para>
        /// <para>True if the redo operation succeeded.</para>
        /// </summary>
        public static int FORM_Redo(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_Redo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FORM_ForceToKillFocus.</para>
        /// <para>Call this member function to force to kill the focus of the form</para>
        /// <para>field which has focus. If it would kill the focus of a form field,</para>
        /// <para>save the value of form field if was changed by theuser.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// </summary>
        public static int FORM_ForceToKillFocus(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __ret = __Internal.FORM_ForceToKillFocus(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Function: FORM_GetFocusedAnnot.</para>
        /// <para>Call this member function to get the currently focused annotation.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page_index  -   Buffer to hold the index number of the page which contains the focused annotation. 0 for the first page. Can't be NULL.</para>
        /// <para>annot       -   Buffer to hold the focused annotation. Can't be NULL.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// <para>Comments: Not currently supported for XFA forms - will report no focused annotation. Must call FPDFPage_CloseAnnot() when the annotation returned in |annot| by this function is no longer needed. This will return true and set |page_index| to -1 and |annot| to NULL, if there is no focused annotation.</para>
        /// </summary>
        public static int FORM_GetFocusedAnnot(global::PDFiumCore.FpdfFormHandleT handle, ref int page_index, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            fixed (int* __page_index1 = &page_index)
            {
                var __arg1 = __page_index1;
                var ____arg2 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
                var __arg2 = new global::System.IntPtr(&____arg2);
                var __ret = __Internal.FORM_GetFocusedAnnot(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Function: FORM_SetFocusedAnnot.</para>
        /// <para>Call this member function to set the currently focused annotation.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>annot       -   Handle to an annotation.</para>
        /// <para>Return Value:</para>
        /// <para>True indicates success; otherwise false.</para>
        /// <para>Comments: |annot| can't be NULL. To kill focus, use FORM_ForceToKillFocus() instead.</para>
        /// </summary>
        public static int FORM_SetFocusedAnnot(global::PDFiumCore.FpdfFormHandleT handle, global::PDFiumCore.FpdfAnnotationT annot)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __arg1 = ReferenceEquals(annot, null) ? global::System.IntPtr.Zero : annot.__Instance;
            var __ret = __Internal.FORM_SetFocusedAnnot(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFPage_HasFormFieldAtPoint</para>
        /// <para>Get the form field type by point.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>page_x      -   X position in PDF &quot;user space&quot;.</para>
        /// <para>page_y      -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>Return Value:</para>
        /// <para>Return the type of the form field; -1 indicates no field.</para>
        /// <para>See field types above.</para>
        /// </summary>
        public static int FPDFPageHasFormFieldAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageHasFormFieldAtPoint(__arg0, __arg1, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFPage_FormFieldZOrderAtPoint</para>
        /// <para>Get the form field z-order by point.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage().</para>
        /// <para>page_x      -   X position in PDF &quot;user space&quot;.</para>
        /// <para>page_y      -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>Return Value:</para>
        /// <para>Return the z-order of the form field; -1 indicates no field.</para>
        /// <para>Higher numbers are closer to the front.</para>
        /// </summary>
        public static int FPDFPageFormFieldZOrderAtPoint(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, double page_x, double page_y)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageFormFieldZOrderAtPoint(__arg0, __arg1, page_x, page_y);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_SetFormFieldHighlightColor</para>
        /// <para>Set the highlight color of the specified (or all) form fields</para>
        /// <para>in the document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>doc         -   Handle to the document, as returned by FPDF_LoadDocument().</para>
        /// <para>fieldType   -   A 32-bit integer indicating the type of a form field (defined above).</para>
        /// <para>color       -   The highlight color of the form field. Constructed by 0xxxrrggbb.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: When the parameter fieldType is set to FPDF_FORMFIELD_UNKNOWN, the highlight color will be applied to all the form fields in the document. Please refresh the client window to show the highlight immediately if necessary.</para>
        /// </summary>
        public static void FPDF_SetFormFieldHighlightColor(global::PDFiumCore.FpdfFormHandleT hHandle, int fieldType, uint color)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_SetFormFieldHighlightColor(__arg0, fieldType, color);
        }

        /// <summary>
        /// <para>Function: FPDF_SetFormFieldHighlightAlpha</para>
        /// <para>Set the transparency of the form field highlight color in the</para>
        /// <para>document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>doc         -   Handle to the document, as returaned by FPDF_LoadDocument().</para>
        /// <para>alpha       -   The transparency of the form field highlight color, between 0-255.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_SetFormFieldHighlightAlpha(global::PDFiumCore.FpdfFormHandleT hHandle, byte alpha)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_SetFormFieldHighlightAlpha(__arg0, alpha);
        }

        /// <summary>
        /// <para>Function: FPDF_RemoveFormFieldHighlight</para>
        /// <para>Remove the form field highlight color in the document.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: Please refresh the client window to remove the highlight immediately if necessary.</para>
        /// </summary>
        public static void FPDF_RemoveFormFieldHighlight(global::PDFiumCore.FpdfFormHandleT hHandle)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            __Internal.FPDF_RemoveFormFieldHighlight(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_FFLDraw</para>
        /// <para>Render FormFields and popup window on a page to a device independent</para>
        /// <para>bitmap.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle      -   Handle to the form fill module, as returned by FPDFDOC_InitFormFillEnvironment().</para>
        /// <para>bitmap       -   Handle to the device independent bitmap (as the output buffer). Bitmap handles can be created by FPDFBitmap_Create().</para>
        /// <para>page         -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>start_x      -   Left pixel position of the display area in the device coordinates.</para>
        /// <para>start_y      -   Top pixel position of the display area in the device coordinates.</para>
        /// <para>size_x       -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y       -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags        -   0 for normal display, or combination of flags defined above.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// <para>Comments: This function is designed to render annotations that are user-interactive, which are widget annotations (for FormFields) and popup annotations. With the FPDF_ANNOT flag, this function will render a popup annotation when users mouse-hover on a non-widget annotation. Regardless of FPDF_ANNOT flag, this function will always render widget annotations for FormFields. In order to implement the FormFill functions, implementation should call this function after rendering functions, such as FPDF_RenderPageBitmap() or FPDF_RenderPageBitmap_Start(), have finished rendering the page contents.</para>
        /// </summary>
        public static void FPDF_FFLDraw(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __arg2 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDF_FFLDraw(__arg0, __arg1, __arg2, start_x, start_y, size_x, size_y, rotate, flags);
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FPDF_GetFormType</para>
        /// <para>Returns the type of form contained in the PDF document.</para>
        /// <para>Parameters:</para>
        /// <para>document - Handle to document.</para>
        /// <para>Return Value:</para>
        /// <para>Integer value representing one of the FORMTYPE_ values.</para>
        /// <para>Comments: If |document| is NULL, then the return value is FORMTYPE_NONE.</para>
        /// </summary>
        public static int FPDF_GetFormType(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetFormType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_SetIndexSelected</para>
        /// <para>Selects/deselects the value at the given |index| of the focused</para>
        /// <para>annotation.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>index       -   0-based index of value to be set as selected/unselected</para>
        /// <para>selected    -   true to select, false to deselect</para>
        /// <para>Return Value:</para>
        /// <para>TRUE if the operation succeeded.</para>
        /// <para>FALSE if the operation failed or widget is not a supported type.</para>
        /// <para>Comments: Intended for use with listbox/combobox widget types. Comboboxes have at most a single value selected at a time which cannot be deselected. Deselect on a combobox is a no-op that returns false. Default implementation is a no-op that will return false for other types. Not currently supported for XFA forms - will return false.</para>
        /// </summary>
        public static int FORM_SetIndexSelected(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int index, int selected)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_SetIndexSelected(__arg0, __arg1, index, selected);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API</para>
        /// <para>Function: FORM_IsIndexSelected</para>
        /// <para>Returns whether or not the value at |index| of the focused</para>
        /// <para>annotation is currently selected.</para>
        /// <para>Parameters:</para>
        /// <para>hHandle     -   Handle to the form fill module. Returned by FPDFDOC_InitFormFillEnvironment.</para>
        /// <para>page        -   Handle to the page. Returned by FPDF_LoadPage</para>
        /// <para>index       -   0-based Index of value to check</para>
        /// <para>Return Value:</para>
        /// <para>TRUE if value at |index| is currently selected.</para>
        /// <para>FALSE if value at |index| is not selected or widget is not a</para>
        /// <para>supported type.</para>
        /// <para>Comments: Intended for use with listbox/combobox widget types. Default implementation is a no-op that will return false for other types. Not currently supported for XFA forms - will return false.</para>
        /// </summary>
        public static int FORM_IsIndexSelected(global::PDFiumCore.FpdfFormHandleT hHandle, global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = ReferenceEquals(hHandle, null) ? global::System.IntPtr.Zero : hHandle.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FORM_IsIndexSelected(__arg0, __arg1, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_LoadXFA</para>
        /// <para>If the document consists of XFA fields, call this method to</para>
        /// <para>attempt to load XFA fields.</para>
        /// <para>Parameters:</para>
        /// <para>document     -   Handle to document from FPDF_LoadDocument().</para>
        /// <para>Return Value:</para>
        /// <para>TRUE upon success, otherwise FALSE. If XFA support is not built</para>
        /// <para>into PDFium, performs no action and always returns FALSE.</para>
        /// </summary>
        public static int FPDF_LoadXFA(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_LoadXFA(__arg0);
            return __ret;
        }
    }

    public unsafe partial class fpdf_attachment
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_GetAttachmentCount")]
            internal static extern int FPDFDocGetAttachmentCount(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_AddAttachment")]
            internal static extern global::System.IntPtr FPDFDocAddAttachment(global::System.IntPtr document, ushort* name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_GetAttachment")]
            internal static extern global::System.IntPtr FPDFDocGetAttachment(global::System.IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_DeleteAttachment")]
            internal static extern int FPDFDocDeleteAttachment(global::System.IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_GetName")]
            internal static extern uint FPDFAttachmentGetName(global::System.IntPtr attachment, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_HasKey")]
            internal static extern int FPDFAttachmentHasKey(global::System.IntPtr attachment, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_GetValueType")]
            internal static extern int FPDFAttachmentGetValueType(global::System.IntPtr attachment, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_SetStringValue")]
            internal static extern int FPDFAttachmentSetStringValue(global::System.IntPtr attachment, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, ushort* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_GetStringValue")]
            internal static extern uint FPDFAttachmentGetStringValue(global::System.IntPtr attachment, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_SetFile")]
            internal static extern int FPDFAttachmentSetFile(global::System.IntPtr attachment, global::System.IntPtr document, global::System.IntPtr contents, uint len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAttachment_GetFile")]
            internal static extern int FPDFAttachmentGetFile(global::System.IntPtr attachment, global::System.IntPtr buffer, uint buflen, uint* out_buflen);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of embedded files in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns the number of embedded files in |document|.</para>
        /// </summary>
        public static int FPDFDocGetAttachmentCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetAttachmentCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add an embedded file with |name| in |document|. If |name| is empty, or if</para>
        /// <para>|name| is the name of a existing embedded file in |document|, or if</para>
        /// <para>|document|'s embedded file name tree is too deep (i.e. |document| has too</para>
        /// <para>many embedded files already), then a new attachment will not be added.</para>
        /// <para>document - handle to a document.</para>
        /// <para>name     - name of the new attachment.</para>
        /// <para>Returns a handle to the new attachment object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAttachmentT FPDFDocAddAttachment(global::PDFiumCore.FpdfDocumentT document, ref ushort name)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            fixed (ushort* __name1 = &name)
            {
                var __arg1 = __name1;
                var __ret = __Internal.FPDFDocAddAttachment(__arg0, __arg1);
                global::PDFiumCore.FpdfAttachmentT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::PDFiumCore.FpdfAttachmentT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::PDFiumCore.FpdfAttachmentT) global::PDFiumCore.FpdfAttachmentT.NativeToManagedMap[__ret];
                else __result0 = global::PDFiumCore.FpdfAttachmentT.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the embedded attachment at |index| in |document|. Note that the returned</para>
        /// <para>attachment handle is only valid while |document| is open.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the requested embedded file.</para>
        /// <para>Returns the handle to the attachment object, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfAttachmentT FPDFDocGetAttachment(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetAttachment(__arg0, index);
            global::PDFiumCore.FpdfAttachmentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfAttachmentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfAttachmentT) global::PDFiumCore.FpdfAttachmentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfAttachmentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Delete the embedded attachment at |index| in |document|. Note that this does</para>
        /// <para>not remove the attachment data from the PDF file; it simply removes the</para>
        /// <para>file's entry in the embedded files name tree so that it does not appear in</para>
        /// <para>the attachment list. This behavior may change in the future.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the embedded file to be deleted.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFDocDeleteAttachment(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocDeleteAttachment(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name of the |attachment| file. |buffer| is only modified if |buflen|</para>
        /// <para>is longer than the length of the file name. On errors, |buffer| is unmodified</para>
        /// <para>and the returned length is 0.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>buffer     - buffer for holding the file name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the file name in bytes.</para>
        /// </summary>
        public static uint FPDFAttachmentGetName(global::PDFiumCore.FpdfAttachmentT attachment, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFAttachmentGetName(__arg0, __arg1, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Check if the params dictionary of |attachment| has |key| as a key.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns true if |key| exists.</para>
        /// </summary>
        public static int FPDFAttachmentHasKey(global::PDFiumCore.FpdfAttachmentT attachment, string key)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            var __ret = __Internal.FPDFAttachmentHasKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value corresponding to |key| in the params dictionary of</para>
        /// <para>the embedded |attachment|.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to look for, encoded in UTF-8.</para>
        /// <para>Returns the type of the dictionary value.</para>
        /// </summary>
        public static int FPDFAttachmentGetValueType(global::PDFiumCore.FpdfAttachmentT attachment, string key)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            var __ret = __Internal.FPDFAttachmentGetValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the string value corresponding to |key| in the params dictionary of the</para>
        /// <para>embedded file |attachment|, overwriting the existing value if any. The value</para>
        /// <para>type should be FPDF_OBJECT_STRING after this function call succeeds.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to the dictionary entry, encoded in UTF-8.</para>
        /// <para>value      - the string value to be set, encoded in UTF-16LE.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAttachmentSetStringValue(global::PDFiumCore.FpdfAttachmentT attachment, string key, ref ushort value)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.FPDFAttachmentSetStringValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the string value corresponding to |key| in the params dictionary of the</para>
        /// <para>embedded file |attachment|. |buffer| is only modified if |buflen| is longer</para>
        /// <para>than the length of the string value. Note that if |key| does not exist in the</para>
        /// <para>dictionary or if |key|'s corresponding value in the dictionary is not a</para>
        /// <para>string (i.e. the value is not of type FPDF_OBJECT_STRING or</para>
        /// <para>FPDF_OBJECT_NAME), then an empty string would be copied to |buffer| and the</para>
        /// <para>return value would be 2. On other errors, nothing would be added to |buffer|</para>
        /// <para>and the return value would be 0.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>key        - the key to the requested string value, encoded in UTF-8.</para>
        /// <para>buffer     - buffer for holding the string value encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the dictionary value string in bytes.</para>
        /// </summary>
        public static uint FPDFAttachmentGetStringValue(global::PDFiumCore.FpdfAttachmentT attachment, string key, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFAttachmentGetStringValue(__arg0, key, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the file data of |attachment|, overwriting the existing file data if any.</para>
        /// <para>The creation date and checksum will be updated, while all other dictionary</para>
        /// <para>entries will be deleted. Note that only contents with |len| smaller than</para>
        /// <para>INT_MAX is supported.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>contents   - buffer holding the file data to write to |attachment|.</para>
        /// <para>len        - length of file data in bytes.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFAttachmentSetFile(global::PDFiumCore.FpdfAttachmentT attachment, global::PDFiumCore.FpdfDocumentT document, global::System.IntPtr contents, uint len)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            var __arg1 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFAttachmentSetFile(__arg0, __arg1, contents, len);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the file data of |attachment|.</para>
        /// <para>When the attachment file data is readable, true is returned, and |out_buflen|</para>
        /// <para>is updated to indicate the file data size. |buffer| is only modified if</para>
        /// <para>|buflen| is non-null and long enough to contain the entire file data. Callers</para>
        /// <para>must check both the return value and the input |buflen| is no less than the</para>
        /// <para>returned |out_buflen| before using the data.</para>
        /// <para>Otherwise, when the attachment file data is unreadable or when |out_buflen|</para>
        /// <para>is null, false is returned and |buffer| and |out_buflen| remain unmodified.</para>
        /// <para>attachment - handle to an attachment.</para>
        /// <para>buffer     - buffer for holding the file data from |attachment|.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>out_buflen - pointer to the variable that will receive the minimum buffer</para>
        /// <para>size to contain the file data of |attachment|.</para>
        /// <para>Returns true on success, false otherwise.</para>
        /// </summary>
        public static int FPDFAttachmentGetFile(global::PDFiumCore.FpdfAttachmentT attachment, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(attachment, null) ? global::System.IntPtr.Zero : attachment.__Instance;
            fixed (uint* __out_buflen3 = &out_buflen)
            {
                var __arg3 = __out_buflen3;
                var __ret = __Internal.FPDFAttachmentGetFile(__arg0, buffer, buflen, __arg3);
                return __ret;
            }
        }
    }

    public unsafe partial class fpdf_catalog
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFCatalog_IsTagged")]
            internal static extern int FPDFCatalogIsTagged(global::System.IntPtr document);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Experimental API.</para>
        /// <para>Determine if |document| represents a tagged PDF.</para>
        /// <para>For the definition of tagged PDF, See (see 10.7 &quot;Tagged PDF&quot; in PDF</para>
        /// <para>Reference 1.7).</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns |true| iff |document| is a tagged PDF.</para>
        /// </summary>
        public static int FPDFCatalogIsTagged(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFCatalogIsTagged(__arg0);
            return __ret;
        }
    }

    public unsafe partial class FX_FILEAVAIL : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr IsDataAvail;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FX_FILEAVAIL@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_FILEAVAIL> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_FILEAVAIL>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FX_FILEAVAIL __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FX_FILEAVAIL(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FX_FILEAVAIL __CreateInstance(global::PDFiumCore.FX_FILEAVAIL.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FX_FILEAVAIL(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FX_FILEAVAIL.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_FILEAVAIL.__Internal));
            *(global::PDFiumCore.FX_FILEAVAIL.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FX_FILEAVAIL(global::PDFiumCore.FX_FILEAVAIL.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FX_FILEAVAIL(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FX_FILEAVAIL()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_FILEAVAIL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FX_FILEAVAIL(global::PDFiumCore.FX_FILEAVAIL _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_FILEAVAIL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FX_FILEAVAIL.__Internal*) __Instance) = *((global::PDFiumCore.FX_FILEAVAIL.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FX_FILEAVAIL __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FX_FILEAVAIL.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FX_FILEAVAIL.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_ulong_ulong IsDataAvail
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FX_FILEAVAIL.__Internal*) __Instance)->IsDataAvail;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_ulong_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_ulong_ulong));
            }

            set
            {
                ((global::PDFiumCore.FX_FILEAVAIL.__Internal*)__Instance)->IsDataAvail = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FX_DOWNLOADHINTS : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr AddSegment;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FX_DOWNLOADHINTS@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_DOWNLOADHINTS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FX_DOWNLOADHINTS>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FX_DOWNLOADHINTS __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FX_DOWNLOADHINTS(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FX_DOWNLOADHINTS __CreateInstance(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FX_DOWNLOADHINTS(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal));
            *(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FX_DOWNLOADHINTS(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FX_DOWNLOADHINTS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FX_DOWNLOADHINTS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FX_DOWNLOADHINTS(global::PDFiumCore.FX_DOWNLOADHINTS _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FX_DOWNLOADHINTS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) __Instance) = *((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FX_DOWNLOADHINTS __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_ulong_ulong AddSegment
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*) __Instance)->AddSegment;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_ulong_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_ulong_ulong));
            }

            set
            {
                ((global::PDFiumCore.FX_DOWNLOADHINTS.__Internal*)__Instance)->AddSegment = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_dataavail
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_Create")]
            internal static extern global::System.IntPtr FPDFAvailCreate(global::System.IntPtr file_avail, global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_Destroy")]
            internal static extern void FPDFAvailDestroy(global::System.IntPtr avail);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_IsDocAvail")]
            internal static extern int FPDFAvailIsDocAvail(global::System.IntPtr avail, global::System.IntPtr hints);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_GetDocument")]
            internal static extern global::System.IntPtr FPDFAvailGetDocument(global::System.IntPtr avail, [MarshalAs(UnmanagedType.LPUTF8Str)] string password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_GetFirstPageNum")]
            internal static extern int FPDFAvailGetFirstPageNum(global::System.IntPtr doc);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_IsPageAvail")]
            internal static extern int FPDFAvailIsPageAvail(global::System.IntPtr avail, int page_index, global::System.IntPtr hints);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_IsFormAvail")]
            internal static extern int FPDFAvailIsFormAvail(global::System.IntPtr avail, global::System.IntPtr hints);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFAvail_IsLinearized")]
            internal static extern int FPDFAvailIsLinearized(global::System.IntPtr avail);
        }

        /// <summary>
        /// <para>Create a document availability provider.</para>
        /// <para>file_avail - pointer to file availability interface.</para>
        /// <para>file       - pointer to a file access interface.</para>
        /// <para>Returns a handle to the document availability provider, or NULL on error.</para>
        /// <para>FPDFAvail_Destroy() must be called when done with the availability provider.</para>
        /// </summary>
        public static global::System.IntPtr FPDFAvailCreate(global::PDFiumCore.FX_FILEAVAIL file_avail, global::PDFiumCore.FPDF_FILEACCESS file)
        {
            var __arg0 = ReferenceEquals(file_avail, null) ? global::System.IntPtr.Zero : file_avail.__Instance;
            var __arg1 = ReferenceEquals(file, null) ? global::System.IntPtr.Zero : file.__Instance;
            var __ret = __Internal.FPDFAvailCreate(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Destroy the |avail| document availability provider.</para>
        /// <para>avail - handle to document availability provider to be destroyed.</para>
        /// </summary>
        public static void FPDFAvailDestroy(global::System.IntPtr avail)
        {
            __Internal.FPDFAvailDestroy(avail);
        }

        /// <summary>
        /// <para>Checks if the document is ready for loading, if not, gets download hints.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>hints - pointer to a download hints interface.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_DATA_ERROR: A common error is returned. Data availability unknown.</para>
        /// <para>PDF_DATA_NOTAVAIL: Data not yet available.</para>
        /// <para>PDF_DATA_AVAIL: Data available.</para>
        /// <para>Applications should call this function whenever new data arrives, and process</para>
        /// <para>all the generated download hints, if any, until the function returns</para>
        /// <para>|PDF_DATA_ERROR| or |PDF_DATA_AVAIL|.</para>
        /// <para>if hints is nullptr, the function just check current document availability.</para>
        /// <para>Once all data is available, call FPDFAvail_GetDocument() to get a document</para>
        /// <para>handle.</para>
        /// </summary>
        public static int FPDFAvailIsDocAvail(global::System.IntPtr avail, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg1 = ReferenceEquals(hints, null) ? global::System.IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsDocAvail(avail, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get document from the availability provider.</para>
        /// <para>avail    - handle to document availability provider.</para>
        /// <para>password - password for decrypting the PDF file. Optional.</para>
        /// <para>Returns a handle to the document.</para>
        /// <para>When FPDFAvail_IsDocAvail() returns TRUE, call FPDFAvail_GetDocument() to</para>
        /// <para>retrieve the document handle.</para>
        /// <para>See the comments for FPDF_LoadDocument() regarding the encoding for</para>
        /// <para>|password|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDFAvailGetDocument(global::System.IntPtr avail, string password)
        {
            var __ret = __Internal.FPDFAvailGetDocument(avail, password);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the page number for the first available page in a linearized PDF.</para>
        /// <para>doc - document handle.</para>
        /// <para>Returns the zero-based index for the first available page.</para>
        /// <para>For most linearized PDFs, the first available page will be the first page,</para>
        /// <para>however, some PDFs might make another page the first available page.</para>
        /// <para>For non-linearized PDFs, this function will always return zero.</para>
        /// </summary>
        public static int FPDFAvailGetFirstPageNum(global::PDFiumCore.FpdfDocumentT doc)
        {
            var __arg0 = ReferenceEquals(doc, null) ? global::System.IntPtr.Zero : doc.__Instance;
            var __ret = __Internal.FPDFAvailGetFirstPageNum(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Check if |page_index| is ready for loading, if not, get the</para>
        /// <para>|FX_DOWNLOADHINTS|.</para>
        /// <para>avail      - handle to document availability provider.</para>
        /// <para>page_index - index number of the page. Zero for the first page.</para>
        /// <para>hints      - pointer to a download hints interface. Populated if</para>
        /// <para>|page_index| is not available.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_DATA_ERROR: A common error is returned. Data availability unknown.</para>
        /// <para>PDF_DATA_NOTAVAIL: Data not yet available.</para>
        /// <para>PDF_DATA_AVAIL: Data available.</para>
        /// <para>This function can be called only after FPDFAvail_GetDocument() is called.</para>
        /// <para>Applications should call this function whenever new data arrives and process</para>
        /// <para>all the generated download |hints|, if any, until this function returns</para>
        /// <para>|PDF_DATA_ERROR| or |PDF_DATA_AVAIL|. Applications can then perform page</para>
        /// <para>loading.</para>
        /// <para>if hints is nullptr, the function just check current availability of</para>
        /// <para>specified page.</para>
        /// </summary>
        public static int FPDFAvailIsPageAvail(global::System.IntPtr avail, int page_index, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg2 = ReferenceEquals(hints, null) ? global::System.IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsPageAvail(avail, page_index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Check if form data is ready for initialization, if not, get the</para>
        /// <para>|FX_DOWNLOADHINTS|.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>hints - pointer to a download hints interface. Populated if form is not</para>
        /// <para>ready for initialization.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_FORM_ERROR: A common eror, in general incorrect parameters.</para>
        /// <para>PDF_FORM_NOTAVAIL: Data not available.</para>
        /// <para>PDF_FORM_AVAIL: Data available.</para>
        /// <para>PDF_FORM_NOTEXIST: No form data.</para>
        /// <para>This function can be called only after FPDFAvail_GetDocument() is called.</para>
        /// <para>The application should call this function whenever new data arrives and</para>
        /// <para>process all the generated download |hints|, if any, until the function</para>
        /// <para>|PDF_FORM_ERROR|, |PDF_FORM_AVAIL| or |PDF_FORM_NOTEXIST|.</para>
        /// <para>if hints is nullptr, the function just check current form availability.</para>
        /// <para>Applications can then perform page loading. It is recommend to call</para>
        /// <para>FPDFDOC_InitFormFillEnvironment() when |PDF_FORM_AVAIL| is returned.</para>
        /// </summary>
        public static int FPDFAvailIsFormAvail(global::System.IntPtr avail, global::PDFiumCore.FX_DOWNLOADHINTS hints)
        {
            var __arg1 = ReferenceEquals(hints, null) ? global::System.IntPtr.Zero : hints.__Instance;
            var __ret = __Internal.FPDFAvailIsFormAvail(avail, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Check whether a document is a linearized PDF.</para>
        /// <para>avail - handle to document availability provider.</para>
        /// <para>Returns one of:</para>
        /// <para>PDF_LINEARIZED</para>
        /// <para>PDF_NOT_LINEARIZED</para>
        /// <para>PDF_LINEARIZATION_UNKNOWN</para>
        /// <para>FPDFAvail_IsLinearized() will return |PDF_LINEARIZED| or |PDF_NOT_LINEARIZED|</para>
        /// <para>when we have 1k  of data. If the files size less than 1k, it returns</para>
        /// <para>|PDF_LINEARIZATION_UNKNOWN| as there is insufficient information to determine</para>
        /// <para>if the PDF is linearlized.</para>
        /// </summary>
        public static int FPDFAvailIsLinearized(global::System.IntPtr avail)
        {
            var __ret = __Internal.FPDFAvailIsLinearized(avail);
            return __ret;
        }
    }

    public unsafe partial class FPDF_IMAGEOBJ_METADATA : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint width;

            [FieldOffset(4)]
            internal uint height;

            [FieldOffset(8)]
            internal float horizontal_dpi;

            [FieldOffset(12)]
            internal float vertical_dpi;

            [FieldOffset(16)]
            internal uint bits_per_pixel;

            [FieldOffset(20)]
            internal int colorspace;

            [FieldOffset(24)]
            internal int marked_content_id;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_IMAGEOBJ_METADATA@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_IMAGEOBJ_METADATA __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_IMAGEOBJ_METADATA(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_IMAGEOBJ_METADATA __CreateInstance(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_IMAGEOBJ_METADATA(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal));
            *(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_IMAGEOBJ_METADATA(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_IMAGEOBJ_METADATA(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_IMAGEOBJ_METADATA()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_IMAGEOBJ_METADATA(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_IMAGEOBJ_METADATA __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->height = value;
            }
        }

        public float HorizontalDpi
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->horizontal_dpi;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->horizontal_dpi = value;
            }
        }

        public float VerticalDpi
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->vertical_dpi;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->vertical_dpi = value;
            }
        }

        public uint BitsPerPixel
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->bits_per_pixel;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->bits_per_pixel = value;
            }
        }

        public int Colorspace
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->colorspace;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->colorspace = value;
            }
        }

        public int MarkedContentId
        {
            get
            {
                return ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*) __Instance)->marked_content_id;
            }

            set
            {
                ((global::PDFiumCore.FPDF_IMAGEOBJ_METADATA.__Internal*)__Instance)->marked_content_id = value;
            }
        }
    }

    public unsafe partial class fpdf_edit
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_CreateNewDocument")]
            internal static extern global::System.IntPtr FPDF_CreateNewDocument();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_New")]
            internal static extern global::System.IntPtr FPDFPageNew(global::System.IntPtr document, int page_index, double width, double height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_Delete")]
            internal static extern void FPDFPageDelete(global::System.IntPtr document, int page_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetRotation")]
            internal static extern int FPDFPageGetRotation(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetRotation")]
            internal static extern void FPDFPageSetRotation(global::System.IntPtr page, int rotate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_InsertObject")]
            internal static extern void FPDFPageInsertObject(global::System.IntPtr page, global::System.IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_RemoveObject")]
            internal static extern int FPDFPageRemoveObject(global::System.IntPtr page, global::System.IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_CountObjects")]
            internal static extern int FPDFPageCountObjects(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetObject")]
            internal static extern global::System.IntPtr FPDFPageGetObject(global::System.IntPtr page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_HasTransparency")]
            internal static extern int FPDFPageHasTransparency(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GenerateContent")]
            internal static extern int FPDFPageGenerateContent(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_Destroy")]
            internal static extern void FPDFPageObjDestroy(global::System.IntPtr page_obj);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_HasTransparency")]
            internal static extern int FPDFPageObjHasTransparency(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetType")]
            internal static extern int FPDFPageObjGetType(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_Transform")]
            internal static extern void FPDFPageObjTransform(global::System.IntPtr page_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_TransformAnnots")]
            internal static extern void FPDFPageTransformAnnots(global::System.IntPtr page, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_NewImageObj")]
            internal static extern global::System.IntPtr FPDFPageObjNewImageObj(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_CountMarks")]
            internal static extern int FPDFPageObjCountMarks(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetMark")]
            internal static extern global::System.IntPtr FPDFPageObjGetMark(global::System.IntPtr page_object, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_AddMark")]
            internal static extern global::System.IntPtr FPDFPageObjAddMark(global::System.IntPtr page_object, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_RemoveMark")]
            internal static extern int FPDFPageObjRemoveMark(global::System.IntPtr page_object, global::System.IntPtr mark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetName")]
            internal static extern int FPDFPageObjMarkGetName(global::System.IntPtr mark, global::System.IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_CountParams")]
            internal static extern int FPDFPageObjMarkCountParams(global::System.IntPtr mark);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetParamKey")]
            internal static extern int FPDFPageObjMarkGetParamKey(global::System.IntPtr mark, uint index, global::System.IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetParamValueType")]
            internal static extern int FPDFPageObjMarkGetParamValueType(global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetParamIntValue")]
            internal static extern int FPDFPageObjMarkGetParamIntValue(global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, int* out_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetParamStringValue")]
            internal static extern int FPDFPageObjMarkGetParamStringValue(global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::System.IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_GetParamBlobValue")]
            internal static extern int FPDFPageObjMarkGetParamBlobValue(global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::System.IntPtr buffer, uint buflen, uint* out_buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_SetIntParam")]
            internal static extern int FPDFPageObjMarkSetIntParam(global::System.IntPtr document, global::System.IntPtr page_object, global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_SetStringParam")]
            internal static extern int FPDFPageObjMarkSetStringParam(global::System.IntPtr document, global::System.IntPtr page_object, global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, [MarshalAs(UnmanagedType.LPUTF8Str)] string value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_SetBlobParam")]
            internal static extern int FPDFPageObjMarkSetBlobParam(global::System.IntPtr document, global::System.IntPtr page_object, global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key, global::System.IntPtr value, uint value_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObjMark_RemoveParam")]
            internal static extern int FPDFPageObjMarkRemoveParam(global::System.IntPtr page_object, global::System.IntPtr mark, [MarshalAs(UnmanagedType.LPUTF8Str)] string key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_LoadJpegFile")]
            internal static extern int FPDFImageObjLoadJpegFile(global::System.IntPtr pages, int count, global::System.IntPtr image_object, global::System.IntPtr file_access);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_LoadJpegFileInline")]
            internal static extern int FPDFImageObjLoadJpegFileInline(global::System.IntPtr pages, int count, global::System.IntPtr image_object, global::System.IntPtr file_access);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetMatrix")]
            internal static extern int FPDFImageObjGetMatrix(global::System.IntPtr image_object, double* a, double* b, double* c, double* d, double* e, double* f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_SetMatrix")]
            internal static extern int FPDFImageObjSetMatrix(global::System.IntPtr image_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_SetBitmap")]
            internal static extern int FPDFImageObjSetBitmap(global::System.IntPtr pages, int count, global::System.IntPtr image_object, global::System.IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetBitmap")]
            internal static extern global::System.IntPtr FPDFImageObjGetBitmap(global::System.IntPtr image_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetRenderedBitmap")]
            internal static extern global::System.IntPtr FPDFImageObjGetRenderedBitmap(global::System.IntPtr document, global::System.IntPtr page, global::System.IntPtr image_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetImageDataDecoded")]
            internal static extern uint FPDFImageObjGetImageDataDecoded(global::System.IntPtr image_object, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetImageDataRaw")]
            internal static extern uint FPDFImageObjGetImageDataRaw(global::System.IntPtr image_object, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetImageFilterCount")]
            internal static extern int FPDFImageObjGetImageFilterCount(global::System.IntPtr image_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetImageFilter")]
            internal static extern uint FPDFImageObjGetImageFilter(global::System.IntPtr image_object, int index, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFImageObj_GetImageMetadata")]
            internal static extern int FPDFImageObjGetImageMetadata(global::System.IntPtr image_object, global::System.IntPtr page, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_CreateNewPath")]
            internal static extern global::System.IntPtr FPDFPageObjCreateNewPath(float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_CreateNewRect")]
            internal static extern global::System.IntPtr FPDFPageObjCreateNewRect(float x, float y, float w, float h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetBounds")]
            internal static extern int FPDFPageObjGetBounds(global::System.IntPtr page_object, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetBlendMode")]
            internal static extern void FPDFPageObjSetBlendMode(global::System.IntPtr page_object, [MarshalAs(UnmanagedType.LPUTF8Str)] string blend_mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetStrokeColor")]
            internal static extern int FPDFPageObjSetStrokeColor(global::System.IntPtr page_object, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetStrokeColor")]
            internal static extern int FPDFPageObjGetStrokeColor(global::System.IntPtr page_object, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetStrokeWidth")]
            internal static extern int FPDFPageObjSetStrokeWidth(global::System.IntPtr page_object, float width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetStrokeWidth")]
            internal static extern int FPDFPageObjGetStrokeWidth(global::System.IntPtr page_object, float* width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetLineJoin")]
            internal static extern int FPDFPageObjGetLineJoin(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetLineJoin")]
            internal static extern int FPDFPageObjSetLineJoin(global::System.IntPtr page_object, int line_join);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetLineCap")]
            internal static extern int FPDFPageObjGetLineCap(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetLineCap")]
            internal static extern int FPDFPageObjSetLineCap(global::System.IntPtr page_object, int line_cap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_SetFillColor")]
            internal static extern int FPDFPageObjSetFillColor(global::System.IntPtr page_object, uint R, uint G, uint B, uint A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetFillColor")]
            internal static extern int FPDFPageObjGetFillColor(global::System.IntPtr page_object, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_CountSegments")]
            internal static extern int FPDFPathCountSegments(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_GetPathSegment")]
            internal static extern global::System.IntPtr FPDFPathGetPathSegment(global::System.IntPtr path, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPathSegment_GetPoint")]
            internal static extern int FPDFPathSegmentGetPoint(global::System.IntPtr segment, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPathSegment_GetType")]
            internal static extern int FPDFPathSegmentGetType(global::System.IntPtr segment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPathSegment_GetClose")]
            internal static extern int FPDFPathSegmentGetClose(global::System.IntPtr segment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_MoveTo")]
            internal static extern int FPDFPathMoveTo(global::System.IntPtr path, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_LineTo")]
            internal static extern int FPDFPathLineTo(global::System.IntPtr path, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_BezierTo")]
            internal static extern int FPDFPathBezierTo(global::System.IntPtr path, float x1, float y1, float x2, float y2, float x3, float y3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_Close")]
            internal static extern int FPDFPathClose(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_SetDrawMode")]
            internal static extern int FPDFPathSetDrawMode(global::System.IntPtr path, int fillmode, int stroke);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_GetDrawMode")]
            internal static extern int FPDFPathGetDrawMode(global::System.IntPtr path, int* fillmode, int* stroke);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_GetMatrix")]
            internal static extern int FPDFPathGetMatrix(global::System.IntPtr path, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPath_SetMatrix")]
            internal static extern int FPDFPathSetMatrix(global::System.IntPtr path, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_NewTextObj")]
            internal static extern global::System.IntPtr FPDFPageObjNewTextObj(global::System.IntPtr document, [MarshalAs(UnmanagedType.LPUTF8Str)] string font, float font_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_SetText")]
            internal static extern int FPDFTextSetText(global::System.IntPtr text_object, ushort* text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_LoadFont")]
            internal static extern global::System.IntPtr FPDFTextLoadFont(global::System.IntPtr document, byte* data, uint size, int font_type, int cid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_LoadStandardFont")]
            internal static extern global::System.IntPtr FPDFTextLoadStandardFont(global::System.IntPtr document, [MarshalAs(UnmanagedType.LPUTF8Str)] string font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_GetMatrix")]
            internal static extern int FPDFTextObjGetMatrix(global::System.IntPtr text, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_GetFontSize")]
            internal static extern float FPDFTextObjGetFontSize(global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFFont_Close")]
            internal static extern void FPDFFontClose(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_CreateTextObj")]
            internal static extern global::System.IntPtr FPDFPageObjCreateTextObj(global::System.IntPtr document, global::System.IntPtr font, float font_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_GetTextRenderMode")]
            internal static extern global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextObjGetTextRenderMode(global::System.IntPtr text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_SetTextRenderMode")]
            internal static extern int FPDFTextObjSetTextRenderMode(global::System.IntPtr text, global::PDFiumCore.FPDF_TEXT_RENDERMODE render_mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_GetFontName")]
            internal static extern uint FPDFTextObjGetFontName(global::System.IntPtr text, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFTextObj_GetText")]
            internal static extern uint FPDFTextObjGetText(global::System.IntPtr text_object, global::System.IntPtr text_page, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFFormObj_CountObjects")]
            internal static extern int FPDFFormObjCountObjects(global::System.IntPtr form_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFFormObj_GetObject")]
            internal static extern global::System.IntPtr FPDFFormObjGetObject(global::System.IntPtr form_object, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFFormObj_GetMatrix")]
            internal static extern int FPDFFormObjGetMatrix(global::System.IntPtr form_object, global::System.IntPtr matrix);
        }

        /// <summary>
        /// <para>Create a new PDF document.</para>
        /// <para>Returns a handle to a new document, or NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_CreateNewDocument()
        {
            var __ret = __Internal.FPDF_CreateNewDocument();
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a new PDF page.</para>
        /// <para>document   - handle to document.</para>
        /// <para>page_index - suggested 0-based index of the page to create. If it is larger</para>
        /// <para>than document's current last index(L), the created page index</para>
        /// <para>is the next available index -- L+1.</para>
        /// <para>width      - the page width in points.</para>
        /// <para>height     - the page height in points.</para>
        /// <para>Returns the handle to the new page or NULL on failure.</para>
        /// <para>The page should be closed with FPDF_ClosePage() when finished as</para>
        /// <para>with any other page in the document.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageT FPDFPageNew(global::PDFiumCore.FpdfDocumentT document, int page_index, double width, double height)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageNew(__arg0, page_index, width, height);
            global::PDFiumCore.FpdfPageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageT) global::PDFiumCore.FpdfPageT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Delete the page at |page_index|.</para>
        /// <para>document   - handle to document.</para>
        /// <para>page_index - the index of the page to delete.</para>
        /// </summary>
        public static void FPDFPageDelete(global::PDFiumCore.FpdfDocumentT document, int page_index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            __Internal.FPDFPageDelete(__arg0, page_index);
        }

        /// <summary>
        /// <para>Get the rotation of |page|.</para>
        /// <para>page - handle to a page</para>
        /// <para>Returns one of the following indicating the page rotation:</para>
        /// <para>0 - No rotation.</para>
        /// <para>1 - Rotated 90 degrees clockwise.</para>
        /// <para>2 - Rotated 180 degrees clockwise.</para>
        /// <para>3 - Rotated 270 degrees clockwise.</para>
        /// </summary>
        public static int FPDFPageGetRotation(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetRotation(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set rotation for |page|.</para>
        /// <para>page   - handle to a page.</para>
        /// <para>rotate - the rotation value, one of:</para>
        /// <para>0 - No rotation.</para>
        /// <para>1 - Rotated 90 degrees clockwise.</para>
        /// <para>2 - Rotated 180 degrees clockwise.</para>
        /// <para>3 - Rotated 270 degrees clockwise.</para>
        /// </summary>
        public static void FPDFPageSetRotation(global::PDFiumCore.FpdfPageT page, int rotate)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetRotation(__arg0, rotate);
        }

        /// <summary>
        /// <para>Insert |page_obj| into |page|.</para>
        /// <para>page     - handle to a page</para>
        /// <para>page_obj - handle to a page object. The |page_obj| will be automatically</para>
        /// <para>freed.</para>
        /// </summary>
        public static void FPDFPageInsertObject(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(page_obj, null) ? global::System.IntPtr.Zero : page_obj.__Instance;
            __Internal.FPDFPageInsertObject(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Remove |page_obj| from |page|.</para>
        /// <para>page     - handle to a page</para>
        /// <para>page_obj - handle to a page object to be removed.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>Ownership is transferred to the caller. Call FPDFPageObj_Destroy() to free</para>
        /// <para>it.</para>
        /// </summary>
        public static int FPDFPageRemoveObject(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(page_obj, null) ? global::System.IntPtr.Zero : page_obj.__Instance;
            var __ret = __Internal.FPDFPageRemoveObject(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Get number of page objects inside |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns the number of objects in |page|.</para>
        /// </summary>
        public static int FPDFPageCountObjects(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageCountObjects(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get object in |page| at |index|.</para>
        /// <para>page  - handle to a page.</para>
        /// <para>index - the index of a page object.</para>
        /// <para>Returns the handle to the page object, or NULL on failed.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageGetObject(global::PDFiumCore.FpdfPageT page, int index)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetObject(__arg0, index);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Checks if |page| contains transparency.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns TRUE if |page| contains transparency.</para>
        /// </summary>
        public static int FPDFPageHasTransparency(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageHasTransparency(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Generate the content of |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>Before you save the page to a file, or reload the page, you must call</para>
        /// <para>|FPDFPage_GenerateContent| or any changes to |page| will be lost.</para>
        /// </summary>
        public static int FPDFPageGenerateContent(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGenerateContent(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Destroy |page_obj| by releasing its resources. |page_obj| must have been</para>
        /// <para>created by FPDFPageObj_CreateNew{Path|Rect}() or</para>
        /// <para>FPDFPageObj_New{Text|Image}Obj(). This function must be called on</para>
        /// <para>newly-created objects if they are not added to a page through</para>
        /// <para>FPDFPage_InsertObject() or to an annotation through FPDFAnnot_AppendObject().</para>
        /// <para>page_obj - handle to a page object.</para>
        /// </summary>
        public static void FPDFPageObjDestroy(global::PDFiumCore.FpdfPageobjectT page_obj)
        {
            var __arg0 = ReferenceEquals(page_obj, null) ? global::System.IntPtr.Zero : page_obj.__Instance;
            __Internal.FPDFPageObjDestroy(__arg0);
        }

        /// <summary>
        /// <para>Checks if |page_object| contains transparency.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns TRUE if |page_object| contains transparency.</para>
        /// </summary>
        public static int FPDFPageObjHasTransparency(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjHasTransparency(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get type of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns one of the FPDF_PAGEOBJ_* values on success, FPDF_PAGEOBJ_UNKNOWN on</para>
        /// <para>error.</para>
        /// </summary>
        public static int FPDFPageObjGetType(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Transform |page_object| by the given matrix.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>a           - matrix value.</para>
        /// <para>b           - matrix value.</para>
        /// <para>c           - matrix value.</para>
        /// <para>d           - matrix value.</para>
        /// <para>e           - matrix value.</para>
        /// <para>f           - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |page_object|.</para>
        /// </summary>
        public static void FPDFPageObjTransform(global::PDFiumCore.FpdfPageobjectT page_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjTransform(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Transform all annotations in |page|.</para>
        /// <para>page - handle to a page.</para>
        /// <para>a    - matrix value.</para>
        /// <para>b    - matrix value.</para>
        /// <para>c    - matrix value.</para>
        /// <para>d    - matrix value.</para>
        /// <para>e    - matrix value.</para>
        /// <para>f    - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |page| annotations.</para>
        /// </summary>
        public static void FPDFPageTransformAnnots(global::PDFiumCore.FpdfPageT page, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageTransformAnnots(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Create a new image object.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns a handle to a new image object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjNewImageObj(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageObjNewImageObj(__arg0);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of content marks in |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns the number of content marks in |page_object|, or -1 in case of</para>
        /// <para>failure.</para>
        /// </summary>
        public static int FPDFPageObjCountMarks(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjCountMarks(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get content mark in |page_object| at |index|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>index       - the index of a page object.</para>
        /// <para>Returns the handle to the content mark, or NULL on failure. The handle is</para>
        /// <para>still owned by the library, and it should not be freed directly. It becomes</para>
        /// <para>invalid if the page object is destroyed, either directly or indirectly by</para>
        /// <para>unloading the page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectmarkT FPDFPageObjGetMark(global::PDFiumCore.FpdfPageobjectT page_object, uint index)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetMark(__arg0, index);
            global::PDFiumCore.FpdfPageobjectmarkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectmarkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectmarkT) global::PDFiumCore.FpdfPageobjectmarkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectmarkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Add a new content mark to a |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>name        - the name (tag) of the mark.</para>
        /// <para>Returns the handle to the content mark, or NULL on failure. The handle is</para>
        /// <para>still owned by the library, and it should not be freed directly. It becomes</para>
        /// <para>invalid if the page object is destroyed, either directly or indirectly by</para>
        /// <para>unloading the page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectmarkT FPDFPageObjAddMark(global::PDFiumCore.FpdfPageobjectT page_object, string name)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjAddMark(__arg0, name);
            global::PDFiumCore.FpdfPageobjectmarkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectmarkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectmarkT) global::PDFiumCore.FpdfPageobjectmarkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectmarkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes a content |mark| from a |page_object|.</para>
        /// <para>The mark handle will be invalid after the removal.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>mark        - handle to a content mark in that object to remove.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE if it failed.</para>
        /// </summary>
        public static int FPDFPageObjRemoveMark(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __arg1 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjRemoveMark(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name of a content mark.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>buffer     - buffer for holding the returned name in UTF-16LE. This is only</para>
        /// <para>modified if |buflen| is longer than the length of the name.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the name. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE if it failed.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetName(global::PDFiumCore.FpdfPageobjectmarkT mark, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen3 = &out_buflen)
            {
                var __arg3 = __out_buflen3;
                var __ret = __Internal.FPDFPageObjMarkGetName(__arg0, buffer, buflen, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of key/value pair parameters in |mark|.</para>
        /// <para>mark   - handle to a content mark.</para>
        /// <para>Returns the number of key/value pair parameters |mark|, or -1 in case of</para>
        /// <para>failure.</para>
        /// </summary>
        public static int FPDFPageObjMarkCountParams(global::PDFiumCore.FpdfPageobjectmarkT mark)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkCountParams(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the key of a property in a content mark.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>index      - index of the property.</para>
        /// <para>buffer     - buffer for holding the returned key in UTF-16LE. This is only</para>
        /// <para>modified if |buflen| is longer than the length of the key.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the key. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the operation was successful, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamKey(global::PDFiumCore.FpdfPageobjectmarkT mark, uint index, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamKey(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the type of the value of a property in a content mark by key.</para>
        /// <para>mark   - handle to a content mark.</para>
        /// <para>key    - string key of the property.</para>
        /// <para>Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of failure.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamValueType(global::PDFiumCore.FpdfPageobjectmarkT mark, string key)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkGetParamValueType(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a number property in a content mark by key as int.</para>
        /// <para>FPDFPageObjMark_GetParamValueType() should have returned FPDF_OBJECT_NUMBER</para>
        /// <para>for this property.</para>
        /// <para>mark      - handle to a content mark.</para>
        /// <para>key       - string key of the property.</para>
        /// <para>out_value - pointer to variable that will receive the value. Not filled if</para>
        /// <para>false is returned.</para>
        /// <para>Returns TRUE if the key maps to a number value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamIntValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, ref int out_value)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            fixed (int* __out_value2 = &out_value)
            {
                var __arg2 = __out_value2;
                var __ret = __Internal.FPDFPageObjMarkGetParamIntValue(__arg0, key, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a string property in a content mark by key.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>key        - string key of the property.</para>
        /// <para>buffer     - buffer for holding the returned value in UTF-16LE. This is</para>
        /// <para>only modified if |buflen| is longer than the length of the</para>
        /// <para>value.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the value. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the key maps to a string/blob value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamStringValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamStringValue(__arg0, key, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the value of a blob property in a content mark by key.</para>
        /// <para>mark       - handle to a content mark.</para>
        /// <para>key        - string key of the property.</para>
        /// <para>buffer     - buffer for holding the returned value. This is only modified</para>
        /// <para>if |buflen| is at least as long as the length of the value.</para>
        /// <para>Optional, pass null to just retrieve the size of the buffer</para>
        /// <para>needed.</para>
        /// <para>buflen     - length of the buffer.</para>
        /// <para>out_buflen - pointer to variable that will receive the minimum buffer size</para>
        /// <para>to contain the value. Not filled if FALSE is returned.</para>
        /// <para>Returns TRUE if the key maps to a string/blob value, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkGetParamBlobValue(global::PDFiumCore.FpdfPageobjectmarkT mark, string key, global::System.IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var __ret = __Internal.FPDFPageObjMarkGetParamBlobValue(__arg0, key, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of an int property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - int value to set.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetIntParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, int value)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __arg2 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetIntParam(__arg0, __arg1, __arg2, key, value);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of a string property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - string value to set.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetStringParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, string value)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __arg2 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetStringParam(__arg0, __arg1, __arg2, key, value);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the value of a blob property in a content mark by key. If a parameter</para>
        /// <para>with key |key| exists, its value is set to |value|. Otherwise, it is added as</para>
        /// <para>a new parameter.</para>
        /// <para>document    - handle to the document.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>value       - pointer to blob value to set.</para>
        /// <para>value_len   - size in bytes of |value|.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkSetBlobParam(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key, global::System.IntPtr value, uint value_len)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __arg2 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkSetBlobParam(__arg0, __arg1, __arg2, key, value, value_len);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Removes a property from a content mark by key.</para>
        /// <para>page_object - handle to the page object with the mark.</para>
        /// <para>mark        - handle to a content mark.</para>
        /// <para>key         - string key of the property.</para>
        /// <para>Returns TRUE if the operation succeeded, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPageObjMarkRemoveParam(global::PDFiumCore.FpdfPageobjectT page_object, global::PDFiumCore.FpdfPageobjectmarkT mark, string key)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __arg1 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __ret = __Internal.FPDFPageObjMarkRemoveParam(__arg0, __arg1, key);
            return __ret;
        }

        /// <summary>
        /// <para>Load an image from a JPEG image file and then set it into |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>file_access  - file access handler which specifies the JPEG image file.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>The image object might already have an associated image, which is shared and</para>
        /// <para>cached by the loaded pages. In that case, we need to clear the cached image</para>
        /// <para>for all the loaded pages. Pass |pages| and page count (|count|) to this API</para>
        /// <para>to clear the image cache. If the image is not previously shared, or NULL is a</para>
        /// <para>valid |pages| value.</para>
        /// </summary>
        public static int FPDFImageObjLoadJpegFile(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FPDF_FILEACCESS file_access)
        {
            var ____arg0 = ReferenceEquals(pages, null) ? global::System.IntPtr.Zero : pages.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg2 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __arg3 = ReferenceEquals(file_access, null) ? global::System.IntPtr.Zero : file_access.__Instance;
            var __ret = __Internal.FPDFImageObjLoadJpegFile(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>Load an image from a JPEG image file and then set it into |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>file_access  - file access handler which specifies the JPEG image file.</para>
        /// <para>Returns TRUE on success.</para>
        /// <para>The image object might already have an associated image, which is shared and</para>
        /// <para>cached by the loaded pages. In that case, we need to clear the cached image</para>
        /// <para>for all the loaded pages. Pass |pages| and page count (|count|) to this API</para>
        /// <para>to clear the image cache. If the image is not previously shared, or NULL is a</para>
        /// <para>valid |pages| value. This function loads the JPEG image inline, so the image</para>
        /// <para>content is copied to the file. This allows |file_access| and its associated</para>
        /// <para>data to be deleted after this function returns.</para>
        /// </summary>
        public static int FPDFImageObjLoadJpegFileInline(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FPDF_FILEACCESS file_access)
        {
            var ____arg0 = ReferenceEquals(pages, null) ? global::System.IntPtr.Zero : pages.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg2 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __arg3 = ReferenceEquals(file_access, null) ? global::System.IntPtr.Zero : file_access.__Instance;
            var __ret = __Internal.FPDFImageObjLoadJpegFileInline(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the transform matrix of an image object.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>a            - matrix value.</para>
        /// <para>b            - matrix value.</para>
        /// <para>c            - matrix value.</para>
        /// <para>d            - matrix value.</para>
        /// <para>e            - matrix value.</para>
        /// <para>f            - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and used to scale, rotate, shear and translate the image.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFImageObjGetMatrix(global::PDFiumCore.FpdfPageobjectT image_object, ref double a, ref double b, ref double c, ref double d, ref double e, ref double f)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            fixed (double* __a1 = &a)
            {
                var __arg1 = __a1;
                fixed (double* __b2 = &b)
                {
                    var __arg2 = __b2;
                    fixed (double* __c3 = &c)
                    {
                        var __arg3 = __c3;
                        fixed (double* __d4 = &d)
                        {
                            var __arg4 = __d4;
                            fixed (double* __e5 = &e)
                            {
                                var __arg5 = __e5;
                                fixed (double* __f6 = &f)
                                {
                                    var __arg6 = __f6;
                                    var __ret = __Internal.FPDFImageObjGetMatrix(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                                    return __ret;
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Set the transform matrix of |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>a            - matrix value.</para>
        /// <para>b            - matrix value.</para>
        /// <para>c            - matrix value.</para>
        /// <para>d            - matrix value.</para>
        /// <para>e            - matrix value.</para>
        /// <para>f            - matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the |image_object|.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFImageObjSetMatrix(global::PDFiumCore.FpdfPageobjectT image_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjSetMatrix(__arg0, a, b, c, d, e, f);
            return __ret;
        }

        /// <summary>
        /// <para>Set |bitmap| to |image_object|.</para>
        /// <para>pages        - pointer to the start of all loaded pages, may be NULL.</para>
        /// <para>count        - number of |pages|, may be 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>bitmap       - handle of the bitmap.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFImageObjSetBitmap(global::PDFiumCore.FpdfPageT pages, int count, global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FpdfBitmapT bitmap)
        {
            var ____arg0 = ReferenceEquals(pages, null) ? global::System.IntPtr.Zero : pages.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg2 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __arg3 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __ret = __Internal.FPDFImageObjSetBitmap(__arg0, count, __arg2, __arg3);
            return __ret;
        }

        /// <summary>
        /// <para>Get a bitmap rasterization of |image_object|. FPDFImageObj_GetBitmap() only</para>
        /// <para>operates on |image_object| and does not take the associated image mask into</para>
        /// <para>account. It also ignores the matrix for |image_object|.</para>
        /// <para>The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()</para>
        /// <para>must be called on the returned bitmap when it is no longer needed.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the bitmap.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFImageObjGetBitmap(global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetBitmap(__arg0);
            global::PDFiumCore.FpdfBitmapT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBitmapT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBitmapT) global::PDFiumCore.FpdfBitmapT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBitmapT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get a bitmap rasterization of |image_object| that takes the image mask and</para>
        /// <para>image matrix into account. To render correctly, the caller must provide the</para>
        /// <para>|document| associated with |image_object|. If there is a |page| associated</para>
        /// <para>with |image_object| the caller should provide that as well.</para>
        /// <para>The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()</para>
        /// <para>must be called on the returned bitmap when it is no longer needed.</para>
        /// <para>document     - handle to a document associated with |image_object|.</para>
        /// <para>page         - handle to an optional page associated with |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the bitmap.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFImageObjGetRenderedBitmap(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg2 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetRenderedBitmap(__arg0, __arg1, __arg2);
            global::PDFiumCore.FpdfBitmapT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBitmapT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBitmapT) global::PDFiumCore.FpdfBitmapT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBitmapT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the decoded image data of |image_object|. The decoded data is the</para>
        /// <para>uncompressed image data, i.e. the raw image data after having all filters</para>
        /// <para>applied. |buffer| is only modified if |buflen| is longer than the length of</para>
        /// <para>the decoded image data.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>buffer       - buffer for holding the decoded image data.</para>
        /// <para>buflen       - length of the buffer in bytes.</para>
        /// <para>Returns the length of the decoded image data.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageDataDecoded(global::PDFiumCore.FpdfPageobjectT image_object, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageDataDecoded(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the raw image data of |image_object|. The raw data is the image data as</para>
        /// <para>stored in the PDF without applying any filters. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the raw image data.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>buffer       - buffer for holding the raw image data.</para>
        /// <para>buflen       - length of the buffer in bytes.</para>
        /// <para>Returns the length of the raw image data.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageDataRaw(global::PDFiumCore.FpdfPageobjectT image_object, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageDataRaw(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the number of filters (i.e. decoders) of the image in |image_object|.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>Returns the number of |image_object|'s filters.</para>
        /// </summary>
        public static int FPDFImageObjGetImageFilterCount(global::PDFiumCore.FpdfPageobjectT image_object)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageFilterCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the filter at |index| of |image_object|'s list of filters. Note that the</para>
        /// <para>filters need to be applied in order, i.e. the first filter should be applied</para>
        /// <para>first, then the second, etc. |buffer| is only modified if |buflen| is longer</para>
        /// <para>than the length of the filter string.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>index        - the index of the filter requested.</para>
        /// <para>buffer       - buffer for holding filter string, encoded in UTF-8.</para>
        /// <para>buflen       - length of the buffer.</para>
        /// <para>Returns the length of the filter string.</para>
        /// </summary>
        public static uint FPDFImageObjGetImageFilter(global::PDFiumCore.FpdfPageobjectT image_object, int index, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageFilter(__arg0, index, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Get the image metadata of |image_object|, including dimension, DPI, bits per</para>
        /// <para>pixel, and colorspace. If the |image_object| is not an image object or if it</para>
        /// <para>does not have an image, then the return value will be false. Otherwise,</para>
        /// <para>failure to retrieve any specific parameter would result in its value being 0.</para>
        /// <para>image_object - handle to an image object.</para>
        /// <para>page         - handle to the page that |image_object| is on. Required for</para>
        /// <para>retrieving the image's bits per pixel and colorspace.</para>
        /// <para>metadata     - receives the image metadata; must not be NULL.</para>
        /// <para>Returns true if successful.</para>
        /// </summary>
        public static int FPDFImageObjGetImageMetadata(global::PDFiumCore.FpdfPageobjectT image_object, global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FPDF_IMAGEOBJ_METADATA metadata)
        {
            var __arg0 = ReferenceEquals(image_object, null) ? global::System.IntPtr.Zero : image_object.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg2 = ReferenceEquals(metadata, null) ? global::System.IntPtr.Zero : metadata.__Instance;
            var __ret = __Internal.FPDFImageObjGetImageMetadata(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Create a new path object at an initial position.</para>
        /// <para>x - initial horizontal position.</para>
        /// <para>y - initial vertical position.</para>
        /// <para>Returns a handle to a new path object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateNewPath(float x, float y)
        {
            var __ret = __Internal.FPDFPageObjCreateNewPath(x, y);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a closed path consisting of a rectangle.</para>
        /// <para>x - horizontal position for the left boundary of the rectangle.</para>
        /// <para>y - vertical position for the bottom boundary of the rectangle.</para>
        /// <para>w - width of the rectangle.</para>
        /// <para>h - height of the rectangle.</para>
        /// <para>Returns a handle to the new path object.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateNewRect(float x, float y, float w, float h)
        {
            var __ret = __Internal.FPDFPageObjCreateNewRect(x, y, w, h);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the bounding box of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>left         - pointer where the left coordinate will be stored</para>
        /// <para>bottom       - pointer where the bottom coordinate will be stored</para>
        /// <para>right        - pointer where the right coordinate will be stored</para>
        /// <para>top          - pointer where the top coordinate will be stored</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetBounds(global::PDFiumCore.FpdfPageobjectT page_object, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageObjGetBounds(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Set the blend mode of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>blend_mode   - string containing the blend mode.</para>
        /// <para>Blend mode can be one of following: Color, ColorBurn, ColorDodge, Darken,</para>
        /// <para>Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal,</para>
        /// <para>Overlay, Saturation, Screen, SoftLight</para>
        /// </summary>
        public static void FPDFPageObjSetBlendMode(global::PDFiumCore.FpdfPageobjectT page_object, string blend_mode)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjSetBlendMode(__arg0, blend_mode);
        }

        /// <summary>
        /// <para>Set the stroke RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component for the object's stroke color.</para>
        /// <para>G            - the green component for the object's stroke color.</para>
        /// <para>B            - the blue component for the object's stroke color.</para>
        /// <para>A            - the stroke alpha for the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetStrokeColor(global::PDFiumCore.FpdfPageobjectT page_object, uint R, uint G, uint B, uint A)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetStrokeColor(__arg0, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Get the stroke RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component of the path stroke color.</para>
        /// <para>G            - the green component of the object's stroke color.</para>
        /// <para>B            - the blue component of the object's stroke color.</para>
        /// <para>A            - the stroke alpha of the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetStrokeColor(global::PDFiumCore.FpdfPageobjectT page_object, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            fixed (uint* __R1 = &R)
            {
                var __arg1 = __R1;
                fixed (uint* __G2 = &G)
                {
                    var __arg2 = __G2;
                    fixed (uint* __B3 = &B)
                    {
                        var __arg3 = __B3;
                        fixed (uint* __A4 = &A)
                        {
                            var __arg4 = __A4;
                            var __ret = __Internal.FPDFPageObjGetStrokeColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Set the stroke width of a page object.</para>
        /// <para>path   - the handle to the page object.</para>
        /// <para>width  - the width of the stroke.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPageObjSetStrokeWidth(global::PDFiumCore.FpdfPageobjectT page_object, float width)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetStrokeWidth(__arg0, width);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the stroke width of a page object.</para>
        /// <para>path   - the handle to the page object.</para>
        /// <para>width  - the width of the stroke.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPageObjGetStrokeWidth(global::PDFiumCore.FpdfPageobjectT page_object, ref float width)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            fixed (float* __width1 = &width)
            {
                var __arg1 = __width1;
                var __ret = __Internal.FPDFPageObjGetStrokeWidth(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the line join of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>Returns the line join, or -1 on failure.</para>
        /// <para>Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,</para>
        /// <para>FPDF_LINEJOIN_BEVEL</para>
        /// </summary>
        public static int FPDFPageObjGetLineJoin(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetLineJoin(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the line join of |page_object|.</para>
        /// <para>page_object  - handle to a page object.</para>
        /// <para>line_join    - line join</para>
        /// <para>Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,</para>
        /// <para>FPDF_LINEJOIN_BEVEL</para>
        /// </summary>
        public static int FPDFPageObjSetLineJoin(global::PDFiumCore.FpdfPageobjectT page_object, int line_join)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetLineJoin(__arg0, line_join);
            return __ret;
        }

        /// <summary>
        /// <para>Get the line cap of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>Returns the line cap, or -1 on failure.</para>
        /// <para>Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,</para>
        /// <para>FPDF_LINECAP_PROJECTING_SQUARE</para>
        /// </summary>
        public static int FPDFPageObjGetLineCap(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetLineCap(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the line cap of |page_object|.</para>
        /// <para>page_object - handle to a page object.</para>
        /// <para>line_cap    - line cap</para>
        /// <para>Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,</para>
        /// <para>FPDF_LINECAP_PROJECTING_SQUARE</para>
        /// </summary>
        public static int FPDFPageObjSetLineCap(global::PDFiumCore.FpdfPageobjectT page_object, int line_cap)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetLineCap(__arg0, line_cap);
            return __ret;
        }

        /// <summary>
        /// <para>Set the fill RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component for the object's fill color.</para>
        /// <para>G            - the green component for the object's fill color.</para>
        /// <para>B            - the blue component for the object's fill color.</para>
        /// <para>A            - the fill alpha for the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjSetFillColor(global::PDFiumCore.FpdfPageobjectT page_object, uint R, uint G, uint B, uint A)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjSetFillColor(__arg0, R, G, B, A);
            return __ret;
        }

        /// <summary>
        /// <para>Get the fill RGBA of a page object. Range of values: 0 - 255.</para>
        /// <para>page_object  - the handle to the page object.</para>
        /// <para>R            - the red component of the object's fill color.</para>
        /// <para>G            - the green component of the object's fill color.</para>
        /// <para>B            - the blue component of the object's fill color.</para>
        /// <para>A            - the fill alpha of the object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPageObjGetFillColor(global::PDFiumCore.FpdfPageobjectT page_object, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            fixed (uint* __R1 = &R)
            {
                var __arg1 = __R1;
                fixed (uint* __G2 = &G)
                {
                    var __arg2 = __G2;
                    fixed (uint* __B3 = &B)
                    {
                        var __arg3 = __B3;
                        fixed (uint* __A4 = &A)
                        {
                            var __arg4 = __A4;
                            var __ret = __Internal.FPDFPageObjGetFillColor(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of segments inside |path|.</para>
        /// <para>path - handle to a path.</para>
        /// <para>A segment is a command, created by e.g. FPDFPath_MoveTo(),</para>
        /// <para>FPDFPath_LineTo() or FPDFPath_BezierTo().</para>
        /// <para>Returns the number of objects in |path| or -1 on failure.</para>
        /// </summary>
        public static int FPDFPathCountSegments(global::PDFiumCore.FpdfPageobjectT path)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathCountSegments(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get segment in |path| at |index|.</para>
        /// <para>path  - handle to a path.</para>
        /// <para>index - the index of a segment.</para>
        /// <para>Returns the handle to the segment, or NULL on faiure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPathsegmentT FPDFPathGetPathSegment(global::PDFiumCore.FpdfPageobjectT path, int index)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathGetPathSegment(__arg0, index);
            global::PDFiumCore.FpdfPathsegmentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPathsegmentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPathsegmentT) global::PDFiumCore.FpdfPathsegmentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPathsegmentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get coordinates of |segment|.</para>
        /// <para>segment  - handle to a segment.</para>
        /// <para>x      - the horizontal position of the segment.</para>
        /// <para>y      - the vertical position of the segment.</para>
        /// <para>Returns TRUE on success, otherwise |x| and |y| is not set.</para>
        /// </summary>
        public static int FPDFPathSegmentGetPoint(global::PDFiumCore.FpdfPathsegmentT segment, ref float x, ref float y)
        {
            var __arg0 = ReferenceEquals(segment, null) ? global::System.IntPtr.Zero : segment.__Instance;
            fixed (float* __x1 = &x)
            {
                var __arg1 = __x1;
                fixed (float* __y2 = &y)
                {
                    var __arg2 = __y2;
                    var __ret = __Internal.FPDFPathSegmentGetPoint(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get type of |segment|.</para>
        /// <para>segment - handle to a segment.</para>
        /// <para>Returns one of the FPDF_SEGMENT_* values on success,</para>
        /// <para>FPDF_SEGMENT_UNKNOWN on error.</para>
        /// </summary>
        public static int FPDFPathSegmentGetType(global::PDFiumCore.FpdfPathsegmentT segment)
        {
            var __arg0 = ReferenceEquals(segment, null) ? global::System.IntPtr.Zero : segment.__Instance;
            var __ret = __Internal.FPDFPathSegmentGetType(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets if the |segment| closes the current subpath of a given path.</para>
        /// <para>segment - handle to a segment.</para>
        /// <para>Returns close flag for non-NULL segment, FALSE otherwise.</para>
        /// </summary>
        public static int FPDFPathSegmentGetClose(global::PDFiumCore.FpdfPathsegmentT segment)
        {
            var __arg0 = ReferenceEquals(segment, null) ? global::System.IntPtr.Zero : segment.__Instance;
            var __ret = __Internal.FPDFPathSegmentGetClose(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Move a path's current point.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x      - the horizontal position of the new current point.</para>
        /// <para>y      - the vertical position of the new current point.</para>
        /// <para>Note that no line will be created between the previous current point and the</para>
        /// <para>new one.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathMoveTo(global::PDFiumCore.FpdfPageobjectT path, float x, float y)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathMoveTo(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Add a line between the current point and a new point in the path.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x      - the horizontal position of the new point.</para>
        /// <para>y      - the vertical position of the new point.</para>
        /// <para>The path's current point is changed to (x, y).</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathLineTo(global::PDFiumCore.FpdfPageobjectT path, float x, float y)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathLineTo(__arg0, x, y);
            return __ret;
        }

        /// <summary>
        /// <para>Add a cubic Bezier curve to the given path, starting at the current point.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>x1     - the horizontal position of the first Bezier control point.</para>
        /// <para>y1     - the vertical position of the first Bezier control point.</para>
        /// <para>x2     - the horizontal position of the second Bezier control point.</para>
        /// <para>y2     - the vertical position of the second Bezier control point.</para>
        /// <para>x3     - the horizontal position of the ending point of the Bezier curve.</para>
        /// <para>y3     - the vertical position of the ending point of the Bezier curve.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathBezierTo(global::PDFiumCore.FpdfPageobjectT path, float x1, float y1, float x2, float y2, float x3, float y3)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathBezierTo(__arg0, x1, y1, x2, y2, x3, y3);
            return __ret;
        }

        /// <summary>
        /// <para>Close the current subpath of a given path.</para>
        /// <para>path   - the handle to the path object.</para>
        /// <para>This will add a line between the current point and the initial point of the</para>
        /// <para>subpath, thus terminating the current subpath.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathClose(global::PDFiumCore.FpdfPageobjectT path)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathClose(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the drawing mode of a path.</para>
        /// <para>path     - the handle to the path object.</para>
        /// <para>fillmode - the filling mode to be set: one of the FPDF_FILLMODE_* flags.</para>
        /// <para>stroke   - a boolean specifying if the path should be stroked or not.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathSetDrawMode(global::PDFiumCore.FpdfPageobjectT path, int fillmode, int stroke)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __ret = __Internal.FPDFPathSetDrawMode(__arg0, fillmode, stroke);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the drawing mode of a path.</para>
        /// <para>path     - the handle to the path object.</para>
        /// <para>fillmode - the filling mode of the path: one of the FPDF_FILLMODE_* flags.</para>
        /// <para>stroke   - a boolean specifying if the path is stroked or not.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFPathGetDrawMode(global::PDFiumCore.FpdfPageobjectT path, ref int fillmode, ref int stroke)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            fixed (int* __fillmode1 = &fillmode)
            {
                var __arg1 = __fillmode1;
                fixed (int* __stroke2 = &stroke)
                {
                    var __arg2 = __stroke2;
                    var __ret = __Internal.FPDFPathGetDrawMode(__arg0, __arg1, __arg2);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the transform matrix of a path.</para>
        /// <para>path   - handle to a path.</para>
        /// <para>matrix - pointer to struct to receive the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and used to scale, rotate, shear and translate the path.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPathGetMatrix(global::PDFiumCore.FpdfPageobjectT path, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFPathGetMatrix(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the transform matrix of a path.</para>
        /// <para>path   - handle to a path.</para>
        /// <para>matrix - pointer to struct with the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and can be used to scale, rotate, shear and translate the path.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFPathSetMatrix(global::PDFiumCore.FpdfPageobjectT path, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
            var __arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFPathSetMatrix(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Create a new text object using one of the standard PDF fonts.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - string containing the font name, without spaces.</para>
        /// <para>font_size  - the font size for the new text object.</para>
        /// <para>Returns a handle to a new text object, or NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjNewTextObj(global::PDFiumCore.FpdfDocumentT document, string font, float font_size)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFPageObjNewTextObj(__arg0, font, font_size);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Set the text for a textobject. If it had text, it will be replaced.</para>
        /// <para>text_object  - handle to the text object.</para>
        /// <para>text         - the UTF-16LE encoded string containing the text to be added.</para>
        /// <para>Returns TRUE on success</para>
        /// </summary>
        public static int FPDFTextSetText(global::PDFiumCore.FpdfPageobjectT text_object, ref ushort text)
        {
            var __arg0 = ReferenceEquals(text_object, null) ? global::System.IntPtr.Zero : text_object.__Instance;
            fixed (ushort* __text1 = &text)
            {
                var __arg1 = __text1;
                var __ret = __Internal.FPDFTextSetText(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a font object loaded from a stream of data. The font is loaded</para>
        /// <para>into the document.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>data       - the stream of data, which will be copied by the font object.</para>
        /// <para>size       - size of the stream, in bytes.</para>
        /// <para>font_type  - FPDF_FONT_TYPE1 or FPDF_FONT_TRUETYPE depending on the font</para>
        /// <para>type.</para>
        /// <para>cid        - a boolean specifying if the font is a CID font or not.</para>
        /// <para>The loaded font can be closed using FPDFFont_Close.</para>
        /// <para>Returns NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFontT FPDFTextLoadFont(global::PDFiumCore.FpdfDocumentT document, byte* data, uint size, int font_type, int cid)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFTextLoadFont(__arg0, data, size, font_type, cid);
            global::PDFiumCore.FpdfFontT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfFontT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfFontT) global::PDFiumCore.FpdfFontT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfFontT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Loads one of the standard 14 fonts per PDF spec 1.7 page 416. The preferred</para>
        /// <para>way of using font style is using a dash to separate the name from the style,</para>
        /// <para>for example 'Helvetica-BoldItalic'.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - string containing the font name, without spaces.</para>
        /// <para>The loaded font can be closed using FPDFFont_Close.</para>
        /// <para>Returns NULL on failure.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfFontT FPDFTextLoadStandardFont(global::PDFiumCore.FpdfDocumentT document, string font)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFTextLoadStandardFont(__arg0, font);
            global::PDFiumCore.FpdfFontT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfFontT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfFontT) global::PDFiumCore.FpdfFontT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfFontT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the transform matrix of a text object.</para>
        /// <para>text   - handle to a text.</para>
        /// <para>matrix - pointer to struct with the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and used to scale, rotate, shear and translate the text.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFTextObjGetMatrix(global::PDFiumCore.FpdfPageobjectT text, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var __arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFTextObjGetMatrix(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the font size of a text object.</para>
        /// <para>text - handle to a text.</para>
        /// <para>Returns the font size of the text object, measured in points (about 1/72</para>
        /// <para>inch) on success; 0 on failure.</para>
        /// </summary>
        public static float FPDFTextObjGetFontSize(global::PDFiumCore.FpdfPageobjectT text)
        {
            var __arg0 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjGetFontSize(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Close a loaded PDF font.</para>
        /// <para>font   - Handle to the loaded font.</para>
        /// </summary>
        public static void FPDFFontClose(global::PDFiumCore.FpdfFontT font)
        {
            var __arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            __Internal.FPDFFontClose(__arg0);
        }

        /// <summary>
        /// <para>Create a new text object using a loaded font.</para>
        /// <para>document   - handle to the document.</para>
        /// <para>font       - handle to the font object.</para>
        /// <para>font_size  - the font size for the new text object.</para>
        /// <para>Returns a handle to a new text object, or NULL on failure</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFPageObjCreateTextObj(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FpdfFontT font, float font_size)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var __ret = __Internal.FPDFPageObjCreateTextObj(__arg0, __arg1, font_size);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the text rendering mode of a text object.</para>
        /// <para>text     - the handle to the text object.</para>
        /// <para>Returns one of the known FPDF_TEXT_RENDERMODE enum values on success,</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN on error.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextObjGetTextRenderMode(global::PDFiumCore.FpdfPageobjectT text)
        {
            var __arg0 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjGetTextRenderMode(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Set the text rendering mode of a text object.</para>
        /// <para>text         - the handle to the text object.</para>
        /// <para>render_mode  - the FPDF_TEXT_RENDERMODE enum value to be set (cannot set to</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN).</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFTextObjSetTextRenderMode(global::PDFiumCore.FpdfPageobjectT text, global::PDFiumCore.FPDF_TEXT_RENDERMODE render_mode)
        {
            var __arg0 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjSetTextRenderMode(__arg0, render_mode);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the font name of a text object.</para>
        /// <para>text             - the handle to the text object.</para>
        /// <para>buffer           - the address of a buffer that receives the font name.</para>
        /// <para>length           - the size, in bytes, of |buffer|.</para>
        /// <para>Returns the number of bytes in the font name (including the trailing NUL</para>
        /// <para>character) on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-8 encoding.</para>
        /// <para>If |length| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFTextObjGetFontName(global::PDFiumCore.FpdfPageobjectT text, global::System.IntPtr buffer, uint length)
        {
            var __arg0 = ReferenceEquals(text, null) ? global::System.IntPtr.Zero : text.__Instance;
            var __ret = __Internal.FPDFTextObjGetFontName(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the text of a text object.</para>
        /// <para>text_object      - the handle to the text object.</para>
        /// <para>text_page        - the handle to the text page.</para>
        /// <para>buffer           - the address of a buffer that receives the text.</para>
        /// <para>length           - the size, in bytes, of |buffer|.</para>
        /// <para>Returns the number of bytes in the text (including the trailing NUL</para>
        /// <para>character) on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding.</para>
        /// <para>If |length| is less than the returned length, or |buffer| is NULL, |buffer|</para>
        /// <para>will not be modified.</para>
        /// </summary>
        public static uint FPDFTextObjGetText(global::PDFiumCore.FpdfPageobjectT text_object, global::PDFiumCore.FpdfTextpageT text_page, global::System.IntPtr buffer, uint length)
        {
            var __arg0 = ReferenceEquals(text_object, null) ? global::System.IntPtr.Zero : text_object.__Instance;
            var __arg1 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextObjGetText(__arg0, __arg1, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of page objects inside |form_object|.</para>
        /// <para>form_object - handle to a form object.</para>
        /// <para>Returns the number of objects in |form_object| on success, -1 on error.</para>
        /// </summary>
        public static int FPDFFormObjCountObjects(global::PDFiumCore.FpdfPageobjectT form_object)
        {
            var __arg0 = ReferenceEquals(form_object, null) ? global::System.IntPtr.Zero : form_object.__Instance;
            var __ret = __Internal.FPDFFormObjCountObjects(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get page object in |form_object| at |index|.</para>
        /// <para>form_object - handle to a form object.</para>
        /// <para>index       - the 0-based index of a page object.</para>
        /// <para>Returns the handle to the page object, or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPageobjectT FPDFFormObjGetObject(global::PDFiumCore.FpdfPageobjectT form_object, uint index)
        {
            var __arg0 = ReferenceEquals(form_object, null) ? global::System.IntPtr.Zero : form_object.__Instance;
            var __ret = __Internal.FPDFFormObjGetObject(__arg0, index);
            global::PDFiumCore.FpdfPageobjectT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPageobjectT) global::PDFiumCore.FpdfPageobjectT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPageobjectT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the transform matrix of a form object.</para>
        /// <para>form_object - handle to a form.</para>
        /// <para>matrix      - pointer to struct to receive the matrix value.</para>
        /// <para>The matrix is composed as:</para>
        /// <para>|a c e|</para>
        /// <para>|b d f|</para>
        /// <para>and used to scale, rotate, shear and translate the form object.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDFFormObjGetMatrix(global::PDFiumCore.FpdfPageobjectT form_object, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = ReferenceEquals(form_object, null) ? global::System.IntPtr.Zero : form_object.__Instance;
            var __arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFFormObjGetMatrix(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class fpdf_flatten
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_Flatten")]
            internal static extern int FPDFPageFlatten(global::System.IntPtr page, int nFlag);
        }

        /// <summary>
        /// <para>Flatten annotations and form fields into the page contents.</para>
        /// <para>page  - handle to the page.</para>
        /// <para>nFlag - One of the |FLAT_*| values denoting the page usage.</para>
        /// <para>Returns one of the |FLATTEN_*| values.</para>
        /// <para>Currently, all failures return |FLATTEN_FAIL| with no indication of the</para>
        /// <para>cause.</para>
        /// </summary>
        public static int FPDFPageFlatten(global::PDFiumCore.FpdfPageT page, int nFlag)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageFlatten(__arg0, nFlag);
            return __ret;
        }
    }

    [Flags]
    public enum FWL_EVENTFLAG
    {
        FWL_EVENTFLAG_ShiftKey = 1,
        FWL_EVENTFLAG_ControlKey = 2,
        FWL_EVENTFLAG_AltKey = 4,
        FWL_EVENTFLAG_MetaKey = 8,
        FWL_EVENTFLAG_KeyPad = 16,
        FWL_EVENTFLAG_AutoRepeat = 32,
        FWL_EVENTFLAG_LeftButtonDown = 64,
        FWL_EVENTFLAG_MiddleButtonDown = 128,
        FWL_EVENTFLAG_RightButtonDown = 256
    }

    public enum FWL_VKEYCODE
    {
        FWL_VKEY_Back = 8,
        FWL_VKEY_Tab = 9,
        FWL_VKEY_NewLine = 10,
        FWL_VKEY_Clear = 12,
        FWL_VKEY_Return = 13,
        FWL_VKEY_Shift = 16,
        FWL_VKEY_Control = 17,
        FWL_VKEY_Menu = 18,
        FWL_VKEY_Pause = 19,
        FWL_VKEY_Capital = 20,
        FWL_VKEY_Kana = 21,
        FWL_VKEY_Hangul = 21,
        FWL_VKEY_Junja = 23,
        FWL_VKEY_Final = 24,
        FWL_VKEY_Hanja = 25,
        FWL_VKEY_Kanji = 25,
        FWL_VKEY_Escape = 27,
        FWL_VKEY_Convert = 28,
        FWL_VKEY_NonConvert = 29,
        FWL_VKEY_Accept = 30,
        FWL_VKEY_ModeChange = 31,
        FWL_VKEY_Space = 32,
        FWL_VKEY_Prior = 33,
        FWL_VKEY_Next = 34,
        FWL_VKEY_End = 35,
        FWL_VKEY_Home = 36,
        FWL_VKEY_Left = 37,
        FWL_VKEY_Up = 38,
        FWL_VKEY_Right = 39,
        FWL_VKEY_Down = 40,
        FWL_VKEY_Select = 41,
        FWL_VKEY_Print = 42,
        FWL_VKEY_Execute = 43,
        FWL_VKEY_Snapshot = 44,
        FWL_VKEY_Insert = 45,
        FWL_VKEY_Delete = 46,
        FWL_VKEY_Help = 47,
        FWL_VKEY_0 = 48,
        FWL_VKEY_1 = 49,
        FWL_VKEY_2 = 50,
        FWL_VKEY_3 = 51,
        FWL_VKEY_4 = 52,
        FWL_VKEY_5 = 53,
        FWL_VKEY_6 = 54,
        FWL_VKEY_7 = 55,
        FWL_VKEY_8 = 56,
        FWL_VKEY_9 = 57,
        FWL_VKEY_A = 65,
        FWL_VKEY_B = 66,
        FWL_VKEY_C = 67,
        FWL_VKEY_D = 68,
        FWL_VKEY_E = 69,
        FWL_VKEY_F = 70,
        FWL_VKEY_G = 71,
        FWL_VKEY_H = 72,
        FWL_VKEY_I = 73,
        FWL_VKEY_J = 74,
        FWL_VKEY_K = 75,
        FWL_VKEY_L = 76,
        FWL_VKEY_M = 77,
        FWL_VKEY_N = 78,
        FWL_VKEY_O = 79,
        FWL_VKEY_P = 80,
        FWL_VKEY_Q = 81,
        FWL_VKEY_R = 82,
        FWL_VKEY_S = 83,
        FWL_VKEY_T = 84,
        FWL_VKEY_U = 85,
        FWL_VKEY_V = 86,
        FWL_VKEY_W = 87,
        FWL_VKEY_X = 88,
        FWL_VKEY_Y = 89,
        FWL_VKEY_Z = 90,
        FWL_VKEY_LWin = 91,
        FWL_VKEY_Command = 91,
        FWL_VKEY_RWin = 92,
        FWL_VKEY_Apps = 93,
        FWL_VKEY_Sleep = 95,
        FWL_VKEY_NumPad0 = 96,
        FWL_VKEY_NumPad1 = 97,
        FWL_VKEY_NumPad2 = 98,
        FWL_VKEY_NumPad3 = 99,
        FWL_VKEY_NumPad4 = 100,
        FWL_VKEY_NumPad5 = 101,
        FWL_VKEY_NumPad6 = 102,
        FWL_VKEY_NumPad7 = 103,
        FWL_VKEY_NumPad8 = 104,
        FWL_VKEY_NumPad9 = 105,
        FWL_VKEY_Multiply = 106,
        FWL_VKEY_Add = 107,
        FWL_VKEY_Separator = 108,
        FWL_VKEY_Subtract = 109,
        FWL_VKEY_Decimal = 110,
        FWL_VKEY_Divide = 111,
        FWL_VKEY_F1 = 112,
        FWL_VKEY_F2 = 113,
        FWL_VKEY_F3 = 114,
        FWL_VKEY_F4 = 115,
        FWL_VKEY_F5 = 116,
        FWL_VKEY_F6 = 117,
        FWL_VKEY_F7 = 118,
        FWL_VKEY_F8 = 119,
        FWL_VKEY_F9 = 120,
        FWL_VKEY_F10 = 121,
        FWL_VKEY_F11 = 122,
        FWL_VKEY_F12 = 123,
        FWL_VKEY_F13 = 124,
        FWL_VKEY_F14 = 125,
        FWL_VKEY_F15 = 126,
        FWL_VKEY_F16 = 127,
        FWL_VKEY_F17 = 128,
        FWL_VKEY_F18 = 129,
        FWL_VKEY_F19 = 130,
        FWL_VKEY_F20 = 131,
        FWL_VKEY_F21 = 132,
        FWL_VKEY_F22 = 133,
        FWL_VKEY_F23 = 134,
        FWL_VKEY_F24 = 135,
        FWL_VKEY_NunLock = 144,
        FWL_VKEY_Scroll = 145,
        FWL_VKEY_LShift = 160,
        FWL_VKEY_RShift = 161,
        FWL_VKEY_LControl = 162,
        FWL_VKEY_RControl = 163,
        FWL_VKEY_LMenu = 164,
        FWL_VKEY_RMenu = 165,
        FWL_VKEY_BROWSER_Back = 166,
        FWL_VKEY_BROWSER_Forward = 167,
        FWL_VKEY_BROWSER_Refresh = 168,
        FWL_VKEY_BROWSER_Stop = 169,
        FWL_VKEY_BROWSER_Search = 170,
        FWL_VKEY_BROWSER_Favorites = 171,
        FWL_VKEY_BROWSER_Home = 172,
        FWL_VKEY_VOLUME_Mute = 173,
        FWL_VKEY_VOLUME_Down = 174,
        FWL_VKEY_VOLUME_Up = 175,
        FWL_VKEY_MEDIA_NEXT_Track = 176,
        FWL_VKEY_MEDIA_PREV_Track = 177,
        FWL_VKEY_MEDIA_Stop = 178,
        FWL_VKEY_MEDIA_PLAY_Pause = 179,
        FWL_VKEY_MEDIA_LAUNCH_Mail = 180,
        FWL_VKEY_MEDIA_LAUNCH_MEDIA_Select = 181,
        FWL_VKEY_MEDIA_LAUNCH_APP1 = 182,
        FWL_VKEY_MEDIA_LAUNCH_APP2 = 183,
        FWL_VKEY_OEM_1 = 186,
        FWL_VKEY_OEM_Plus = 187,
        FWL_VKEY_OEM_Comma = 188,
        FWL_VKEY_OEM_Minus = 189,
        FWL_VKEY_OEM_Period = 190,
        FWL_VKEY_OEM_2 = 191,
        FWL_VKEY_OEM_3 = 192,
        FWL_VKEY_OEM_4 = 219,
        FWL_VKEY_OEM_5 = 220,
        FWL_VKEY_OEM_6 = 221,
        FWL_VKEY_OEM_7 = 222,
        FWL_VKEY_OEM_8 = 223,
        FWL_VKEY_OEM_102 = 226,
        FWL_VKEY_ProcessKey = 229,
        FWL_VKEY_Packet = 231,
        FWL_VKEY_Attn = 246,
        FWL_VKEY_Crsel = 247,
        FWL_VKEY_Exsel = 248,
        FWL_VKEY_Ereof = 249,
        FWL_VKEY_Play = 250,
        FWL_VKEY_Zoom = 251,
        FWL_VKEY_NoName = 252,
        FWL_VKEY_PA1 = 253,
        FWL_VKEY_OEM_Clear = 254,
        FWL_VKEY_Unknown = 0
    }

    public unsafe partial class fpdf_javascript
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_GetJavaScriptActionCount")]
            internal static extern int FPDFDocGetJavaScriptActionCount(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_GetJavaScriptAction")]
            internal static extern global::System.IntPtr FPDFDocGetJavaScriptAction(global::System.IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFDoc_CloseJavaScriptAction")]
            internal static extern void FPDFDocCloseJavaScriptAction(global::System.IntPtr javascript);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFJavaScriptAction_GetName")]
            internal static extern uint FPDFJavaScriptActionGetName(global::System.IntPtr javascript, ushort* buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFJavaScriptAction_GetScript")]
            internal static extern uint FPDFJavaScriptActionGetScript(global::System.IntPtr javascript, ushort* buffer, uint buflen);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the number of JavaScript actions in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>Returns the number of JavaScript actions in |document| or -1 on error.</para>
        /// </summary>
        public static int FPDFDocGetJavaScriptActionCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetJavaScriptActionCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the JavaScript action at |index| in |document|.</para>
        /// <para>document - handle to a document.</para>
        /// <para>index    - the index of the requested JavaScript action.</para>
        /// <para>Returns the handle to the JavaScript action, or NULL on failure.</para>
        /// <para>Caller owns the returned handle and must close it with</para>
        /// <para>FPDFDoc_CloseJavaScriptAction().</para>
        /// </summary>
        public static global::PDFiumCore.FpdfJavascriptActionT FPDFDocGetJavaScriptAction(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDFDocGetJavaScriptAction(__arg0, index);
            global::PDFiumCore.FpdfJavascriptActionT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfJavascriptActionT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfJavascriptActionT) global::PDFiumCore.FpdfJavascriptActionT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfJavascriptActionT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>javascript - Handle to a JavaScript action.</summary>
        public static void FPDFDocCloseJavaScriptAction(global::PDFiumCore.FpdfJavascriptActionT javascript)
        {
            var __arg0 = ReferenceEquals(javascript, null) ? global::System.IntPtr.Zero : javascript.__Instance;
            __Internal.FPDFDocCloseJavaScriptAction(__arg0);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the name from the |javascript| handle. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the name. On errors, |buffer| is</para>
        /// <para>unmodified and the returned length is 0.</para>
        /// <para>javascript - handle to an JavaScript action.</para>
        /// <para>buffer     - buffer for holding the name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the JavaScript action name in bytes.</para>
        /// </summary>
        public static uint FPDFJavaScriptActionGetName(global::PDFiumCore.FpdfJavascriptActionT javascript, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(javascript, null) ? global::System.IntPtr.Zero : javascript.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFJavaScriptActionGetName(__arg0, __arg1, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the script from the |javascript| handle. |buffer| is only modified if</para>
        /// <para>|buflen| is longer than the length of the script. On errors, |buffer| is</para>
        /// <para>unmodified and the returned length is 0.</para>
        /// <para>javascript - handle to an JavaScript action.</para>
        /// <para>buffer     - buffer for holding the name, encoded in UTF-16LE.</para>
        /// <para>buflen     - length of the buffer in bytes.</para>
        /// <para>Returns the length of the JavaScript action name in bytes.</para>
        /// </summary>
        public static uint FPDFJavaScriptActionGetScript(global::PDFiumCore.FpdfJavascriptActionT javascript, ref ushort buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(javascript, null) ? global::System.IntPtr.Zero : javascript.__Instance;
            fixed (ushort* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFJavaScriptActionGetScript(__arg0, __arg1, buflen);
                return __ret;
            }
        }
    }

    public unsafe partial class fpdf_ppo
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_ImportPages")]
            internal static extern int FPDF_ImportPages(global::System.IntPtr dest_doc, global::System.IntPtr src_doc, [MarshalAs(UnmanagedType.LPUTF8Str)] string pagerange, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_ImportNPagesToOne")]
            internal static extern global::System.IntPtr FPDF_ImportNPagesToOne(global::System.IntPtr src_doc, float output_width, float output_height, ulong num_pages_on_x_axis, ulong num_pages_on_y_axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_CopyViewerPreferences")]
            internal static extern int FPDF_CopyViewerPreferences(global::System.IntPtr dest_doc, global::System.IntPtr src_doc);
        }

        /// <summary>
        /// <para>Import pages to a FPDF_DOCUMENT.</para>
        /// <para>dest_doc  - The destination document for the pages.</para>
        /// <para>src_doc   - The document to be imported.</para>
        /// <para>pagerange - A page range string, Such as &quot;1,3,5-7&quot;. If |pagerange| is NULL,</para>
        /// <para>all pages from |src_doc| are imported.</para>
        /// <para>index     - The page index to insert at.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDF_ImportPages(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc, string pagerange, int index)
        {
            var __arg0 = ReferenceEquals(dest_doc, null) ? global::System.IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = ReferenceEquals(src_doc, null) ? global::System.IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_ImportPages(__arg0, __arg1, pagerange, index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Create a new document from |src_doc|.  The pages of |src_doc| will be</para>
        /// <para>combined to provide |num_pages_on_x_axis x num_pages_on_y_axis| pages per</para>
        /// <para>|output_doc| page.</para>
        /// <para>src_doc             - The document to be imported.</para>
        /// <para>output_width        - The output page width in PDF &quot;user space&quot; units.</para>
        /// <para>output_height       - The output page height in PDF &quot;user space&quot; units.</para>
        /// <para>num_pages_on_x_axis - The number of pages on X Axis.</para>
        /// <para>num_pages_on_y_axis - The number of pages on Y Axis.</para>
        /// <para>Return value:</para>
        /// <para>A handle to the created document, or NULL on failure.</para>
        /// <para>Comments:</para>
        /// <para>number of pages per page = num_pages_on_x_axis * num_pages_on_y_axis</para>
        /// </summary>
        public static global::PDFiumCore.FpdfDocumentT FPDF_ImportNPagesToOne(global::PDFiumCore.FpdfDocumentT src_doc, float output_width, float output_height, ulong num_pages_on_x_axis, ulong num_pages_on_y_axis)
        {
            var __arg0 = ReferenceEquals(src_doc, null) ? global::System.IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_ImportNPagesToOne(__arg0, output_width, output_height, num_pages_on_x_axis, num_pages_on_y_axis);
            global::PDFiumCore.FpdfDocumentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfDocumentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfDocumentT) global::PDFiumCore.FpdfDocumentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfDocumentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Copy the viewer preferences from |src_doc| into |dest_doc|.</para>
        /// <para>dest_doc - Document to write the viewer preferences into.</para>
        /// <para>src_doc  - Document to read the viewer preferences from.</para>
        /// <para>Returns TRUE on success.</para>
        /// </summary>
        public static int FPDF_CopyViewerPreferences(global::PDFiumCore.FpdfDocumentT dest_doc, global::PDFiumCore.FpdfDocumentT src_doc)
        {
            var __arg0 = ReferenceEquals(dest_doc, null) ? global::System.IntPtr.Zero : dest_doc.__Instance;
            var __arg1 = ReferenceEquals(src_doc, null) ? global::System.IntPtr.Zero : src_doc.__Instance;
            var __ret = __Internal.FPDF_CopyViewerPreferences(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class IFSDK_PAUSE : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr NeedToPauseNow;

            [FieldOffset(16)]
            internal global::System.IntPtr user;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_IFSDK_PAUSE@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IFSDK_PAUSE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.IFSDK_PAUSE>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.IFSDK_PAUSE __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.IFSDK_PAUSE(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.IFSDK_PAUSE __CreateInstance(global::PDFiumCore.IFSDK_PAUSE.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.IFSDK_PAUSE(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.IFSDK_PAUSE.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IFSDK_PAUSE.__Internal));
            *(global::PDFiumCore.IFSDK_PAUSE.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IFSDK_PAUSE(global::PDFiumCore.IFSDK_PAUSE.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IFSDK_PAUSE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public IFSDK_PAUSE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IFSDK_PAUSE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public IFSDK_PAUSE(global::PDFiumCore.IFSDK_PAUSE _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.IFSDK_PAUSE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.IFSDK_PAUSE.__Internal*) __Instance) = *((global::PDFiumCore.IFSDK_PAUSE.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.IFSDK_PAUSE __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.IFSDK_PAUSE.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.IFSDK_PAUSE.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr NeedToPauseNow
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.IFSDK_PAUSE.__Internal*) __Instance)->NeedToPauseNow;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.IFSDK_PAUSE.__Internal*)__Instance)->NeedToPauseNow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr User
        {
            get
            {
                return ((global::PDFiumCore.IFSDK_PAUSE.__Internal*) __Instance)->user;
            }

            set
            {
                ((global::PDFiumCore.IFSDK_PAUSE.__Internal*)__Instance)->user = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class fpdf_progressive
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPageBitmapWithColorScheme_Start")]
            internal static extern int FPDF_RenderPageBitmapWithColorSchemeStart(global::System.IntPtr bitmap, global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::System.IntPtr color_scheme, global::System.IntPtr pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPageBitmap_Start")]
            internal static extern int FPDF_RenderPageBitmapStart(global::System.IntPtr bitmap, global::System.IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::System.IntPtr pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPage_Continue")]
            internal static extern int FPDF_RenderPageContinue(global::System.IntPtr page, global::System.IntPtr pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_RenderPage_Close")]
            internal static extern void FPDF_RenderPageClose(global::System.IntPtr page);
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmapWithColorScheme_Start</para>
        /// <para>Start to render page contents to a device independent bitmap</para>
        /// <para>progressively with a specified color scheme for the content.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap       -   Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by FPDFBitmap_Create function.</para>
        /// <para>page         -   Handle to the page as returned by FPDF_LoadPage function.</para>
        /// <para>start_x      -   Left pixel position of the display area in the bitmap coordinate.</para>
        /// <para>start_y      -   Top pixel position of the display area in the bitmap coordinate.</para>
        /// <para>size_x       -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y       -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags        -   0 for normal display, or combination of flags defined in fpdfview.h. With FPDF_ANNOT flag, it renders all annotations that does not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>color_scheme -   Color scheme to be used in rendering the |page|. If null, this function will work similar to FPDF_RenderPageBitmap_Start().</para>
        /// <para>pause        -   The IFSDK_PAUSE interface. A callback mechanism allowing the page rendering process.</para>
        /// <para>Return value:</para>
        /// <para>Rendering Status. See flags for progressive process status for the</para>
        /// <para>details.</para>
        /// </summary>
        public static int FPDF_RenderPageBitmapWithColorSchemeStart(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::PDFiumCore.FPDF_COLORSCHEME_ color_scheme, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg8 = ReferenceEquals(color_scheme, null) ? global::System.IntPtr.Zero : color_scheme.__Instance;
            var __arg9 = ReferenceEquals(pause, null) ? global::System.IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageBitmapWithColorSchemeStart(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags, __arg8, __arg9);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPageBitmap_Start</para>
        /// <para>Start to render page contents to a device independent bitmap</para>
        /// <para>progressively.</para>
        /// <para>Parameters:</para>
        /// <para>bitmap      -   Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by FPDFBitmap_Create().</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>start_x     -   Left pixel position of the display area in the bitmap coordinates.</para>
        /// <para>start_y     -   Top pixel position of the display area in the bitmap coordinates.</para>
        /// <para>size_x      -   Horizontal size (in pixels) for displaying the page.</para>
        /// <para>size_y      -   Vertical size (in pixels) for displaying the page.</para>
        /// <para>rotate      -   Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</para>
        /// <para>flags       -   0 for normal display, or combination of flags defined in fpdfview.h. With FPDF_ANNOT flag, it renders all annotations that does not require user-interaction, which are all annotations except widget and popup annotations.</para>
        /// <para>pause       -   The IFSDK_PAUSE interface.A callback mechanism allowing the page rendering process</para>
        /// <para>Return value:</para>
        /// <para>Rendering Status. See flags for progressive process status for the</para>
        /// <para>details.</para>
        /// </summary>
        public static int FPDF_RenderPageBitmapStart(global::PDFiumCore.FpdfBitmapT bitmap, global::PDFiumCore.FpdfPageT page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = ReferenceEquals(bitmap, null) ? global::System.IntPtr.Zero : bitmap.__Instance;
            var __arg1 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg8 = ReferenceEquals(pause, null) ? global::System.IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageBitmapStart(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags, __arg8);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPage_Continue</para>
        /// <para>Continue rendering a PDF page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>pause       -   The IFSDK_PAUSE interface (a callback mechanism allowing the page rendering process to be paused before it's finished). This can be NULL if you don't want to pause.</para>
        /// <para>Return value:</para>
        /// <para>The rendering status. See flags for progressive process status for</para>
        /// <para>the details.</para>
        /// </summary>
        public static int FPDF_RenderPageContinue(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.IFSDK_PAUSE pause)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(pause, null) ? global::System.IntPtr.Zero : pause.__Instance;
            var __ret = __Internal.FPDF_RenderPageContinue(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_RenderPage_Close</para>
        /// <para>Release the resource allocate during page rendering. Need to be</para>
        /// <para>called after finishing rendering or</para>
        /// <para>cancel the rendering.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_RenderPageClose(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDF_RenderPageClose(__arg0);
        }
    }

    public unsafe partial class FPDF_FILEWRITE_ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr WriteBlock;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_FILEWRITE_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEWRITE_> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_FILEWRITE_>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_FILEWRITE_ __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEWRITE_(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_FILEWRITE_ __CreateInstance(global::PDFiumCore.FPDF_FILEWRITE_.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_FILEWRITE_(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_FILEWRITE_.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEWRITE_.__Internal));
            *(global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEWRITE_(global::PDFiumCore.FPDF_FILEWRITE_.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_FILEWRITE_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_FILEWRITE_()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_FILEWRITE_(global::PDFiumCore.FPDF_FILEWRITE_ _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_FILEWRITE_ __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_uint WriteBlock
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*) __Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_FILEWRITE_.__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class fpdf_save
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SaveAsCopy")]
            internal static extern int FPDF_SaveAsCopy(global::System.IntPtr document, global::System.IntPtr pFileWrite, uint flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SaveWithVersion")]
            internal static extern int FPDF_SaveWithVersion(global::System.IntPtr document, global::System.IntPtr pFileWrite, uint flags, int fileVersion);
        }

        /// <summary>
        /// <para>Function: FPDF_SaveAsCopy</para>
        /// <para>Saves the copy of specified document in custom way.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document, as returned by FPDF_LoadDocument() or FPDF_CreateNewDocument().</para>
        /// <para>pFileWrite      -   A pointer to a custom file write structure.</para>
        /// <para>flags           -   The creating flags.</para>
        /// <para>Return value:</para>
        /// <para>TRUE for succeed, FALSE for failed.</para>
        /// </summary>
        public static int FPDF_SaveAsCopy(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEWRITE_ pFileWrite, uint flags)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(pFileWrite, null) ? global::System.IntPtr.Zero : pFileWrite.__Instance;
            var __ret = __Internal.FPDF_SaveAsCopy(__arg0, __arg1, flags);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_SaveWithVersion</para>
        /// <para>Same as FPDF_SaveAsCopy(), except the file version of the</para>
        /// <para>saved document can be specified by the caller.</para>
        /// <para>Parameters:</para>
        /// <para>document        -   Handle to document.</para>
        /// <para>pFileWrite      -   A pointer to a custom file write structure.</para>
        /// <para>flags           -   The creating flags.</para>
        /// <para>fileVersion     -   The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</para>
        /// <para>Return value:</para>
        /// <para>TRUE if succeed, FALSE if failed.</para>
        /// </summary>
        public static int FPDF_SaveWithVersion(global::PDFiumCore.FpdfDocumentT document, global::PDFiumCore.FPDF_FILEWRITE_ pFileWrite, uint flags, int fileVersion)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __arg1 = ReferenceEquals(pFileWrite, null) ? global::System.IntPtr.Zero : pFileWrite.__Instance;
            var __ret = __Internal.FPDF_SaveWithVersion(__arg0, __arg1, flags, fileVersion);
            return __ret;
        }
    }

    public unsafe partial class fpdf_searchex
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetCharIndexFromTextIndex")]
            internal static extern int FPDFTextGetCharIndexFromTextIndex(global::System.IntPtr text_page, int nTextIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetTextIndexFromCharIndex")]
            internal static extern int FPDFTextGetTextIndexFromCharIndex(global::System.IntPtr text_page, int nCharIndex);
        }

        /// <summary>
        /// <para>Get the character index in |text_page| internal character list.</para>
        /// <para>text_page  - a text page information structure.</para>
        /// <para>nTextIndex - index of the text returned from FPDFText_GetText().</para>
        /// <para>Returns the index of the character in internal character list. -1 for error.</para>
        /// </summary>
        public static int FPDFTextGetCharIndexFromTextIndex(global::PDFiumCore.FpdfTextpageT text_page, int nTextIndex)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharIndexFromTextIndex(__arg0, nTextIndex);
            return __ret;
        }

        /// <summary>
        /// <para>Get the text index in |text_page| internal character list.</para>
        /// <para>text_page  - a text page information structure.</para>
        /// <para>nCharIndex - index of the character in internal character list.</para>
        /// <para>Returns the index of the text returned from FPDFText_GetText(). -1 for error.</para>
        /// </summary>
        public static int FPDFTextGetTextIndexFromCharIndex(global::PDFiumCore.FpdfTextpageT text_page, int nCharIndex)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetTextIndexFromCharIndex(__arg0, nCharIndex);
            return __ret;
        }
    }

    public unsafe partial class fpdf_signature
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetSignatureCount")]
            internal static extern int FPDF_GetSignatureCount(global::System.IntPtr document);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetSignatureObject")]
            internal static extern global::System.IntPtr FPDF_GetSignatureObject(global::System.IntPtr document, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetContents")]
            internal static extern uint FPDFSignatureObjGetContents(global::System.IntPtr signature, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetByteRange")]
            internal static extern uint FPDFSignatureObjGetByteRange(global::System.IntPtr signature, int* buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetSubFilter")]
            internal static extern uint FPDFSignatureObjGetSubFilter(global::System.IntPtr signature, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetReason")]
            internal static extern uint FPDFSignatureObjGetReason(global::System.IntPtr signature, global::System.IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetTime")]
            internal static extern uint FPDFSignatureObjGetTime(global::System.IntPtr signature, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFSignatureObj_GetDocMDPPermission")]
            internal static extern uint FPDFSignatureObjGetDocMDPPermission(global::System.IntPtr signature);
        }

        /// <summary>
        /// <para>Function: FPDF_GetSignatureCount</para>
        /// <para>Get total number of signatures in the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>Return value:</para>
        /// <para>Total number of signatures in the document on success, -1 on error.</para>
        /// </summary>
        public static int FPDF_GetSignatureCount(global::PDFiumCore.FpdfDocumentT document)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSignatureCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_GetSignatureObject</para>
        /// <para>Get the Nth signature of the document.</para>
        /// <para>Parameters:</para>
        /// <para>document    -   Handle to document. Returned by FPDF_LoadDocument().</para>
        /// <para>index       -   Index into the array of signatures of the document.</para>
        /// <para>Return value:</para>
        /// <para>Returns the handle to the signature, or NULL on failure. The caller</para>
        /// <para>does not take ownership of the returned FPDF_SIGNATURE. Instead, it</para>
        /// <para>remains valid until FPDF_CloseDocument() is called for the document.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfSignatureT FPDF_GetSignatureObject(global::PDFiumCore.FpdfDocumentT document, int index)
        {
            var __arg0 = ReferenceEquals(document, null) ? global::System.IntPtr.Zero : document.__Instance;
            var __ret = __Internal.FPDF_GetSignatureObject(__arg0, index);
            global::PDFiumCore.FpdfSignatureT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfSignatureT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfSignatureT) global::PDFiumCore.FpdfSignatureT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfSignatureT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetContents</para>
        /// <para>Get the contents of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the contents.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the contents on success, 0 on error.</para>
        /// <para>For public-key signatures, |buffer| is either a DER-encoded PKCS#1 binary or</para>
        /// <para>a DER-encoded PKCS#7 binary. If |length| is less than the returned length, or</para>
        /// <para>|buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetContents(global::PDFiumCore.FpdfSignatureT signature, global::System.IntPtr buffer, uint length)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetContents(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetByteRange</para>
        /// <para>Get the byte range of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the byte range.</para>
        /// <para>length      -   The size, in ints, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of ints in the byte range on</para>
        /// <para>success, 0 on error.</para>
        /// <para>|buffer| is an array of pairs of integers (starting byte offset,</para>
        /// <para>length in bytes) that describes the exact byte range for the digest</para>
        /// <para>calculation. If |length| is less than the returned length, or</para>
        /// <para>|buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetByteRange(global::PDFiumCore.FpdfSignatureT signature, ref int buffer, uint length)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            fixed (int* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var __ret = __Internal.FPDFSignatureObjGetByteRange(__arg0, __arg1, length);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetSubFilter</para>
        /// <para>Get the encoding of the value of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the encoding.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the encoding name (including the</para>
        /// <para>trailing NUL character) on success, 0 on error.</para>
        /// <para>The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetSubFilter(global::PDFiumCore.FpdfSignatureT signature, sbyte* buffer, uint length)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetSubFilter(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetReason</para>
        /// <para>Get the reason (comment) of the signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the reason.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the reason on success, 0 on error.</para>
        /// <para>Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The</para>
        /// <para>string is terminated by a UTF16 NUL character. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetReason(global::PDFiumCore.FpdfSignatureT signature, global::System.IntPtr buffer, uint length)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetReason(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetTime</para>
        /// <para>Get the time of signing of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>buffer      -   The address of a buffer that receives the time.</para>
        /// <para>length      -   The size, in bytes, of |buffer|.</para>
        /// <para>Return value:</para>
        /// <para>Returns the number of bytes in the encoding name (including the</para>
        /// <para>trailing NUL character) on success, 0 on error.</para>
        /// <para>The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the</para>
        /// <para>returned length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// <para>The format of time is expected to be D:YYYYMMDDHHMMSS+XX'YY', i.e. it's</para>
        /// <para>percision is seconds, with timezone information. This value should be used</para>
        /// <para>only when the time of signing is not available in the (PKCS#7 binary)</para>
        /// <para>signature.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetTime(global::PDFiumCore.FpdfSignatureT signature, sbyte* buffer, uint length)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetTime(__arg0, buffer, length);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFSignatureObj_GetDocMDPPermission</para>
        /// <para>Get the DocMDP permission of a signature object.</para>
        /// <para>Parameters:</para>
        /// <para>signature   -   Handle to the signature object. Returned by FPDF_GetSignatureObject().</para>
        /// <para>Return value:</para>
        /// <para>Returns the permission (1, 2 or 3) on success, 0 on error.</para>
        /// </summary>
        public static uint FPDFSignatureObjGetDocMDPPermission(global::PDFiumCore.FpdfSignatureT signature)
        {
            var __arg0 = ReferenceEquals(signature, null) ? global::System.IntPtr.Zero : signature.__Instance;
            var __ret = __Internal.FPDFSignatureObjGetDocMDPPermission(__arg0);
            return __ret;
        }
    }

    public unsafe partial class fpdf_structtree
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructTree_GetForPage")]
            internal static extern global::System.IntPtr FPDF_StructTreeGetForPage(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructTree_Close")]
            internal static extern void FPDF_StructTreeClose(global::System.IntPtr struct_tree);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructTree_CountChildren")]
            internal static extern int FPDF_StructTreeCountChildren(global::System.IntPtr struct_tree);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructTree_GetChildAtIndex")]
            internal static extern global::System.IntPtr FPDF_StructTreeGetChildAtIndex(global::System.IntPtr struct_tree, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetAltText")]
            internal static extern uint FPDF_StructElementGetAltText(global::System.IntPtr struct_element, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetID")]
            internal static extern uint FPDF_StructElementGetID(global::System.IntPtr struct_element, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetLang")]
            internal static extern uint FPDF_StructElementGetLang(global::System.IntPtr struct_element, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetStringAttribute")]
            internal static extern uint FPDF_StructElementGetStringAttribute(global::System.IntPtr struct_element, [MarshalAs(UnmanagedType.LPUTF8Str)] string attr_name, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetMarkedContentID")]
            internal static extern int FPDF_StructElementGetMarkedContentID(global::System.IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetType")]
            internal static extern uint FPDF_StructElementGetType(global::System.IntPtr struct_element, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetTitle")]
            internal static extern uint FPDF_StructElementGetTitle(global::System.IntPtr struct_element, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_CountChildren")]
            internal static extern int FPDF_StructElementCountChildren(global::System.IntPtr struct_element);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_StructElement_GetChildAtIndex")]
            internal static extern global::System.IntPtr FPDF_StructElementGetChildAtIndex(global::System.IntPtr struct_element, int index);
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_GetForPage</para>
        /// <para>Get the structure tree for a page.</para>
        /// <para>Parameters:</para>
        /// <para>page        -   Handle to the page, as returned by FPDF_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>A handle to the structure tree or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructtreeT FPDF_StructTreeGetForPage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDF_StructTreeGetForPage(__arg0);
            global::PDFiumCore.FpdfStructtreeT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfStructtreeT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfStructtreeT) global::PDFiumCore.FpdfStructtreeT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfStructtreeT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_Close</para>
        /// <para>Release a resource allocated by FPDF_StructTree_GetForPage().</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_StructTreeClose(global::PDFiumCore.FpdfStructtreeT struct_tree)
        {
            var __arg0 = ReferenceEquals(struct_tree, null) ? global::System.IntPtr.Zero : struct_tree.__Instance;
            __Internal.FPDF_StructTreeClose(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_CountChildren</para>
        /// <para>Count the number of children for the structure tree.</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>Return value:</para>
        /// <para>The number of children, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructTreeCountChildren(global::PDFiumCore.FpdfStructtreeT struct_tree)
        {
            var __arg0 = ReferenceEquals(struct_tree, null) ? global::System.IntPtr.Zero : struct_tree.__Instance;
            var __ret = __Internal.FPDF_StructTreeCountChildren(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructTree_GetChildAtIndex</para>
        /// <para>Get a child in the structure tree.</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the structure tree, as returned by FPDF_StructTree_LoadPage().</para>
        /// <para>index       -   The index for the child, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The child at the n-th index or NULL on error.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementT FPDF_StructTreeGetChildAtIndex(global::PDFiumCore.FpdfStructtreeT struct_tree, int index)
        {
            var __arg0 = ReferenceEquals(struct_tree, null) ? global::System.IntPtr.Zero : struct_tree.__Instance;
            var __ret = __Internal.FPDF_StructTreeGetChildAtIndex(__arg0, index);
            global::PDFiumCore.FpdfStructelementT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfStructelementT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfStructelementT) global::PDFiumCore.FpdfStructelementT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfStructelementT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetAltText</para>
        /// <para>Get the alt text for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the alt text. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the title, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetAltText(global::PDFiumCore.FpdfStructelementT struct_element, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetAltText(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetID</para>
        /// <para>Get the ID for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the ID string. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the ID string, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetID(global::PDFiumCore.FpdfStructelementT struct_element, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetID(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetLang</para>
        /// <para>Get the case-insensitive IETF BCP 47 language code for an element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>buffer         -   A buffer for output the lang string. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the ID string, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetLang(global::PDFiumCore.FpdfStructelementT struct_element, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetLang(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetStringAttribute</para>
        /// <para>Get a struct element attribute of type &quot;name&quot; or &quot;string&quot;.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>attr_name      -   The name of the attribute to retrieve.</para>
        /// <para>buffer         -   A buffer for output. May be NULL.</para>
        /// <para>buflen         -   The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the attribute value, including the</para>
        /// <para>terminating NUL character. The number of bytes is returned</para>
        /// <para>regardless of the |buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetStringAttribute(global::PDFiumCore.FpdfStructelementT struct_element, string attr_name, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetStringAttribute(__arg0, attr_name, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetMarkedContentID</para>
        /// <para>Get the marked content ID for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The marked content ID of the element. If no ID exists, returns</para>
        /// <para>-1.</para>
        /// </summary>
        public static int FPDF_StructElementGetMarkedContentID(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetMarkedContentID(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetType</para>
        /// <para>Get the type (/S) for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element - Handle to the struct element.</para>
        /// <para>buffer        - A buffer for output. May be NULL.</para>
        /// <para>buflen        - The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the type, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetType(global::PDFiumCore.FpdfStructelementT struct_element, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetType(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetTitle</para>
        /// <para>Get the title (/T) for a given element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element - Handle to the struct element.</para>
        /// <para>buffer         - A buffer for output. May be NULL.</para>
        /// <para>buflen         - The length of the buffer, in bytes. May be 0.</para>
        /// <para>Return value:</para>
        /// <para>The number of bytes in the title, including the terminating NUL</para>
        /// <para>character. The number of bytes is returned regardless of the</para>
        /// <para>|buffer| and |buflen| parameters.</para>
        /// <para>Comments: Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The string is terminated by a UTF16 NUL character. If |buflen| is less than the required length, or |buffer| is NULL, |buffer| will not be modified.</para>
        /// </summary>
        public static uint FPDF_StructElementGetTitle(global::PDFiumCore.FpdfStructelementT struct_element, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetTitle(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_CountChildren</para>
        /// <para>Count the number of children for the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_element -   Handle to the struct element.</para>
        /// <para>Return value:</para>
        /// <para>The number of children, or -1 on error.</para>
        /// </summary>
        public static int FPDF_StructElementCountChildren(global::PDFiumCore.FpdfStructelementT struct_element)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementCountChildren(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDF_StructElement_GetChildAtIndex</para>
        /// <para>Get a child in the structure element.</para>
        /// <para>Parameters:</para>
        /// <para>struct_tree -   Handle to the struct element.</para>
        /// <para>index       -   The index for the child, 0-based.</para>
        /// <para>Return value:</para>
        /// <para>The child at the n-th index or NULL on error.</para>
        /// <para>Comments: If the child exists but is not an element, then this function will return NULL. This will also return NULL for out of bounds indices.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfStructelementT FPDF_StructElementGetChildAtIndex(global::PDFiumCore.FpdfStructelementT struct_element, int index)
        {
            var __arg0 = ReferenceEquals(struct_element, null) ? global::System.IntPtr.Zero : struct_element.__Instance;
            var __ret = __Internal.FPDF_StructElementGetChildAtIndex(__arg0, index);
            global::PDFiumCore.FpdfStructelementT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfStructelementT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfStructelementT) global::PDFiumCore.FpdfStructelementT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfStructelementT.__CreateInstance(__ret);
            return __result0;
        }
    }

    public unsafe partial class FPDF_SYSFONTINFO : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int version;

            [FieldOffset(8)]
            internal global::System.IntPtr Release;

            [FieldOffset(16)]
            internal global::System.IntPtr EnumFonts;

            [FieldOffset(24)]
            internal global::System.IntPtr MapFont;

            [FieldOffset(32)]
            internal global::System.IntPtr GetFont;

            [FieldOffset(40)]
            internal global::System.IntPtr GetFontData;

            [FieldOffset(48)]
            internal global::System.IntPtr GetFaceName;

            [FieldOffset(56)]
            internal global::System.IntPtr GetFontCharset;

            [FieldOffset(64)]
            internal global::System.IntPtr DeleteFont;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0_FPDF_SYSFONTINFO@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSFONTINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_SYSFONTINFO>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_SYSFONTINFO __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_SYSFONTINFO(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_SYSFONTINFO __CreateInstance(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_SYSFONTINFO(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal));
            *(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_SYSFONTINFO(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_SYSFONTINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_SYSFONTINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_SYSFONTINFO(global::PDFiumCore.FPDF_SYSFONTINFO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_SYSFONTINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_SYSFONTINFO __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->version;
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->version = value;
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr Release
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr EnumFonts
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->EnumFonts;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->EnumFonts = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_int_int_int_string_intPtr MapFont
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->MapFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_int_int_int_string_intPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_int_int_int_int_string_intPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->MapFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_string GetFont
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->GetFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_IntPtr_IntPtr_string));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->GetFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_uint_bytePtr_uint GetFontData
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->GetFontData;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_uint_bytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_uint_bytePtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->GetFontData = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_sbytePtr_uint GetFaceName
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->GetFaceName;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_sbytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_uint_IntPtr_IntPtr_sbytePtr_uint));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->GetFaceName = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr GetFontCharset
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->GetFontCharset;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Func_int_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->GetFontCharset = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PDFiumCore.Delegates.Action_IntPtr_IntPtr DeleteFont
        {
            get
            {
                var __ptr0 = ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*) __Instance)->DeleteFont;
                return __ptr0 == IntPtr.Zero? null : (global::PDFiumCore.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PDFiumCore.Delegates.Action_IntPtr_IntPtr));
            }

            set
            {
                ((global::PDFiumCore.FPDF_SYSFONTINFO.__Internal*)__Instance)->DeleteFont = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FPDF_CharsetFontMap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int charset;

            [FieldOffset(8)]
            internal global::System.IntPtr fontname;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FPDF_CharsetFontMap_@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_CharsetFontMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::PDFiumCore.FPDF_CharsetFontMap>();

        protected bool __ownsNativeInstance;

        internal static global::PDFiumCore.FPDF_CharsetFontMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_CharsetFontMap(native.ToPointer(), skipVTables);
        }

        internal static global::PDFiumCore.FPDF_CharsetFontMap __CreateInstance(global::PDFiumCore.FPDF_CharsetFontMap.__Internal native, bool skipVTables = false)
        {
            return new global::PDFiumCore.FPDF_CharsetFontMap(native, skipVTables);
        }

        private static void* __CopyValue(global::PDFiumCore.FPDF_CharsetFontMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_CharsetFontMap.__Internal));
            *(global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_CharsetFontMap(global::PDFiumCore.FPDF_CharsetFontMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FPDF_CharsetFontMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FPDF_CharsetFontMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_CharsetFontMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FPDF_CharsetFontMap(global::PDFiumCore.FPDF_CharsetFontMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::PDFiumCore.FPDF_CharsetFontMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance) = *((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::PDFiumCore.FPDF_CharsetFontMap __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Charset
        {
            get
            {
                return ((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance)->charset;
            }

            set
            {
                ((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*)__Instance)->charset = value;
            }
        }

        public string Fontname
        {
            get
            {
                if (((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance)->fontname == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance)->fontname;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*) __Instance)->fontname, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::PDFiumCore.FPDF_CharsetFontMap.__Internal*)__Instance)->fontname = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class fpdf_sysfontinfo
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetDefaultTTFMap")]
            internal static extern global::System.IntPtr FPDF_GetDefaultTTFMap();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_AddInstalledFont")]
            internal static extern void FPDF_AddInstalledFont(global::System.IntPtr mapper, [MarshalAs(UnmanagedType.LPUTF8Str)] string face, int charset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_SetSystemFontInfo")]
            internal static extern void FPDF_SetSystemFontInfo(global::System.IntPtr pFontInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_GetDefaultSystemFontInfo")]
            internal static extern global::System.IntPtr FPDF_GetDefaultSystemFontInfo();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_FreeDefaultSystemFontInfo")]
            internal static extern void FPDF_FreeDefaultSystemFontInfo(global::System.IntPtr pFontInfo);
        }

        /// <summary>
        /// <para>Function: FPDF_GetDefaultTTFMap</para>
        /// <para>Returns a pointer to the default character set to TT Font name map. The</para>
        /// <para>map is an array of FPDF_CharsetFontMap structs, with its end indicated</para>
        /// <para>by a { -1, NULL } entry.</para>
        /// <para>Parameters:</para>
        /// <para>None.</para>
        /// <para>Return Value:</para>
        /// <para>Pointer to the Charset Font Map.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_CharsetFontMap FPDF_GetDefaultTTFMap()
        {
            var __ret = __Internal.FPDF_GetDefaultTTFMap();
            global::PDFiumCore.FPDF_CharsetFontMap __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FPDF_CharsetFontMap.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FPDF_CharsetFontMap) global::PDFiumCore.FPDF_CharsetFontMap.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FPDF_CharsetFontMap.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_AddInstalledFont</para>
        /// <para>Add a system font to the list in PDFium.</para>
        /// <para>Comments: This function is only called during the system font list building process.</para>
        /// <para>Parameters:</para>
        /// <para>mapper          -   Opaque pointer to Foxit font mapper</para>
        /// <para>face            -   The font face name</para>
        /// <para>charset         -   Font character set. See above defined constants.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDF_AddInstalledFont(global::System.IntPtr mapper, string face, int charset)
        {
            __Internal.FPDF_AddInstalledFont(mapper, face, charset);
        }

        /// <summary>
        /// <para>Function: FPDF_SetSystemFontInfo</para>
        /// <para>Set the system font info interface into PDFium</para>
        /// <para>Parameters:</para>
        /// <para>pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure</para>
        /// <para>Return Value:</para>
        /// <para>None</para>
        /// <para>Comments: Platform support implementation should implement required methods of FFDF_SYSFONTINFO interface, then call this function during PDFium initialization process.</para>
        /// </summary>
        public static void FPDF_SetSystemFontInfo(global::PDFiumCore.FPDF_SYSFONTINFO pFontInfo)
        {
            var __arg0 = ReferenceEquals(pFontInfo, null) ? global::System.IntPtr.Zero : pFontInfo.__Instance;
            __Internal.FPDF_SetSystemFontInfo(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDF_GetDefaultSystemFontInfo</para>
        /// <para>Get default system font info interface for current platform</para>
        /// <para>Parameters:</para>
        /// <para>None</para>
        /// <para>Return Value:</para>
        /// <para>Pointer to a FPDF_SYSFONTINFO structure describing the default</para>
        /// <para>interface, or NULL if the platform doesn't have a default interface.</para>
        /// <para>Application should call FPDF_FreeDefaultSystemFontInfo to free the</para>
        /// <para>returned pointer.</para>
        /// <para>Comments: For some platforms, PDFium implements a default version of system font info interface. The default implementation can be passed to FPDF_SetSystemFontInfo().</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_SYSFONTINFO FPDF_GetDefaultSystemFontInfo()
        {
            var __ret = __Internal.FPDF_GetDefaultSystemFontInfo();
            global::PDFiumCore.FPDF_SYSFONTINFO __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FPDF_SYSFONTINFO.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FPDF_SYSFONTINFO) global::PDFiumCore.FPDF_SYSFONTINFO.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FPDF_SYSFONTINFO.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDF_FreeDefaultSystemFontInfo</para>
        /// <para>Free a default system font info interface</para>
        /// <para>Parameters:</para>
        /// <para>pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure</para>
        /// <para>Return Value:</para>
        /// <para>None</para>
        /// <para>Comments: This function should be called on the output from FPDF_SetSystemFontInfo() once it is no longer needed.</para>
        /// </summary>
        public static void FPDF_FreeDefaultSystemFontInfo(global::PDFiumCore.FPDF_SYSFONTINFO pFontInfo)
        {
            var __arg0 = ReferenceEquals(pFontInfo, null) ? global::System.IntPtr.Zero : pFontInfo.__Instance;
            __Internal.FPDF_FreeDefaultSystemFontInfo(__arg0);
        }
    }

    public unsafe partial class fpdf_text
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_LoadPage")]
            internal static extern global::System.IntPtr FPDFTextLoadPage(global::System.IntPtr page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_ClosePage")]
            internal static extern void FPDFTextClosePage(global::System.IntPtr text_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_CountChars")]
            internal static extern int FPDFTextCountChars(global::System.IntPtr text_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetUnicode")]
            internal static extern uint FPDFTextGetUnicode(global::System.IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetFontSize")]
            internal static extern double FPDFTextGetFontSize(global::System.IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetFontInfo")]
            internal static extern uint FPDFTextGetFontInfo(global::System.IntPtr text_page, int index, global::System.IntPtr buffer, uint buflen, int* flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetFontWeight")]
            internal static extern int FPDFTextGetFontWeight(global::System.IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetTextRenderMode")]
            internal static extern global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextGetTextRenderMode(global::System.IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetFillColor")]
            internal static extern int FPDFTextGetFillColor(global::System.IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetStrokeColor")]
            internal static extern int FPDFTextGetStrokeColor(global::System.IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetCharAngle")]
            internal static extern float FPDFTextGetCharAngle(global::System.IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetCharBox")]
            internal static extern int FPDFTextGetCharBox(global::System.IntPtr text_page, int index, double* left, double* right, double* bottom, double* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetLooseCharBox")]
            internal static extern int FPDFTextGetLooseCharBox(global::System.IntPtr text_page, int index, global::System.IntPtr rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetMatrix")]
            internal static extern int FPDFTextGetMatrix(global::System.IntPtr text_page, int index, global::System.IntPtr matrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetCharOrigin")]
            internal static extern int FPDFTextGetCharOrigin(global::System.IntPtr text_page, int index, double* x, double* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetCharIndexAtPos")]
            internal static extern int FPDFTextGetCharIndexAtPos(global::System.IntPtr text_page, double x, double y, double xTolerance, double yTolerance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetText")]
            internal static extern int FPDFTextGetText(global::System.IntPtr text_page, int start_index, int count, ushort* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_CountRects")]
            internal static extern int FPDFTextCountRects(global::System.IntPtr text_page, int start_index, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetRect")]
            internal static extern int FPDFTextGetRect(global::System.IntPtr text_page, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetBoundedText")]
            internal static extern int FPDFTextGetBoundedText(global::System.IntPtr text_page, double left, double top, double right, double bottom, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_FindStart")]
            internal static extern global::System.IntPtr FPDFTextFindStart(global::System.IntPtr text_page, ushort* findwhat, uint flags, int start_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_FindNext")]
            internal static extern int FPDFTextFindNext(global::System.IntPtr handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_FindPrev")]
            internal static extern int FPDFTextFindPrev(global::System.IntPtr handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetSchResultIndex")]
            internal static extern int FPDFTextGetSchResultIndex(global::System.IntPtr handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_GetSchCount")]
            internal static extern int FPDFTextGetSchCount(global::System.IntPtr handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFText_FindClose")]
            internal static extern void FPDFTextFindClose(global::System.IntPtr handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_LoadWebLinks")]
            internal static extern global::System.IntPtr FPDFLinkLoadWebLinks(global::System.IntPtr text_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_CountWebLinks")]
            internal static extern int FPDFLinkCountWebLinks(global::System.IntPtr link_page);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetURL")]
            internal static extern int FPDFLinkGetURL(global::System.IntPtr link_page, int link_index, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_CountRects")]
            internal static extern int FPDFLinkCountRects(global::System.IntPtr link_page, int link_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetRect")]
            internal static extern int FPDFLinkGetRect(global::System.IntPtr link_page, int link_index, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_GetTextRange")]
            internal static extern int FPDFLinkGetTextRange(global::System.IntPtr link_page, int link_index, int* start_char_index, int* char_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFLink_CloseWebLinks")]
            internal static extern void FPDFLinkCloseWebLinks(global::System.IntPtr link_page);
        }

        /// <summary>
        /// <para>Function: FPDFText_LoadPage</para>
        /// <para>Prepare information about all characters in a page.</para>
        /// <para>Parameters:</para>
        /// <para>page    -   Handle to the page. Returned by FPDF_LoadPage function (in FPDFVIEW module).</para>
        /// <para>Return value:</para>
        /// <para>A handle to the text page information structure.</para>
        /// <para>NULL if something goes wrong.</para>
        /// <para>Comments: Application must call FPDFText_ClosePage to release the text page information.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfTextpageT FPDFTextLoadPage(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFTextLoadPage(__arg0);
            global::PDFiumCore.FpdfTextpageT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfTextpageT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfTextpageT) global::PDFiumCore.FpdfTextpageT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfTextpageT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFText_ClosePage</para>
        /// <para>Release all resources allocated for a text page information</para>
        /// <para>structure.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFTextClosePage(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            __Internal.FPDFTextClosePage(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDFText_CountChars</para>
        /// <para>Get number of characters in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return value:</para>
        /// <para>Number of characters in the page. Return -1 for error.</para>
        /// <para>Generated characters, like additional space characters, new line</para>
        /// <para>characters, are also counted.</para>
        /// <para>Comments: Characters in a page form a &quot;stream&quot;, inside the stream, each character has an index. We will use the index parameters in many of FPDFTEXT functions. The first character in the page has an index value of zero.</para>
        /// </summary>
        public static int FPDFTextCountChars(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextCountChars(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetUnicode</para>
        /// <para>Get Unicode of a character in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>The Unicode of the particular character.</para>
        /// <para>If a character is not encoded in Unicode and Foxit engine can't</para>
        /// <para>convert to Unicode,</para>
        /// <para>the return value will be zero.</para>
        /// </summary>
        public static uint FPDFTextGetUnicode(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetUnicode(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontSize</para>
        /// <para>Get the font size of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>The font size of the particular character, measured in points (about</para>
        /// <para>1/72 inch). This is the typographic size of the font (so called</para>
        /// <para>&quot;em size&quot;).</para>
        /// </summary>
        public static double FPDFTextGetFontSize(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetFontSize(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontInfo</para>
        /// <para>Get the font name and flags of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page - Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index     - Zero-based index of the character.</para>
        /// <para>buffer    - A buffer receiving the font name.</para>
        /// <para>buflen    - The length of |buffer| in bytes.</para>
        /// <para>flags     - Optional pointer to an int receiving the font flags. These flags should be interpreted per PDF spec 1.7 Section 5.7.1 Font Descriptor Flags.</para>
        /// <para>Return value:</para>
        /// <para>On success, return the length of the font name, including the</para>
        /// <para>trailing NUL character, in bytes. If this length is less than or</para>
        /// <para>equal to |length|, |buffer| is set to the font name, |flags| is</para>
        /// <para>set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on</para>
        /// <para>failure.</para>
        /// </summary>
        public static uint FPDFTextGetFontInfo(global::PDFiumCore.FpdfTextpageT text_page, int index, global::System.IntPtr buffer, uint buflen, ref int flags)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (int* __flags4 = &flags)
            {
                var __arg4 = __flags4;
                var __ret = __Internal.FPDFTextGetFontInfo(__arg0, index, buffer, buflen, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFontWeight</para>
        /// <para>Get the font weight of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return value:</para>
        /// <para>On success, return the font weight of the particular character. If</para>
        /// <para>|text_page| is invalid, if |index| is out of bounds, or if the</para>
        /// <para>character's text object is undefined, return -1.</para>
        /// </summary>
        public static int FPDFTextGetFontWeight(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetFontWeight(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetTextRenderMode</para>
        /// <para>Get text rendering mode of character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return the render mode value. A valid value is of type</para>
        /// <para>FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out</para>
        /// <para>of bounds, or if the text object is undefined, then return</para>
        /// <para>FPDF_TEXTRENDERMODE_UNKNOWN.</para>
        /// </summary>
        public static global::PDFiumCore.FPDF_TEXT_RENDERMODE FPDFTextGetTextRenderMode(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetTextRenderMode(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetFillColor</para>
        /// <para>Get the fill color of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page      -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index          -   Zero-based index of the character.</para>
        /// <para>R              -   Pointer to an unsigned int number receiving the red value of the fill color.</para>
        /// <para>G              -   Pointer to an unsigned int number receiving the green value of the fill color.</para>
        /// <para>B              -   Pointer to an unsigned int number receiving the blue value of the fill color.</para>
        /// <para>A              -   Pointer to an unsigned int number receiving the alpha value of the fill color.</para>
        /// <para>Return value:</para>
        /// <para>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are</para>
        /// <para>unchanged.</para>
        /// </summary>
        public static int FPDFTextGetFillColor(global::PDFiumCore.FpdfTextpageT text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFTextGetFillColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetStrokeColor</para>
        /// <para>Get the stroke color of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page      -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index          -   Zero-based index of the character.</para>
        /// <para>R              -   Pointer to an unsigned int number receiving the red value of the stroke color.</para>
        /// <para>G              -   Pointer to an unsigned int number receiving the green value of the stroke color.</para>
        /// <para>B              -   Pointer to an unsigned int number receiving the blue value of the stroke color.</para>
        /// <para>A              -   Pointer to an unsigned int number receiving the alpha value of the stroke color.</para>
        /// <para>Return value:</para>
        /// <para>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are</para>
        /// <para>unchanged.</para>
        /// </summary>
        public static int FPDFTextGetStrokeColor(global::PDFiumCore.FpdfTextpageT text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var __ret = __Internal.FPDFTextGetStrokeColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharAngle</para>
        /// <para>Get character rotation angle.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return the angle value in radian. Value will always be</para>
        /// <para>greater or equal to 0. If |text_page| is invalid, or if |index| is</para>
        /// <para>out of bounds, then return -1.</para>
        /// </summary>
        public static float FPDFTextGetCharAngle(global::PDFiumCore.FpdfTextpageT text_page, int index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharAngle(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharBox</para>
        /// <para>Get bounding box of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>left        -   Pointer to a double number receiving left position of the character box.</para>
        /// <para>right       -   Pointer to a double number receiving right position of the character box.</para>
        /// <para>bottom      -   Pointer to a double number receiving bottom position of the character box.</para>
        /// <para>top         -   Pointer to a double number receiving top position of the character box.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |right|, |bottom|, and</para>
        /// <para>|top|. If |text_page| is invalid, or if |index| is out of bounds,</para>
        /// <para>then return FALSE, and the out parameters remain unmodified.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetCharBox(global::PDFiumCore.FpdfTextpageT text_page, int index, ref double left, ref double right, ref double bottom, ref double top)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __right3 = &right)
                {
                    var __arg3 = __right3;
                    fixed (double* __bottom4 = &bottom)
                    {
                        var __arg4 = __bottom4;
                        fixed (double* __top5 = &top)
                        {
                            var __arg5 = __top5;
                            var __ret = __Internal.FPDFTextGetCharBox(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetLooseCharBox</para>
        /// <para>Get a &quot;loose&quot; bounding box of a particular character, i.e., covering</para>
        /// <para>the entire glyph bounds, without taking the actual glyph shape into</para>
        /// <para>account.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>rect        -   Pointer to a FS_RECTF receiving the character box.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |rect|. If |text_page| is</para>
        /// <para>invalid, or if |index| is out of bounds, then return FALSE, and the</para>
        /// <para>|rect| out parameter remains unmodified.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetLooseCharBox(global::PDFiumCore.FpdfTextpageT text_page, int index, global::PDFiumCore.FS_RECTF_ rect)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __arg2 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __ret = __Internal.FPDFTextGetLooseCharBox(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetMatrix</para>
        /// <para>Get the effective transformation matrix for a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage().</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>matrix      -   Pointer to a FS_MATRIX receiving the transformation matrix.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |matrix|. If |text_page| is</para>
        /// <para>invalid, or if |index| is out of bounds, or if |matrix| is NULL,</para>
        /// <para>then return FALSE, and |matrix| remains unmodified.</para>
        /// </summary>
        public static int FPDFTextGetMatrix(global::PDFiumCore.FpdfTextpageT text_page, int index, global::PDFiumCore.FS_MATRIX_ matrix)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __arg2 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __ret = __Internal.FPDFTextGetMatrix(__arg0, index, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharOrigin</para>
        /// <para>Get origin of a particular character.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>index       -   Zero-based index of the character.</para>
        /// <para>x           -   Pointer to a double number receiving x coordinate of the character origin.</para>
        /// <para>y           -   Pointer to a double number receiving y coordinate of the character origin.</para>
        /// <para>Return Value:</para>
        /// <para>Whether the call succeeded. If false, x and y are unchanged.</para>
        /// <para>Comments: All positions are measured in PDF &quot;user space&quot;.</para>
        /// </summary>
        public static int FPDFTextGetCharOrigin(global::PDFiumCore.FpdfTextpageT text_page, int index, ref double x, ref double y)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (double* __x2 = &x)
            {
                var __arg2 = __x2;
                fixed (double* __y3 = &y)
                {
                    var __arg3 = __y3;
                    var __ret = __Internal.FPDFTextGetCharOrigin(__arg0, index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetCharIndexAtPos</para>
        /// <para>Get the index of a character at or nearby a certain position on the</para>
        /// <para>page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>x           -   X position in PDF &quot;user space&quot;.</para>
        /// <para>y           -   Y position in PDF &quot;user space&quot;.</para>
        /// <para>xTolerance  -   An x-axis tolerance value for character hit detection, in point units.</para>
        /// <para>yTolerance  -   A y-axis tolerance value for character hit detection, in point units.</para>
        /// <para>Return Value:</para>
        /// <para>The zero-based index of the character at, or nearby the point (x,y).</para>
        /// <para>If there is no character at or nearby the point, return value will</para>
        /// <para>be -1. If an error occurs, -3 will be returned.</para>
        /// </summary>
        public static int FPDFTextGetCharIndexAtPos(global::PDFiumCore.FpdfTextpageT text_page, double x, double y, double xTolerance, double yTolerance)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextGetCharIndexAtPos(__arg0, x, y, xTolerance, yTolerance);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetText</para>
        /// <para>Extract unicode text string from the page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>start_index -   Index for the start characters.</para>
        /// <para>count       -   Number of characters to be extracted.</para>
        /// <para>result      -   A buffer (allocated by application) receiving the extracted unicodes. The size of the buffer must be able to hold the number of characters plus a terminator.</para>
        /// <para>Return Value:</para>
        /// <para>Number of characters written into the result buffer, including the</para>
        /// <para>trailing terminator.</para>
        /// <para>Comments: This function ignores characters without unicode information.</para>
        /// </summary>
        public static int FPDFTextGetText(global::PDFiumCore.FpdfTextpageT text_page, int start_index, int count, ref ushort result)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __result3 = &result)
            {
                var __arg3 = __result3;
                var __ret = __Internal.FPDFTextGetText(__arg0, start_index, count, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_CountRects</para>
        /// <para>Count number of rectangular areas occupied by a segment of texts.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>start_index -   Index for the start characters.</para>
        /// <para>count       -   Number of characters.</para>
        /// <para>Return value:</para>
        /// <para>Number of rectangles. Zero for error.</para>
        /// <para>Comments: This function, along with FPDFText_GetRect can be used by applications to detect the position on the page for a text segment, so proper areas can be highlighted. FPDFTEXT will automatically merge small character boxes into bigger one if those characters are on the same line and use same font settings.</para>
        /// </summary>
        public static int FPDFTextCountRects(global::PDFiumCore.FpdfTextpageT text_page, int start_index, int count)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFTextCountRects(__arg0, start_index, count);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetRect</para>
        /// <para>Get a rectangular area from the result generated by</para>
        /// <para>FPDFText_CountRects.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>rect_index  -   Zero-based index for the rectangle.</para>
        /// <para>left        -   Pointer to a double value receiving the rectangle left boundary.</para>
        /// <para>top         -   Pointer to a double value receiving the rectangle top boundary.</para>
        /// <para>right       -   Pointer to a double value receiving the rectangle right boundary.</para>
        /// <para>bottom      -   Pointer to a double value receiving the rectangle bottom boundary.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |top|, |right|, and</para>
        /// <para>|bottom|. If |text_page| is invalid then return FALSE, and the out</para>
        /// <para>parameters remain unmodified. If |text_page| is valid but</para>
        /// <para>|rect_index| is out of bounds, then return FALSE and set the out</para>
        /// <para>parameters to 0.</para>
        /// </summary>
        public static int FPDFTextGetRect(global::PDFiumCore.FpdfTextpageT text_page, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __top3 = &top)
                {
                    var __arg3 = __top3;
                    fixed (double* __right4 = &right)
                    {
                        var __arg4 = __right4;
                        fixed (double* __bottom5 = &bottom)
                        {
                            var __arg5 = __bottom5;
                            var __ret = __Internal.FPDFTextGetRect(__arg0, rect_index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_GetBoundedText</para>
        /// <para>Extract unicode text within a rectangular boundary on the page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>left        -   Left boundary.</para>
        /// <para>top         -   Top boundary.</para>
        /// <para>right       -   Right boundary.</para>
        /// <para>bottom      -   Bottom boundary.</para>
        /// <para>buffer      -   A unicode buffer.</para>
        /// <para>buflen      -   Number of characters (not bytes) for the buffer, excluding an additional terminator.</para>
        /// <para>Return Value:</para>
        /// <para>If buffer is NULL or buflen is zero, return number of characters</para>
        /// <para>(not bytes) of text present within the rectangle, excluding a</para>
        /// <para>terminating NUL. Generally you should pass a buffer at least one</para>
        /// <para>larger than this if you want a terminating NUL, which will be</para>
        /// <para>provided if space is available. Otherwise, return number of</para>
        /// <para>characters copied into the buffer, including the terminating NUL</para>
        /// <para>when space for it is available.</para>
        /// <para>Comment:</para>
        /// <para>If the buffer is too small, as much text as will fit is copied into</para>
        /// <para>it.</para>
        /// </summary>
        public static int FPDFTextGetBoundedText(global::PDFiumCore.FpdfTextpageT text_page, double left, double top, double right, double bottom, ref ushort buffer, int buflen)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __buffer5 = &buffer)
            {
                var __arg5 = __buffer5;
                var __ret = __Internal.FPDFTextGetBoundedText(__arg0, left, top, right, bottom, __arg5, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_FindStart</para>
        /// <para>Start a search.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>findwhat    -   A unicode match pattern.</para>
        /// <para>flags       -   Option flags.</para>
        /// <para>start_index -   Start from this character. -1 for end of the page.</para>
        /// <para>Return Value:</para>
        /// <para>A handle for the search context. FPDFText_FindClose must be called</para>
        /// <para>to release this handle.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfSchhandleT FPDFTextFindStart(global::PDFiumCore.FpdfTextpageT text_page, ref ushort findwhat, uint flags, int start_index)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __findwhat1 = &findwhat)
            {
                var __arg1 = __findwhat1;
                var __ret = __Internal.FPDFTextFindStart(__arg0, __arg1, flags, start_index);
                global::PDFiumCore.FpdfSchhandleT __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::PDFiumCore.FpdfSchhandleT.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::PDFiumCore.FpdfSchhandleT) global::PDFiumCore.FpdfSchhandleT.NativeToManagedMap[__ret];
                else __result0 = global::PDFiumCore.FpdfSchhandleT.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Function: FPDFText_FindNext</para>
        /// <para>Search in the direction from page start to end.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Whether a match is found.</para>
        /// </summary>
        public static int FPDFTextFindNext(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextFindNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_FindPrev</para>
        /// <para>Search in the direction from page end to start.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Whether a match is found.</para>
        /// </summary>
        public static int FPDFTextFindPrev(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextFindPrev(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetSchResultIndex</para>
        /// <para>Get the starting character index of the search result.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Index for the starting character.</para>
        /// </summary>
        public static int FPDFTextGetSchResultIndex(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextGetSchResultIndex(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_GetSchCount</para>
        /// <para>Get the number of matched characters in the search result.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>Number of matched characters.</para>
        /// </summary>
        public static int FPDFTextGetSchCount(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            var __ret = __Internal.FPDFTextGetSchCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFText_FindClose</para>
        /// <para>Release a search context.</para>
        /// <para>Parameters:</para>
        /// <para>handle      -   A search context handle returned by FPDFText_FindStart.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFTextFindClose(global::PDFiumCore.FpdfSchhandleT handle)
        {
            var __arg0 = ReferenceEquals(handle, null) ? global::System.IntPtr.Zero : handle.__Instance;
            __Internal.FPDFTextFindClose(__arg0);
        }

        /// <summary>
        /// <para>Function: FPDFLink_LoadWebLinks</para>
        /// <para>Prepare information about weblinks in a page.</para>
        /// <para>Parameters:</para>
        /// <para>text_page   -   Handle to a text page information structure. Returned by FPDFText_LoadPage function.</para>
        /// <para>Return Value:</para>
        /// <para>A handle to the page's links information structure, or</para>
        /// <para>NULL if something goes wrong.</para>
        /// <para>Comments: Weblinks are those links implicitly embedded in PDF pages. PDF also has a type of annotation called &quot;link&quot; (FPDFTEXT doesn't deal with that kind of link). FPDFTEXT weblink feature is useful for automatically detecting links in the page contents. For example, things like &quot;https://www.example.com&quot; will be detected, so applications can allow user to click on those characters to activate the link, even the PDF doesn't come with link annotations.</para>
        /// <para>FPDFLink_CloseWebLinks must be called to release resources.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPagelinkT FPDFLinkLoadWebLinks(global::PDFiumCore.FpdfTextpageT text_page)
        {
            var __arg0 = ReferenceEquals(text_page, null) ? global::System.IntPtr.Zero : text_page.__Instance;
            var __ret = __Internal.FPDFLinkLoadWebLinks(__arg0);
            global::PDFiumCore.FpdfPagelinkT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPagelinkT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPagelinkT) global::PDFiumCore.FpdfPagelinkT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPagelinkT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Function: FPDFLink_CountWebLinks</para>
        /// <para>Count number of detected web links.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>Return Value:</para>
        /// <para>Number of detected web links.</para>
        /// </summary>
        public static int FPDFLinkCountWebLinks(global::PDFiumCore.FpdfPagelinkT link_page)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            var __ret = __Internal.FPDFLinkCountWebLinks(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetURL</para>
        /// <para>Fetch the URL information for a detected web link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>buffer      -   A unicode buffer for the result.</para>
        /// <para>buflen      -   Number of 16-bit code units (not bytes) for the buffer, including an additional terminator.</para>
        /// <para>Return Value:</para>
        /// <para>If |buffer| is NULL or |buflen| is zero, return the number of 16-bit</para>
        /// <para>code units (not bytes) needed to buffer the result (an additional</para>
        /// <para>terminator is included in this count).</para>
        /// <para>Otherwise, copy the result into |buffer|, truncating at |buflen| if</para>
        /// <para>the result is too large to fit, and return the number of 16-bit code</para>
        /// <para>units actually copied into the buffer (the additional terminator is</para>
        /// <para>also included in this count).</para>
        /// <para>If |link_index| does not correspond to a valid link, then the result</para>
        /// <para>is an empty string.</para>
        /// </summary>
        public static int FPDFLinkGetURL(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, ref ushort buffer, int buflen)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var __ret = __Internal.FPDFLinkGetURL(__arg0, link_index, __arg2, buflen);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_CountRects</para>
        /// <para>Count number of rectangular areas for the link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>Return Value:</para>
        /// <para>Number of rectangular areas for the link.  If |link_index| does</para>
        /// <para>not correspond to a valid link, then 0 is returned.</para>
        /// </summary>
        public static int FPDFLinkCountRects(global::PDFiumCore.FpdfPagelinkT link_page, int link_index)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            var __ret = __Internal.FPDFLinkCountRects(__arg0, link_index);
            return __ret;
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetRect</para>
        /// <para>Fetch the boundaries of a rectangle for a link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index  -   Zero-based index for the link.</para>
        /// <para>rect_index  -   Zero-based index for a rectangle.</para>
        /// <para>left        -   Pointer to a double value receiving the rectangle left boundary.</para>
        /// <para>top         -   Pointer to a double value receiving the rectangle top boundary.</para>
        /// <para>right       -   Pointer to a double value receiving the rectangle right boundary.</para>
        /// <para>bottom      -   Pointer to a double value receiving the rectangle bottom boundary.</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |left|, |top|, |right|, and</para>
        /// <para>|bottom|. If |link_page| is invalid or if |link_index| does not</para>
        /// <para>correspond to a valid link, then return FALSE, and the out</para>
        /// <para>parameters remain unmodified.</para>
        /// </summary>
        public static int FPDFLinkGetRect(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            fixed (double* __left3 = &left)
            {
                var __arg3 = __left3;
                fixed (double* __top4 = &top)
                {
                    var __arg4 = __top4;
                    fixed (double* __right5 = &right)
                    {
                        var __arg5 = __right5;
                        fixed (double* __bottom6 = &bottom)
                        {
                            var __arg6 = __bottom6;
                            var __ret = __Internal.FPDFLinkGetRect(__arg0, link_index, rect_index, __arg3, __arg4, __arg5, __arg6);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_GetTextRange</para>
        /// <para>Fetch the start char index and char count for a link.</para>
        /// <para>Parameters:</para>
        /// <para>link_page         -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>link_index        -   Zero-based index for the link.</para>
        /// <para>start_char_index  -   pointer to int receiving the start char index</para>
        /// <para>char_count        -   pointer to int receiving the char count</para>
        /// <para>Return Value:</para>
        /// <para>On success, return TRUE and fill in |start_char_index| and</para>
        /// <para>|char_count|. if |link_page| is invalid or if |link_index| does</para>
        /// <para>not correspond to a valid link, then return FALSE and the out</para>
        /// <para>parameters remain unmodified.</para>
        /// </summary>
        public static int FPDFLinkGetTextRange(global::PDFiumCore.FpdfPagelinkT link_page, int link_index, ref int start_char_index, ref int char_count)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            fixed (int* __start_char_index2 = &start_char_index)
            {
                var __arg2 = __start_char_index2;
                fixed (int* __char_count3 = &char_count)
                {
                    var __arg3 = __char_count3;
                    var __ret = __Internal.FPDFLinkGetTextRange(__arg0, link_index, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Function: FPDFLink_CloseWebLinks</para>
        /// <para>Release resources used by weblink feature.</para>
        /// <para>Parameters:</para>
        /// <para>link_page   -   Handle returned by FPDFLink_LoadWebLinks.</para>
        /// <para>Return Value:</para>
        /// <para>None.</para>
        /// </summary>
        public static void FPDFLinkCloseWebLinks(global::PDFiumCore.FpdfPagelinkT link_page)
        {
            var __arg0 = ReferenceEquals(link_page, null) ? global::System.IntPtr.Zero : link_page.__Instance;
            __Internal.FPDFLinkCloseWebLinks(__arg0);
        }
    }

    public unsafe partial class fpdf_thumbnail
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetDecodedThumbnailData")]
            internal static extern uint FPDFPageGetDecodedThumbnailData(global::System.IntPtr page, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetRawThumbnailData")]
            internal static extern uint FPDFPageGetRawThumbnailData(global::System.IntPtr page, global::System.IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetThumbnailAsBitmap")]
            internal static extern global::System.IntPtr FPDFPageGetThumbnailAsBitmap(global::System.IntPtr page);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the decoded data from the thumbnail of |page| if it exists.</para>
        /// <para>This only modifies |buffer| if |buflen| less than or equal to the</para>
        /// <para>size of the decoded data. Returns the size of the decoded</para>
        /// <para>data or 0 if thumbnail DNE. Optional, pass null to just retrieve</para>
        /// <para>the size of the buffer needed.</para>
        /// <para>page    - handle to a page.</para>
        /// <para>buffer  - buffer for holding the decoded image data.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// </summary>
        public static uint FPDFPageGetDecodedThumbnailData(global::PDFiumCore.FpdfPageT page, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetDecodedThumbnailData(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Gets the raw data from the thumbnail of |page| if it exists.</para>
        /// <para>This only modifies |buffer| if |buflen| is less than or equal to</para>
        /// <para>the size of the raw data. Returns the size of the raw data or 0</para>
        /// <para>if thumbnail DNE. Optional, pass null to just retrieve the size</para>
        /// <para>of the buffer needed.</para>
        /// <para>page    - handle to a page.</para>
        /// <para>buffer  - buffer for holding the raw image data.</para>
        /// <para>buflen  - length of the buffer in bytes.</para>
        /// </summary>
        public static uint FPDFPageGetRawThumbnailData(global::PDFiumCore.FpdfPageT page, global::System.IntPtr buffer, uint buflen)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetRawThumbnailData(__arg0, buffer, buflen);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Returns the thumbnail of |page| as a FPDF_BITMAP. Returns a nullptr</para>
        /// <para>if unable to access the thumbnail's stream.</para>
        /// <para>page - handle to a page.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfBitmapT FPDFPageGetThumbnailAsBitmap(global::PDFiumCore.FpdfPageT page)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __ret = __Internal.FPDFPageGetThumbnailAsBitmap(__arg0);
            global::PDFiumCore.FpdfBitmapT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfBitmapT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfBitmapT) global::PDFiumCore.FpdfBitmapT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfBitmapT.__CreateInstance(__ret);
            return __result0;
        }
    }

    public unsafe partial class fpdf_transformpage
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetMediaBox")]
            internal static extern void FPDFPageSetMediaBox(global::System.IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetCropBox")]
            internal static extern void FPDFPageSetCropBox(global::System.IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetBleedBox")]
            internal static extern void FPDFPageSetBleedBox(global::System.IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetTrimBox")]
            internal static extern void FPDFPageSetTrimBox(global::System.IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_SetArtBox")]
            internal static extern void FPDFPageSetArtBox(global::System.IntPtr page, float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetMediaBox")]
            internal static extern int FPDFPageGetMediaBox(global::System.IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetCropBox")]
            internal static extern int FPDFPageGetCropBox(global::System.IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetBleedBox")]
            internal static extern int FPDFPageGetBleedBox(global::System.IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetTrimBox")]
            internal static extern int FPDFPageGetTrimBox(global::System.IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_GetArtBox")]
            internal static extern int FPDFPageGetArtBox(global::System.IntPtr page, float* left, float* bottom, float* right, float* top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_TransFormWithClip")]
            internal static extern int FPDFPageTransFormWithClip(global::System.IntPtr page, global::System.IntPtr matrix, global::System.IntPtr clipRect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_TransformClipPath")]
            internal static extern void FPDFPageObjTransformClipPath(global::System.IntPtr page_object, double a, double b, double c, double d, double e, double f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPageObj_GetClipPath")]
            internal static extern global::System.IntPtr FPDFPageObjGetClipPath(global::System.IntPtr page_object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFClipPath_CountPaths")]
            internal static extern int FPDFClipPathCountPaths(global::System.IntPtr clip_path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFClipPath_CountPathSegments")]
            internal static extern int FPDFClipPathCountPathSegments(global::System.IntPtr clip_path, int path_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFClipPath_GetPathSegment")]
            internal static extern global::System.IntPtr FPDFClipPathGetPathSegment(global::System.IntPtr clip_path, int path_index, int segment_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_CreateClipPath")]
            internal static extern global::System.IntPtr FPDF_CreateClipPath(float left, float bottom, float right, float top);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDF_DestroyClipPath")]
            internal static extern void FPDF_DestroyClipPath(global::System.IntPtr clipPath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("pdfium", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="FPDFPage_InsertClipPath")]
            internal static extern void FPDFPageInsertClipPath(global::System.IntPtr page, global::System.IntPtr clipPath);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;MediaBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetMediaBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetMediaBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;CropBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetCropBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetCropBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;BleedBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetBleedBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetBleedBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;TrimBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetTrimBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetTrimBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Set &quot;ArtBox&quot; entry to the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - The left of the rectangle.</para>
        /// <para>bottom - The bottom of the rectangle.</para>
        /// <para>right  - The right of the rectangle.</para>
        /// <para>top    - The top of the rectangle.</para>
        /// </summary>
        public static void FPDFPageSetArtBox(global::PDFiumCore.FpdfPageT page, float left, float bottom, float right, float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            __Internal.FPDFPageSetArtBox(__arg0, left, bottom, right, top);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;MediaBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetMediaBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetMediaBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;CropBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetCropBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetCropBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;BleedBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetBleedBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetBleedBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;TrimBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetTrimBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetTrimBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Get &quot;ArtBox&quot; entry from the page dictionary.</para>
        /// <para>page   - Handle to a page.</para>
        /// <para>left   - Pointer to a float value receiving the left of the rectangle.</para>
        /// <para>bottom - Pointer to a float value receiving the bottom of the rectangle.</para>
        /// <para>right  - Pointer to a float value receiving the right of the rectangle.</para>
        /// <para>top    - Pointer to a float value receiving the top of the rectangle.</para>
        /// <para>On success, return true and write to the out parameters. Otherwise return</para>
        /// <para>false and leave the out parameters unmodified.</para>
        /// </summary>
        public static int FPDFPageGetArtBox(global::PDFiumCore.FpdfPageT page, ref float left, ref float bottom, ref float right, ref float top)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            fixed (float* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (float* __bottom2 = &bottom)
                {
                    var __arg2 = __bottom2;
                    fixed (float* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (float* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            var __ret = __Internal.FPDFPageGetArtBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Apply transforms to |page|.</para>
        /// <para>If |matrix| is provided it will be applied to transform the page.</para>
        /// <para>If |clipRect| is provided it will be used to clip the resulting page.</para>
        /// <para>If neither |matrix| or |clipRect| are provided this method returns |false|.</para>
        /// <para>Returns |true| if transforms are applied.</para>
        /// <para>This function will transform the whole page, and would take effect to all the</para>
        /// <para>objects in the page.</para>
        /// <para>page        - Page handle.</para>
        /// <para>matrix      - Transform matrix.</para>
        /// <para>clipRect    - Clipping rectangle.</para>
        /// </summary>
        public static int FPDFPageTransFormWithClip(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FS_MATRIX_ matrix, global::PDFiumCore.FS_RECTF_ clipRect)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(matrix, null) ? global::System.IntPtr.Zero : matrix.__Instance;
            var __arg2 = ReferenceEquals(clipRect, null) ? global::System.IntPtr.Zero : clipRect.__Instance;
            var __ret = __Internal.FPDFPageTransFormWithClip(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Transform (scale, rotate, shear, move) the clip path of page object.</para>
        /// <para>page_object - Handle to a page object. Returned by</para>
        /// <para>FPDFPageObj_NewImageObj().</para>
        /// <para>a  - The coefficient &quot;a&quot; of the matrix.</para>
        /// <para>b  - The coefficient &quot;b&quot; of the matrix.</para>
        /// <para>c  - The coefficient &quot;c&quot; of the matrix.</para>
        /// <para>d  - The coefficient &quot;d&quot; of the matrix.</para>
        /// <para>e  - The coefficient &quot;e&quot; of the matrix.</para>
        /// <para>f  - The coefficient &quot;f&quot; of the matrix.</para>
        /// </summary>
        public static void FPDFPageObjTransformClipPath(global::PDFiumCore.FpdfPageobjectT page_object, double a, double b, double c, double d, double e, double f)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            __Internal.FPDFPageObjTransformClipPath(__arg0, a, b, c, d, e, f);
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get the clip path of the page object.</para>
        /// <para>page object - Handle to a page object. Returned by e.g.</para>
        /// <para>FPDFPage_GetObject().</para>
        /// <para>Returns the handle to the clip path, or NULL on failure. The caller does not</para>
        /// <para>take ownership of the returned FPDF_CLIPPATH. Instead, it remains valid until</para>
        /// <para>FPDF_ClosePage() is called for the page containing |page_object|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfClippathT FPDFPageObjGetClipPath(global::PDFiumCore.FpdfPageobjectT page_object)
        {
            var __arg0 = ReferenceEquals(page_object, null) ? global::System.IntPtr.Zero : page_object.__Instance;
            var __ret = __Internal.FPDFPageObjGetClipPath(__arg0);
            global::PDFiumCore.FpdfClippathT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfClippathT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfClippathT) global::PDFiumCore.FpdfClippathT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfClippathT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of paths inside |clip_path|.</para>
        /// <para>clip_path - handle to a clip_path.</para>
        /// <para>Returns the number of objects in |clip_path| or -1 on failure.</para>
        /// </summary>
        public static int FPDFClipPathCountPaths(global::PDFiumCore.FpdfClippathT clip_path)
        {
            var __arg0 = ReferenceEquals(clip_path, null) ? global::System.IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathCountPaths(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get number of segments inside one path of |clip_path|.</para>
        /// <para>clip_path  - handle to a clip_path.</para>
        /// <para>path_index - index into the array of paths of the clip path.</para>
        /// <para>Returns the number of segments or -1 on failure.</para>
        /// </summary>
        public static int FPDFClipPathCountPathSegments(global::PDFiumCore.FpdfClippathT clip_path, int path_index)
        {
            var __arg0 = ReferenceEquals(clip_path, null) ? global::System.IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathCountPathSegments(__arg0, path_index);
            return __ret;
        }

        /// <summary>
        /// <para>Experimental API.</para>
        /// <para>Get segment in one specific path of |clip_path| at index.</para>
        /// <para>clip_path     - handle to a clip_path.</para>
        /// <para>path_index    - the index of a path.</para>
        /// <para>segment_index - the index of a segment.</para>
        /// <para>Returns the handle to the segment, or NULL on failure. The caller does not</para>
        /// <para>take ownership of the returned FPDF_PATHSEGMENT. Instead, it remains valid</para>
        /// <para>until FPDF_ClosePage() is called for the page containing |clip_path|.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfPathsegmentT FPDFClipPathGetPathSegment(global::PDFiumCore.FpdfClippathT clip_path, int path_index, int segment_index)
        {
            var __arg0 = ReferenceEquals(clip_path, null) ? global::System.IntPtr.Zero : clip_path.__Instance;
            var __ret = __Internal.FPDFClipPathGetPathSegment(__arg0, path_index, segment_index);
            global::PDFiumCore.FpdfPathsegmentT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfPathsegmentT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfPathsegmentT) global::PDFiumCore.FpdfPathsegmentT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfPathsegmentT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Create a new clip path, with a rectangle inserted.</para>
        /// <para>Caller takes ownership of the returned FPDF_CLIPPATH. It should be freed with</para>
        /// <para>FPDF_DestroyClipPath().</para>
        /// <para>left   - The left of the clip box.</para>
        /// <para>bottom - The bottom of the clip box.</para>
        /// <para>right  - The right of the clip box.</para>
        /// <para>top    - The top of the clip box.</para>
        /// </summary>
        public static global::PDFiumCore.FpdfClippathT FPDF_CreateClipPath(float left, float bottom, float right, float top)
        {
            var __ret = __Internal.FPDF_CreateClipPath(left, bottom, right, top);
            global::PDFiumCore.FpdfClippathT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::PDFiumCore.FpdfClippathT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::PDFiumCore.FpdfClippathT) global::PDFiumCore.FpdfClippathT.NativeToManagedMap[__ret];
            else __result0 = global::PDFiumCore.FpdfClippathT.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Destroy the clip path.</para>
        /// <para>clipPath - A handle to the clip path. It will be invalid after this call.</para>
        /// </summary>
        public static void FPDF_DestroyClipPath(global::PDFiumCore.FpdfClippathT clipPath)
        {
            var __arg0 = ReferenceEquals(clipPath, null) ? global::System.IntPtr.Zero : clipPath.__Instance;
            __Internal.FPDF_DestroyClipPath(__arg0);
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Clip the page content, the page content that outside the clipping region</para>
        /// <para>become invisible.</para>
        /// <para>A clip path will be inserted before the page content stream or content array.</para>
        /// <para>In this way, the page content will be clipped by this clip path.</para>
        /// <para>page        - A page handle.</para>
        /// <para>clipPath    - A handle to the clip path. (Does not take ownership.)</para>
        /// </summary>
        public static void FPDFPageInsertClipPath(global::PDFiumCore.FpdfPageT page, global::PDFiumCore.FpdfClippathT clipPath)
        {
            var __arg0 = ReferenceEquals(page, null) ? global::System.IntPtr.Zero : page.__Instance;
            var __arg1 = ReferenceEquals(clipPath, null) ? global::System.IntPtr.Zero : clipPath.__Instance;
            __Internal.FPDFPageInsertClipPath(__arg0, __arg1);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_uint_bytePtr_uint(global::System.IntPtr param, uint position, byte* pBuf, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr(global::System.IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint_IntPtr(global::System.IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_uint_IntPtr_uint(global::System.IntPtr clientData, uint offset, global::System.IntPtr buffer, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr(global::System.IntPtr clientData);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_uint(global::System.IntPtr clientData, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_ushortPtr_ushortPtr_int_int(global::System.IntPtr pThis, ushort* Msg, ushort* Title, int Type, int Icon);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_int(global::System.IntPtr pThis, int nType);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_int_IntPtr_int(global::System.IntPtr pThis, ushort* Question, ushort* Title, ushort* Default, ushort* cLabel, int bPassword, global::System.IntPtr response, int length);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_IntPtr_int(global::System.IntPtr pThis, global::System.IntPtr filePath, int length);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_int_int_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr(global::System.IntPtr pThis, global::System.IntPtr mailData, int length, int bUI, ushort* To, ushort* Subject, ushort* CC, ushort* BCC, ushort* Msg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_int_int_int_int_int_int_int_int(global::System.IntPtr pThis, int bUI, int nStart, int nEnd, int bSilent, int bShrinkToFit, int bPrintAsImage, int bReverse, int bAnnotations);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_int_ushortPtr(global::System.IntPtr pThis, global::System.IntPtr formData, int length, ushort* URL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_double_double_double_double(global::System.IntPtr pThis, global::System.IntPtr page, double left, double top, double right, double bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_int_PDFiumCore_TimerCallback(global::System.IntPtr pThis, int uElapse, global::PDFiumCore.TimerCallback lpTimerFunc);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::PDFiumCore.FPDF_SYSTEMTIME.__Internal Func_PDFiumCore__FPDF_SYSTEMTIME___Internal_IntPtr(global::System.IntPtr pThis);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_IntPtr_int(global::System.IntPtr pThis, global::System.IntPtr document, int nPageIndex);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_IntPtr(global::System.IntPtr pThis, global::System.IntPtr document);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_IntPtr(global::System.IntPtr pThis, global::System.IntPtr page);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_string(global::System.IntPtr pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string namedAction);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_ushortPtr_uint_int(global::System.IntPtr pThis, ushort* value, uint valueLen, int is_focus);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_int_int_floatPtr_int(global::System.IntPtr pThis, int nPageIndex, int zoomMode, float* fPosArray, int sizeofArray);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_int_double_double_double_double(global::System.IntPtr pThis, global::System.IntPtr page, int bVisible, double left, double top, double right, double bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_int(global::System.IntPtr pThis, global::System.IntPtr document, int iCurPage);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_ushortPtr(global::System.IntPtr pThis, global::System.IntPtr document, ushort* wsURL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_doublePtr_doublePtr_doublePtr_doublePtr(global::System.IntPtr pThis, global::System.IntPtr page, double* left, double* top, double* right, double* bottom);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_int_uint(global::System.IntPtr pThis, int page_count, uint event_type);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_IntPtr_IntPtr_int_float_float(global::System.IntPtr pThis, global::System.IntPtr page, global::System.IntPtr hWidget, int menuFlag, float x, float y);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_int_ushortPtr_string(global::System.IntPtr pThis, int fileFlag, ushort* wsURL, [MarshalAs(UnmanagedType.LPUTF8Str)] string mode);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr(global::System.IntPtr pThis, global::System.IntPtr fileHandler, ushort* pTo, ushort* pSubject, ushort* pCC, ushort* pBcc, ushort* pMsg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_ushortPtr(global::System.IntPtr pThis, ushort* URL);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_ushortPtr_IntPtr(global::System.IntPtr pThis, ushort* wsURL, ushort* wsData, ushort* wsContentType, ushort* wsEncode, ushort* wsHeader, global::System.IntPtr response);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_ushortPtr_ushortPtr_ushortPtr(global::System.IntPtr pThis, ushort* wsURL, ushort* wsData, ushort* wsEncode);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_string_int(global::System.IntPtr param, [MarshalAs(UnmanagedType.LPUTF8Str)] string uri, int modifiers);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_ulong_ulong(global::System.IntPtr pThis, ulong offset, ulong size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_ulong_ulong(global::System.IntPtr pThis, ulong offset, ulong size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int Func_int_IntPtr_IntPtr_uint(global::System.IntPtr pThis, global::System.IntPtr pData, uint size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr pThis, global::System.IntPtr pMapper);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_int_int_int_int_string_intPtr(global::System.IntPtr pThis, int weight, int bItalic, int charset, int pitch_family, [MarshalAs(UnmanagedType.LPUTF8Str)] string face, int* bExact);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_string(global::System.IntPtr pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string face);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint_IntPtr_IntPtr_uint_bytePtr_uint(global::System.IntPtr pThis, global::System.IntPtr hFont, uint table, byte* buffer, uint buf_size);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint_IntPtr_IntPtr_sbytePtr_uint(global::System.IntPtr pThis, global::System.IntPtr hFont, sbyte* buffer, uint buf_size);
    }
}
